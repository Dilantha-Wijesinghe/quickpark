This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.husky/
  pre-commit
apps/
  api/
    prisma/
      migrations/
        20240505193648_init/
          migration.sql
        migration_lock.toml
      seed/
        data.ts
        index.ts
        util.ts
      models.md
      schema.prisma
    src/
      common/
        auth/
          auth.decorator.ts
          auth.guard.ts
          util.ts
        dtos/
          common.dto.ts
          common.input.ts
        prisma/
          prisma.module.ts
          prisma.service.ts
        types/
          index.ts
        util.ts
      models/
        addresses/
          graphql/
            dtos/
              create-address.input.ts
              find.args.ts
              order-by.args.ts
              update-address.input.ts
              where.args.ts
            entity/
              address.entity.ts
            addresses.resolver.ts
            addresses.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              address.entity.ts
            addresses.controller.ts
          addresses.module.ts
        admins/
          graphql/
            dtos/
              create-admin.input.ts
              find.args.ts
              order-by.args.ts
              update-admin.input.ts
              where.args.ts
            entity/
              admin.entity.ts
            admins.resolver.ts
            admins.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              admin.entity.ts
            admins.controller.ts
          admins.module.ts
        booking-timelines/
          graphql/
            dtos/
              create-booking-timeline.input.ts
              find.args.ts
              order-by.args.ts
              update-booking-timeline.input.ts
              where.args.ts
            entity/
              booking-timeline.entity.ts
            booking-timelines.resolver.ts
            booking-timelines.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              booking-timeline.entity.ts
            booking-timelines.controller.ts
          booking-timelines.module.ts
        bookings/
          graphql/
            dtos/
              create-booking.input.ts
              find.args.ts
              order-by.args.ts
              update-booking.input.ts
              where.args.ts
            entity/
              booking.entity.ts
            bookings.resolver.ts
            bookings.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              booking.entity.ts
            bookings.controller.ts
          bookings.module.ts
        companies/
          graphql/
            dtos/
              create-company.input.ts
              find.args.ts
              order-by.args.ts
              update-company.input.ts
              where.args.ts
            entity/
              company.entity.ts
            companies.resolver.ts
            companies.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              company.entity.ts
            companies.controller.ts
          companies.module.ts
        customers/
          graphql/
            dtos/
              create-customer.input.ts
              find.args.ts
              order-by.args.ts
              update-customer.input.ts
              where.args.ts
            entity/
              customer.entity.ts
            customers.resolver.ts
            customers.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              customer.entity.ts
            customers.controller.ts
          customers.module.ts
        garages/
          graphql/
            dtos/
              create-garage.input.ts
              find.args.ts
              order-by.args.ts
              search-filter.input.ts
              update-garage.input.ts
              where.args.ts
            entity/
              garage.entity.ts
            garages.resolver.ts
            garages.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              garage.entity.ts
            garages.controller.ts
          garages.module.ts
        managers/
          graphql/
            dtos/
              create-manager.input.ts
              find.args.ts
              order-by.args.ts
              update-manager.input.ts
              where.args.ts
            entity/
              manager.entity.ts
            managers.resolver.ts
            managers.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              manager.entity.ts
            managers.controller.ts
          managers.module.ts
        reviews/
          graphql/
            dtos/
              create-review.input.ts
              find.args.ts
              order-by.args.ts
              update-review.input.ts
              where.args.ts
            entity/
              review.entity.ts
            reviews.resolver.ts
            reviews.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              review.entity.ts
            reviews.controller.ts
          reviews.module.ts
        slots/
          graphql/
            dtos/
              create-slot.input.ts
              find.args.ts
              order-by.args.ts
              update-slot.input.ts
              where.args.ts
            entity/
              slot.entity.ts
            slots.resolver.ts
            slots.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              slot.entity.ts
            slots.controller.ts
          slots.module.ts
        stripe/
          dto/
            create-stripe-session.dto.ts
          stripe.controller.ts
          stripe.module.ts
          stripe.service.ts
        users/
          graphql/
            dtos/
              create-user.input.ts
              find.args.ts
              order-by.args.ts
              update-user.input.ts
              where.args.ts
            entity/
              user.entity.ts
            users.resolver.ts
            users.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              user.entity.ts
            users.controller.ts
          users.module.ts
        valet-assignments/
          graphql/
            dtos/
              create-valet-assignment.input.ts
              find.args.ts
              order-by.args.ts
              update-valet-assignment.input.ts
              where.args.ts
            entity/
              valet-assignment.entity.ts
            valet-assignments.resolver.ts
            valet-assignments.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              valet-assignment.entity.ts
            valet-assignments.controller.ts
          valet-assignments.module.ts
        valets/
          graphql/
            dtos/
              create-valet.input.ts
              find.args.ts
              order-by.args.ts
              update-valet.input.ts
              where.args.ts
            entity/
              valet.entity.ts
            valets.resolver.ts
            valets.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              valet.entity.ts
            valets.controller.ts
          valets.module.ts
        verifications/
          graphql/
            dtos/
              create-verification.input.ts
              find.args.ts
              order-by.args.ts
              update-verification.input.ts
              where.args.ts
            entity/
              verification.entity.ts
            verifications.resolver.ts
            verifications.service.ts
          rest/
            dtos/
              create.dto.ts
              query.dto.ts
              update.dto.ts
            entity/
              verification.entity.ts
            verifications.controller.ts
          verifications.module.ts
      app.controller.spec.ts
      app.controller.ts
      app.module.ts
      app.service.ts
      main.ts
      schema.gql
    test/
      app.e2e-spec.ts
      jest-e2e.json
    .env.example
    .eslintrc.js
    .gitignore
    docker-compose.yml
    nest-cli.json
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
  web/
    public/
      next.svg
      vercel.svg
    src/
      app/
        api/
          auth/
            [...nextauth]/
              route.ts
            token/
              route.ts
        booking-failed/
          page.tsx
        bookings/
          page.tsx
        login/
          page.tsx
        register/
          page.tsx
        search/
          page.tsx
        layout.tsx
        page.tsx
    .env.example
    .eslintrc.json
    .gitignore
    next.config.mjs
    package.json
    postcss.config.js
    README.md
    tailwind.config.ts
    tsconfig.json
    types.d.ts
  web-admin/
    public/
      next.svg
      vercel.svg
    src/
      app/
        api/
          auth/
            [...nextauth]/
              route.ts
            token/
              route.ts
        login/
          page.tsx
        manageAdmins/
          page.tsx
        register/
          page.tsx
        layout.tsx
        page.tsx
    .env.example
    .eslintrc.json
    .gitignore
    next.config.mjs
    package.json
    postcss.config.mjs
    README.md
    tailwind.config.ts
    tsconfig.json
    types.d.ts
  web-manager/
    public/
      next.svg
      vercel.svg
    src/
      app/
        api/
          auth/
            [...nextauth]/
              route.ts
            token/
              route.ts
        bookings/
          page.tsx
        login/
          page.tsx
        new-garage/
          page.tsx
        register/
          page.tsx
        valets/
          page.tsx
        layout.tsx
        page.tsx
    .env.example
    .eslintrc.json
    .gitignore
    next.config.mjs
    package.json
    postcss.config.mjs
    README.md
    tailwind.config.ts
    tsconfig.json
    types.d.ts
  web-valet/
    public/
      next.svg
      vercel.svg
    src/
      app/
        api/
          auth/
            [...nextauth]/
              route.ts
            token/
              route.ts
        login/
          page.tsx
        my-trips/
          page.tsx
        register/
          page.tsx
        layout.tsx
        page.tsx
    .env.example
    .eslintrc.json
    .gitignore
    next.config.mjs
    package.json
    postcss.config.mjs
    README.md
    tailwind.config.ts
    tsconfig.json
    types.d.ts
libs/
  3d/
    src/
      components/
        camera/
          Rotating.tsx
        BlinkingParkingSlot.tsx
        Building.tsx
        BuildingSet.tsx
        Car.tsx
        GradientPlane.tsx
        Spawner.tsx
        Square.tsx
      scenes/
        CarScene.tsx
      util/
        buildingSets.ts
        comments.ts
        constants.ts
        index.ts
        types.ts
    package.json
    tsconfig.json
  forms/
    src/
      adapters/
        searchFormAdapter.ts
        util.ts
      util/
        index.ts
      bookSlot.tsx
      createCompany.ts
      createGarage.tsx
      createSlots.ts
      createUid.ts
      createValet.ts
      login.tsx
      register.tsx
      schemas.ts
      searchGarages.tsx
    package.json
    tsconfig.json
  network/
    src/
      config/
        apollo.tsx
        authOptions.ts
      fetch/
        index.ts
      gql/
        generated.tsx
        queries.graphql
    codegen.ts
    next-auth.d.ts
    package.json
    tsconfig.json
  sample-lib/
    index.ts
    package.json
    tsconfig.json
  ui/
    public/
      next.svg
      vercel.svg
    src/
      app/
        globals.css
        layout.tsx
        page.tsx
      components/
        atoms/
          Accordion.tsx
          Autocomplete.tsx
          Badge.tsx
          Brand.tsx
          BrandIcon.tsx
          Button.tsx
          Container.tsx
          Dialog.tsx
          Dot.tsx
          Form.tsx
          FormError.tsx
          HtmlInput.tsx
          HtmlLabel.tsx
          HtmlSelect.tsx
          HtmlTextArea.tsx
          ParkingIcon.tsx
          Switch.tsx
          TitleValue.tsx
        molecules/
          AlertSection.tsx
          AuthLayout.tsx
          CostTitleValue.tsx
          DateRangeBookingInfo.tsx
          FilterHeading.tsx
          GoogleButton.tsx
          IconTypes.tsx
          Loader.tsx
          LogoutButton.tsx
          MapLink.tsx
          NoResults.tsx
          RangeSlider.tsx
          Reveal.tsx
          SessionProvider.tsx
          Tabs.tsx
          Toast.tsx
          ToggleButtonGroup.tsx
          UserInfo.tsx
        organisms/
          admin/
            AdminCard.tsx
            CreateAdmin.tsx
            CreateVerificationButton.tsx
            RemoveAdminButton.tsx
            RemoveVerificationButton.tsx
          map/
            CurrentLocationButton.tsx
            map.css
            Map.tsx
            MapMarker.tsx
            Panel.tsx
            SearchPlacesBox.tsx
            StaticMapDirections.tsx
            StaticMapSimple.tsx
            ZoomControls.tsx
          search/
            FilterSidebar.tsx
            GarageMarker.tsx
            ShowGarages.tsx
          AddValet.tsx
          AssignValetButton.tsx
          AutoImageChanger.tsx
          BookSlotPopup.tsx
          CheckInOutButtons.tsx
          CreateCompany.tsx
          CreateGarageComponents.tsx
          CreateManySlotsDialog.tsx
          CustomerBookingCard.tsx
          DateCard.tsx
          Directions.tsx
          GarageAdminCard.tsx
          GarageCard.tsx
          Header.tsx
          ImagePreview.tsx
          IsAdmin.tsx
          IsLoggedIn.tsx
          IsManager.tsx
          IsValet.tsx
          ListGarages.tsx
          ListValets.tsx
          ManageBookingCard.tsx
          ManageValets.tsx
          Menus.tsx
          NavSidebar.tsx
          ShowCustomerBookings.tsx
          ShowData.tsx
          ShowGarageBookings.tsx
          ShowValetAllDropTrips.tsx
          ShowValetAllPickupTrips.tsx
          ShowValetMyDropTrips.tsx
          ShowValetMyPickupTrips.tsx
          Sidebar.tsx
          ValetCard.tsx
          ValetTripCard.tsx
        templates/
          AdminHome.tsx
          CreateGarage.tsx
          ListCustomerBookings.tsx
          ListGarageBookings.tsx
          LoginForm.tsx
          ManageAdmins.tsx
          ManageValets.tsx
          RegisterForm.tsx
          SearchPage.tsx
          ValetHome.tsx
          ValetTrips.tsx
      styles/
        config.js
    .eslintrc.json
    .gitignore
    next.config.mjs
    package.json
    postcss.config.mjs
    README.md
    tailwind.config.ts
    tsconfig.json
    types.d.ts
  util/
    hooks/
      async.ts
      cloudinary.ts
      dialog.ts
      directions.ts
      keys.ts
      location.ts
      pagination.ts
      price.ts
    constants.ts
    date.ts
    index.ts
    package.json
    tsconfig.json
    types.ts
.gitignore
.prettierrc
nx.json
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".husky/pre-commit">
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

yarn validate
</file>

<file path="apps/api/prisma/migrations/20240505193648_init/migration.sql">
-- CreateEnum
CREATE TYPE "AuthProviderType" AS ENUM ('GOOGLE', 'CREDENTIALS');

-- CreateEnum
CREATE TYPE "SlotType" AS ENUM ('CAR', 'HEAVY', 'BIKE', 'BICYCLE');

-- CreateEnum
CREATE TYPE "BookingStatus" AS ENUM ('BOOKED', 'VALET_ASSIGNED_FOR_CHECK_IN', 'VALET_PICKED_UP', 'CHECKED_IN', 'VALET_ASSIGNED_FOR_CHECK_OUT', 'CHECKED_OUT', 'VALET_RETURNED');

-- CreateTable
CREATE TABLE "User" (
    "uid" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "name" TEXT,
    "image" TEXT,

    CONSTRAINT "User_pkey" PRIMARY KEY ("uid")
);

-- CreateTable
CREATE TABLE "Admin" (
    "uid" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Admin_pkey" PRIMARY KEY ("uid")
);

-- CreateTable
CREATE TABLE "Credentials" (
    "uid" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "passwordHash" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Credentials_pkey" PRIMARY KEY ("uid")
);

-- CreateTable
CREATE TABLE "AuthProvider" (
    "uid" TEXT NOT NULL,
    "type" "AuthProviderType" NOT NULL,

    CONSTRAINT "AuthProvider_pkey" PRIMARY KEY ("uid")
);

-- CreateTable
CREATE TABLE "Customer" (
    "uid" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "displayName" TEXT,

    CONSTRAINT "Customer_pkey" PRIMARY KEY ("uid")
);

-- CreateTable
CREATE TABLE "Manager" (
    "uid" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "displayName" TEXT,
    "companyId" INTEGER,

    CONSTRAINT "Manager_pkey" PRIMARY KEY ("uid")
);

-- CreateTable
CREATE TABLE "Valet" (
    "uid" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "displayName" TEXT NOT NULL,
    "image" TEXT,
    "licenceID" TEXT NOT NULL DEFAULT '',
    "companyId" INTEGER,

    CONSTRAINT "Valet_pkey" PRIMARY KEY ("uid")
);

-- CreateTable
CREATE TABLE "Company" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "displayName" TEXT,
    "description" TEXT,

    CONSTRAINT "Company_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Garage" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "displayName" TEXT,
    "description" TEXT,
    "images" TEXT[],
    "companyId" INTEGER NOT NULL,

    CONSTRAINT "Garage_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Address" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "address" TEXT NOT NULL,
    "lat" DOUBLE PRECISION NOT NULL,
    "lng" DOUBLE PRECISION NOT NULL,
    "garageId" INTEGER NOT NULL,

    CONSTRAINT "Address_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Slot" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "displayName" TEXT,
    "pricePerHour" DOUBLE PRECISION NOT NULL,
    "length" INTEGER,
    "width" INTEGER,
    "height" INTEGER,
    "type" "SlotType" NOT NULL DEFAULT 'CAR',
    "garageId" INTEGER NOT NULL,

    CONSTRAINT "Slot_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Booking" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "pricePerHour" DOUBLE PRECISION,
    "totalPrice" DOUBLE PRECISION,
    "startTime" TIMESTAMP(3) NOT NULL,
    "endTime" TIMESTAMP(3) NOT NULL,
    "vehicleNumber" TEXT NOT NULL,
    "phoneNumber" TEXT,
    "passcode" TEXT,
    "status" "BookingStatus" NOT NULL DEFAULT 'BOOKED',
    "slotId" INTEGER NOT NULL,
    "customerId" TEXT NOT NULL,

    CONSTRAINT "Booking_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ValetAssignment" (
    "bookingId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "pickupLat" DOUBLE PRECISION,
    "pickupLng" DOUBLE PRECISION,
    "returnLat" DOUBLE PRECISION,
    "returnLng" DOUBLE PRECISION,
    "pickupValetId" TEXT,
    "returnValetId" TEXT,

    CONSTRAINT "ValetAssignment_pkey" PRIMARY KEY ("bookingId")
);

-- CreateTable
CREATE TABLE "BookingTimeline" (
    "id" SERIAL NOT NULL,
    "timestamp" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "status" "BookingStatus" NOT NULL,
    "bookingId" INTEGER NOT NULL,
    "valetId" TEXT,
    "managerId" TEXT,

    CONSTRAINT "BookingTimeline_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Review" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "rating" INTEGER NOT NULL DEFAULT 0,
    "comment" TEXT,
    "customerId" TEXT NOT NULL,
    "garageId" INTEGER NOT NULL,

    CONSTRAINT "Review_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Verification" (
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "verified" BOOLEAN NOT NULL DEFAULT false,
    "adminId" TEXT NOT NULL,
    "garageId" INTEGER NOT NULL,

    CONSTRAINT "Verification_pkey" PRIMARY KEY ("garageId")
);

-- CreateIndex
CREATE UNIQUE INDEX "Credentials_email_key" ON "Credentials"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Manager_companyId_key" ON "Manager"("companyId");

-- CreateIndex
CREATE UNIQUE INDEX "Valet_companyId_uid_key" ON "Valet"("companyId", "uid");

-- CreateIndex
CREATE UNIQUE INDEX "Address_garageId_key" ON "Address"("garageId");

-- CreateIndex
CREATE INDEX "Booking_startTime_endTime_idx" ON "Booking"("startTime", "endTime");

-- CreateIndex
CREATE INDEX "BookingTimeline_bookingId_idx" ON "BookingTimeline"("bookingId");

-- AddForeignKey
ALTER TABLE "Admin" ADD CONSTRAINT "Admin_uid_fkey" FOREIGN KEY ("uid") REFERENCES "User"("uid") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Credentials" ADD CONSTRAINT "Credentials_uid_fkey" FOREIGN KEY ("uid") REFERENCES "User"("uid") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AuthProvider" ADD CONSTRAINT "AuthProvider_uid_fkey" FOREIGN KEY ("uid") REFERENCES "User"("uid") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Customer" ADD CONSTRAINT "Customer_uid_fkey" FOREIGN KEY ("uid") REFERENCES "User"("uid") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Manager" ADD CONSTRAINT "Manager_uid_fkey" FOREIGN KEY ("uid") REFERENCES "User"("uid") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Manager" ADD CONSTRAINT "Manager_companyId_fkey" FOREIGN KEY ("companyId") REFERENCES "Company"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Valet" ADD CONSTRAINT "Valet_uid_fkey" FOREIGN KEY ("uid") REFERENCES "User"("uid") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Valet" ADD CONSTRAINT "Valet_companyId_fkey" FOREIGN KEY ("companyId") REFERENCES "Company"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Garage" ADD CONSTRAINT "Garage_companyId_fkey" FOREIGN KEY ("companyId") REFERENCES "Company"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Address" ADD CONSTRAINT "Address_garageId_fkey" FOREIGN KEY ("garageId") REFERENCES "Garage"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Slot" ADD CONSTRAINT "Slot_garageId_fkey" FOREIGN KEY ("garageId") REFERENCES "Garage"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Booking" ADD CONSTRAINT "Booking_slotId_fkey" FOREIGN KEY ("slotId") REFERENCES "Slot"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Booking" ADD CONSTRAINT "Booking_customerId_fkey" FOREIGN KEY ("customerId") REFERENCES "Customer"("uid") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ValetAssignment" ADD CONSTRAINT "ValetAssignment_pickupValetId_fkey" FOREIGN KEY ("pickupValetId") REFERENCES "Valet"("uid") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ValetAssignment" ADD CONSTRAINT "ValetAssignment_returnValetId_fkey" FOREIGN KEY ("returnValetId") REFERENCES "Valet"("uid") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ValetAssignment" ADD CONSTRAINT "ValetAssignment_bookingId_fkey" FOREIGN KEY ("bookingId") REFERENCES "Booking"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BookingTimeline" ADD CONSTRAINT "BookingTimeline_bookingId_fkey" FOREIGN KEY ("bookingId") REFERENCES "Booking"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BookingTimeline" ADD CONSTRAINT "BookingTimeline_valetId_fkey" FOREIGN KEY ("valetId") REFERENCES "Valet"("uid") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BookingTimeline" ADD CONSTRAINT "BookingTimeline_managerId_fkey" FOREIGN KEY ("managerId") REFERENCES "Manager"("uid") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Review" ADD CONSTRAINT "Review_customerId_fkey" FOREIGN KEY ("customerId") REFERENCES "Customer"("uid") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Review" ADD CONSTRAINT "Review_garageId_fkey" FOREIGN KEY ("garageId") REFERENCES "Garage"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Verification" ADD CONSTRAINT "Verification_adminId_fkey" FOREIGN KEY ("adminId") REFERENCES "Admin"("uid") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Verification" ADD CONSTRAINT "Verification_garageId_fkey" FOREIGN KEY ("garageId") REFERENCES "Garage"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="apps/api/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="apps/api/prisma/seed/data.ts">
import { generateSlots } from './util'
import { Prisma } from '@prisma/client'

export const garagesSample: Prisma.GarageCreateInput[] = [
  {
    displayName: 'Manhattan Garage 1',
    description: 'Secure parking in the heart of Manhattan',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716171734/autospace/create-a-cover-image-of-an-affordable-parking-garage-in-brooklyn-new-york-the-picture-should-featu-561631306_qir7we.jpg',
      ],
    },

    Address: {
      create: {
        address: '123 5th Ave, New York, NY 10001',
        lat: 40.712776,
        lng: -74.005974,
      },
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BIKE',
        }),
        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
  },
]
export const garages: Prisma.GarageCreateInput[] = [
  {
    displayName: 'Brooklyn Garage 1',
    description: 'Affordable parking in Brooklyn',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716171734/autospace/create-a-cover-image-of-an-affordable-and-clean-parking-garage-in-brooklyn-new-york-the-picture-sh-825512221_kzvig6.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BICYCLE',
        }),
      ],
    },
    Address: {
      create: {
        address: '456 Court St, Brooklyn, NY 11231',
        lat: 40.678178,
        lng: -73.944158,
      },
    },
  },
  {
    displayName: 'Queens Garage 1',
    description: 'Convenient parking in Queens',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716171734/autospace/design-a-cover-picture-for-a-convenient-parking-garage-in-queens-new-york-the-image-should-show-a--976407210_la43y2.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '789 Queens Blvd, Queens, NY 11373',
        lat: 40.728224,
        lng: -73.794852,
      },
    },
  },
  {
    displayName: 'Manhattan Garage 2',
    description: 'Secure parking near Central Park',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716171734/autospace/design-a-cover-picture-for-a-convenient-parking-garage-in-queens-new-york-the-image-should-show-a--639233464_tuskex.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BICYCLE',
        }),

        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '101 Central Park West, New York, NY 10023',
        lat: 40.7812,
        lng: -73.9665,
      },
    },
  },
  {
    displayName: 'Brooklyn Garage 2',
    description: 'Spacious parking in Brooklyn Heights',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716171733/autospace/design-a-cover-picture-for-a-parking-garage-in-long-island-city-queens-new-york-the-image-should--184920453_v8umyi.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BIKE',
        }),
      ],
    },
    Address: {
      create: {
        address: '202 Atlantic Ave, Brooklyn, NY 11201',
        lat: 40.6912,
        lng: -73.9936,
      },
    },
  },
  {
    displayName: 'Queens Garage 2',
    description: 'Safe parking in Flushing',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716171733/autospace/create-a-cover-image-of-a-spacious-parking-garage-in-brooklyn-heights-new-york-the-picture-should--539597916_obi5kl.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BICYCLE',
        }),
        ...generateSlots({
          type: 'BIKE',
        }),
        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '303 Main St, Flushing, NY 11354',
        lat: 40.759,
        lng: -73.8303,
      },
    },
  },
  {
    displayName: 'Manhattan Garage 3',
    description: 'Parking near Times Square',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716171733/autospace/design-a-cover-picture-for-a-parking-garage-in-long-island-city-queens-new-york-the-image-should--110448605_bqjzmf.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BIKE',
        }),
      ],
    },
    Address: {
      create: {
        address: '1515 Broadway, New York, NY 10036',
        lat: 40.758,
        lng: -73.9855,
      },
    },
  },
  {
    displayName: 'Brooklyn Garage 3',
    description: 'Secure parking in Williamsburg',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716171733/autospace/render-a-cover-picture-of-a-secure-parking-garage-near-central-park-in-manhattan-new-york-the-imag-736153979_kvpczt.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '404 Bedford Ave, Brooklyn, NY 11249',
        lat: 40.7081,
        lng: -73.9571,
      },
    },
  },
  {
    displayName: 'Queens Garage 3',
    description: 'Affordable parking in Astoria',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716171733/autospace/create-a-cover-image-of-an-affordable-clean-outdoor-parking-garage-in-brooklyn-new-york-the-pict-620611113_ortr3g.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '505 Steinway St, Astoria, NY 11103',
        lat: 40.7592,
        lng: -73.9196,
      },
    },
  },
  {
    displayName: 'Manhattan Garage 4',
    description: 'Parking near Wall Street',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158769/autospace/busy-parking-garage-with-slots-in-newyork-neon-ambiance-abstract-black-oil-gear-mecha-detailed-a_fy51wa.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BICYCLE',
        }),

        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '75 Wall St, New York, NY 10005',
        lat: 40.7074,
        lng: -74.0104,
      },
    },
  },
  {
    displayName: 'Brooklyn Garage 4',
    description: 'Parking near Prospect Park',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158768/autospace/brand-new-ultra-modern-techno-parking-garage-with-slots-showing-newyork-skyline-haze-ultra-detail_n1hhhz.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BICYCLE',
        }),
        ...generateSlots({
          type: 'BIKE',
        }),
        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '606 Flatbush Ave, Brooklyn, NY 11225',
        lat: 40.6591,
        lng: -73.9626,
      },
    },
  },
  {
    displayName: 'Queens Garage 4',
    description: 'Parking near LaGuardia Airport',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158768/autospace/brand-new-ultra-modern-car-parking-garage-with-slots-wide-angle-haze-ultra-detailed-film-photogr_kst6l1.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BIKE',
        }),
      ],
    },
    Address: {
      create: {
        address: '707 Ditmars Blvd, Queens, NY 11370',
        lat: 40.7743,
        lng: -73.8896,
      },
    },
  },
  {
    displayName: 'Manhattan Garage 5',
    description: 'Secure parking in the East Village',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158768/autospace/busy-parking-garage-near-a-newyork-central-park-acrylic-painting-trending-on-pixiv-fanbox-palette-790070610_pptabc.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '808 E 14th St, New York, NY 10009',
        lat: 40.7295,
        lng: -73.9786,
      },
    },
  },
  {
    displayName: 'Brooklyn Garage 5',
    description: 'Parking in Greenpoint',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158768/autospace/brand-new-ultra-modern-techno-parking-garage-with-slots-wide-angle-haze-ultra-detailed-film-phot_ywuzvl.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BICYCLE',
        }),
        ...generateSlots({
          type: 'BIKE',
        }),
        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '909 Manhattan Ave, Brooklyn, NY 11222',
        lat: 40.7291,
        lng: -73.9542,
      },
    },
  },
  {
    displayName: 'Queens Garage 5',
    description: 'Convenient parking in Forest Hills',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158767/autospace/brand-new-ultra-modern-techno-parking-garage-with-slots-showing-newyork-skyline-low-poly-isometri_lai3r3.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BICYCLE',
        }),

        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '1001 Austin St, Forest Hills, NY 11375',
        lat: 40.7207,
        lng: -73.8448,
      },
    },
  },
  {
    displayName: 'Manhattan Garage 6',
    description: 'Parking in Soho',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158767/autospace/brand-new-modern-techno-parking-garage-with-slots-showing-newyork-skyline-low-poly-isometric-art_rfgxgp.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'HEAVY',
        }),
      ],
    },
    Address: {
      create: {
        address: '1101 Broadway, New York, NY 10012',
        lat: 40.7223,
        lng: -73.9987,
      },
    },
  },
  {
    displayName: 'Brooklyn Garage 6',
    description: 'Parking in DUMBO',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158767/autospace/busy-parking-garage-with-slots-in-newyork-in-the-hudson-river-low-poly-isometric-art-3d-art-high_os8c09.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'CAR',
        }),
        ...generateSlots({
          type: 'HEAVY',
        }),
      ],
    },
    Address: {
      create: {
        address: '1202 Water St, Brooklyn, NY 11201',
        lat: 40.7033,
        lng: -73.9903,
      },
    },
  },
  {
    displayName: 'Queens Garage 6',
    description: 'Parking in Jamaica',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158767/autospace/brand-new-modern-techno-parking-garage-with-slots-showing-newyork-skyline-with-no-cars-low-poly-i_ikyidk.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BICYCLE',
        }),
        ...generateSlots({
          type: 'BIKE',
        }),
        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '1303 Jamaica Ave, Jamaica, NY 11432',
        lat: 40.7028,
        lng: -73.7925,
      },
    },
  },
  {
    displayName: 'Manhattan Garage 7',
    description: 'Parking near the UN Headquarters',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158767/autospace/busy-parking-garage-with-slots-in-newyork-outer-space-vanishing-point-super-highway-high-speed-_wnpn6u.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BIKE',
        }),
        ...generateSlots({
          type: 'CAR',
        }),
      ],
    },
    Address: {
      create: {
        address: '1401 1st Ave, New York, NY 10016',
        lat: 40.7489,
        lng: -73.968,
      },
    },
  },
  {
    displayName: 'Brooklyn Garage 7',
    description: 'Parking in Park Slope',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158766/autospace/busy-parking-garage-near-a-newyork-central-park-acrylic-painting-trending-on-pixiv-fanbox-palette_buv6ks.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BIKE',
        }),
      ],
    },
    Address: {
      create: {
        address: '1504 7th Ave, Brooklyn, NY 11215',
        lat: 40.6681,
        lng: -73.9822,
      },
    },
  },
  {
    displayName: 'Queens Garage 7',
    description: 'Parking in Long Island City',
    Company: { connect: { id: 1 } },
    images: {
      set: [
        'https://res.cloudinary.com/thankyou/image/upload/v1716158766/autospace/multistorey-parking-garage-with-slots-showing-newyork-skyline-low-poly-isometric-art-3d-art-hig_1_pbgzgi.jpg',
      ],
    },
    Slots: {
      create: [
        ...generateSlots({
          type: 'BICYCLE',
        }),

        ...generateSlots({
          type: 'CAR',
        }),
        ...generateSlots({
          type: 'HEAVY',
        }),
      ],
    },
    Address: {
      create: {
        address: '1605 Jackson Ave, Long Island City, NY 11101',
        lat: 40.7472,
        lng: -73.9438,
      },
    },
  },
]
</file>

<file path="apps/api/prisma/seed/index.ts">
import { PrismaClient } from '@prisma/client'
import { garages } from './data'

let prisma

async function main() {
  prisma = new PrismaClient()

  for (const garage of garages) {
    await prisma.garage.create({
      data: garage,
    })
  }
}

main()
  .catch((e) => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
</file>

<file path="apps/api/prisma/seed/util.ts">
import { Slot } from '@prisma/client'

const randomRange = (min: number, max: number) => {
  return Math.random() * (max - min) + min
}

const slotRanges = {
  CAR: {
    length: { min: 12, max: 18 },
    width: { min: 8, max: 10 },
    height: { min: 15, max: 20 },
    pricePerHour: { min: 15, max: 25 },
    count: { min: 2, max: 6 },
  },
  HEAVY: {
    length: { min: 22, max: 30 },
    width: { min: 10, max: 18 },
    height: { min: 20, max: 30 },
    pricePerHour: { min: 30, max: 50 },
    count: { min: 2, max: 6 },
  },
  BIKE: {
    length: { min: 6, max: 8 },
    width: { min: 2, max: 3 },
    height: { min: 15, max: 20 },
    pricePerHour: { min: 5, max: 10 },
    count: { min: 2, max: 6 },
  },
  BICYCLE: {
    length: { min: 4, max: 6 },
    width: { min: 1, max: 2 },
    height: { min: 15, max: 20 },
    pricePerHour: { min: 2, max: 5 },
    count: { min: 2, max: 6 },
  },
}

export const generateSlots = ({ type }: Pick<Slot, 'type'>) => {
  const slots = []
  const ranges = slotRanges[type]

  const count = randomRange(ranges.count.min, ranges.count.max)
  const length = randomRange(ranges.length.min, ranges.length.max)
  const width = randomRange(ranges.width.min, ranges.width.max)
  const height = randomRange(ranges.height.min, ranges.height.max)
  const pricePerHour = Math.floor(
    randomRange(ranges.pricePerHour.min, ranges.pricePerHour.max),
  )
  for (let i = 0; i < count; i++) {
    slots.push({
      displayName: `${type} ${i + 1}`,
      pricePerHour,
      length,
      width,
      height,
      type,
    })
  }
  return slots
}
</file>

<file path="apps/api/prisma/models.md">
yarn entity:complete Admin
yarn entity:complete Customer
yarn entity:complete Manager
yarn entity:complete Valet
yarn entity:complete Company
yarn entity:complete Garage
yarn entity:complete Address
yarn entity:complete Slot
yarn entity:complete Booking
yarn entity:complete ValetAssignment
yarn entity:complete BookingTimeline
yarn entity:complete Review
yarn entity:complete Verification
</file>

<file path="apps/api/prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    uid       String   @id
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    name  String?
    image String?

    Credentials  Credentials?
    AuthProvider AuthProvider?
    Admin        Admin?
    Manager      Manager?
    Valet        Valet?
    Customer     Customer?
}

model Admin {
    uid  String @id
    User User   @relation(fields: [uid], references: [uid])

    createdAt     DateTime       @default(now())
    updatedAt     DateTime       @updatedAt
    Verifications Verification[]
}

model Credentials {
    uid  String @id
    User User   @relation(fields: [uid], references: [uid])

    email        String @unique
    passwordHash String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model AuthProvider {
    uid String @id

    type AuthProviderType
    User User             @relation(fields: [uid], references: [uid])
}

enum AuthProviderType {
    GOOGLE
    CREDENTIALS
}

model Customer {
    uid  String @id
    User User   @relation(fields: [uid], references: [uid])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    displayName String?

    Bookings Booking[]
    Reviews  Review[]
}

model Manager {
    uid  String @id
    User User   @relation(fields: [uid], references: [uid])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    displayName String?

    companyId       Int?              @unique
    Company         Company?          @relation(fields: [companyId], references: [id])
    BookingTimeline BookingTimeline[]
}

model Valet {
    uid  String @id
    User User   @relation(fields: [uid], references: [uid])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    displayName String
    image       String?
    licenceID   String  @default("")

    companyId         Int?
    Company           Company?          @relation(fields: [companyId], references: [id])
    BookingTimeline   BookingTimeline[]
    PickupAssignments ValetAssignment[] @relation("PickupValet")
    ReturnAssignments ValetAssignment[] @relation("ReturnValet")

    @@unique([companyId, uid])
}

model Company {
    id        Int      @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    displayName String?
    description String?

    Garages  Garage[]
    Managers Manager[]
    Valets   Valet[]
}

model Garage {
    id        Int      @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    displayName String?
    description String?
    images      String[]

    companyId    Int
    Company      Company       @relation(fields: [companyId], references: [id])
    Address      Address?
    Verification Verification?
    Reviews      Review[]
    Slots        Slot[]
}

model Address {
    id        Int      @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    address String
    lat     Float
    lng     Float

    garageId Int    @unique
    Garage   Garage @relation(fields: [garageId], references: [id])
}

model Slot {
    id        Int      @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    displayName  String?
    pricePerHour Float

    length Int?
    width  Int?
    height Int?

    type SlotType @default(CAR)

    garageId Int
    Garage   Garage    @relation(fields: [garageId], references: [id])
    Bookings Booking[]
}

model Booking {
    id        Int      @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    pricePerHour  Float?
    totalPrice    Float?
    startTime     DateTime
    endTime       DateTime
    vehicleNumber String
    phoneNumber   String?
    passcode      String?
    status        BookingStatus @default(BOOKED)

    slotId Int
    Slot   Slot @relation(fields: [slotId], references: [id])

    customerId String
    Customer   Customer @relation(fields: [customerId], references: [uid])

    ValetAssignment ValetAssignment?
    BookingTimeline BookingTimeline[]

    @@index([startTime, endTime])
}

model ValetAssignment {
    bookingId Int      @id
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    pickupLat Float?
    pickupLng Float?
    returnLat Float?
    returnLng Float?

    pickupValetId String?
    returnValetId String?
    PickupValet   Valet?  @relation("PickupValet", fields: [pickupValetId], references: [uid])
    ReturnValet   Valet?  @relation("ReturnValet", fields: [returnValetId], references: [uid])
    Booking       Booking @relation(fields: [bookingId], references: [id])
}

model BookingTimeline {
    id Int @id @default(autoincrement())

    timestamp DateTime      @default(now())
    status    BookingStatus

    bookingId Int
    Booking   Booking @relation(fields: [bookingId], references: [id])

    valetId String?
    Valet   Valet?  @relation(fields: [valetId], references: [uid])

    managerId String?
    Manager   Manager? @relation(fields: [managerId], references: [uid])

    @@index([bookingId])
}

model Review {
    id        Int      @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    rating  Int     @default(0)
    comment String?

    customerId String
    Customer   Customer @relation(fields: [customerId], references: [uid])

    garageId Int
    Garage   Garage @relation(fields: [garageId], references: [id])
}

model Verification {
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    verified Boolean @default(false)

    adminId  String
    garageId Int    @id
    Admin    Admin  @relation(fields: [adminId], references: [uid])
    Garage   Garage @relation(fields: [garageId], references: [id])
}

enum SlotType {
    CAR
    HEAVY
    BIKE
    BICYCLE
}

enum BookingStatus {
    BOOKED
    VALET_ASSIGNED_FOR_CHECK_IN
    VALET_PICKED_UP
    CHECKED_IN
    VALET_ASSIGNED_FOR_CHECK_OUT
    CHECKED_OUT
    VALET_RETURNED
}
</file>

<file path="apps/api/src/common/auth/auth.decorator.ts">
import {
  SetMetadata,
  UseGuards,
  applyDecorators,
  createParamDecorator,
  ExecutionContext,
} from '@nestjs/common'
import { Role } from 'src/common/types'

import { AuthGuard } from './auth.guard'
import { GqlExecutionContext } from '@nestjs/graphql'

export const AllowAuthenticated = (...roles: Role[]) =>
  applyDecorators(SetMetadata('roles', roles), UseGuards(AuthGuard))

export const GetUser = createParamDecorator((data, ctx: ExecutionContext) => {
  const context = GqlExecutionContext.create(ctx)
  return context.getContext().req.user
})
</file>

<file path="apps/api/src/common/auth/auth.guard.ts">
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common'
import { GqlExecutionContext } from '@nestjs/graphql'
import { JwtService } from '@nestjs/jwt'
import { Reflector } from '@nestjs/core'
import { Role } from 'src/common/types'
import { PrismaService } from 'src/common/prisma/prisma.service'

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    private readonly jwtService: JwtService,
    private readonly reflector: Reflector,
    private readonly prisma: PrismaService,
  ) {}
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const ctx = GqlExecutionContext.create(context)
    const req = ctx.getContext().req

    await this.authenticateUser(req)

    return this.authorizeUser(req, context)
  }

  private async authenticateUser(req: any): Promise<void> {
    const bearerHeader = req.headers.authorization
    // Bearer eylskfdjlsdf309
    const token = bearerHeader?.split(' ')[1]

    if (!token) {
      throw new UnauthorizedException('No token provided.')
    }

    try {
      const payload = await this.jwtService.verify(token)
      const uid = payload.uid
      if (!uid) {
        throw new UnauthorizedException(
          'Invalid token. No uid present in the token.',
        )
      }

      const user = await this.prisma.user.findUnique({ where: { uid } })
      if (!user) {
        throw new UnauthorizedException(
          'Invalid token. No user present with the uid.',
        )
      }

      console.log('jwt payload: ', payload)
      req.user = payload
    } catch (err) {
      console.error('Token validation error:', err)
      throw err
    }

    if (!req.user) {
      throw new UnauthorizedException('Invalid token.')
    }
  }

  private async authorizeUser(
    req: any,
    context: ExecutionContext,
  ): Promise<boolean> {
    const requiredRoles = this.getMetadata<Role[]>('roles', context)
    const userRoles = await this.getUserRoles(req.user.uid)
    req.user.roles = userRoles

    if (!requiredRoles || requiredRoles.length === 0) {
      return true
    }

    return requiredRoles.some((role) => userRoles.includes(role))
  }

  private getMetadata<T>(key: string, context: ExecutionContext): T {
    return this.reflector.getAllAndOverride<T>(key, [
      context.getHandler(),
      context.getClass(),
    ])
  }

  private async getUserRoles(uid: string): Promise<Role[]> {
    const roles: Role[] = []

    const [admin, manager, valet] = await Promise.all([
      this.prisma.admin.findUnique({ where: { uid } }),
      this.prisma.manager.findUnique({ where: { uid } }),
      this.prisma.valet.findUnique({ where: { uid } }),
      // Add promises for other role models here
    ])

    admin && roles.push('admin')
    manager && roles.push('manager')
    valet && roles.push('valet')

    return roles
  }
}
</file>

<file path="apps/api/src/common/auth/util.ts">
import { GetUserType, Role } from 'src/common/types'
import { ForbiddenException } from '@nestjs/common'

export const checkRowLevelPermission = (
  user: GetUserType,
  requestedUid?: string | string[],
  roles: Role[] = ['admin'],
) => {
  if (!requestedUid) return false

  if (user.roles?.some((role) => roles.includes(role))) {
    return true
  }

  const uids =
    typeof requestedUid === 'string'
      ? [requestedUid]
      : requestedUid.filter(Boolean)

  if (!uids.includes(user.uid)) {
    throw new ForbiddenException()
  }
}
</file>

<file path="apps/api/src/common/dtos/common.dto.ts">
import { IsIn, IsNumberString, IsOptional, IsString } from 'class-validator'

export class BaseQueryDto {
  @IsNumberString()
  @IsOptional()
  skip?: number

  @IsNumberString()
  @IsOptional()
  take?: number

  @IsString()
  @IsOptional()
  search?: string

  @IsOptional()
  @IsIn(['asc', 'desc'])
  order?: 'asc' | 'desc'
}
</file>

<file path="apps/api/src/common/dtos/common.input.ts">
import {
  ArgsType,
  Field,
  Float,
  InputType,
  ObjectType,
  registerEnumType,
} from '@nestjs/graphql'
import { Prisma } from '@prisma/client'

export type RestrictProperties<T, U> = {
  [K in keyof T]: K extends keyof U ? T[K] : never
} & Required<U>

// implements Prisma.DateTimeFilter
@InputType()
export class DateTimeFilter {
  equals?: string;
  in?: string[]
  notIn?: string[]
  lt?: string
  lte?: string
  gt?: string
  gte?: string
}

registerEnumType(Prisma.QueryMode, {
  name: 'QueryMode',
})

// implements Required<Prisma.StringFilter>
@InputType()
export class StringFilter {
  equals?: string;
  in?: string[]
  notIn?: string[]
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string
  @Field(() => Prisma.QueryMode)
  mode?: Prisma.QueryMode
}
@InputType()
export class StringListFilter {
  equals?: string[]
  has?: string
  hasEvery?: string[]
  hasSome?: string[]
  isEmpty?: boolean
}

@InputType()
export class BoolFilter {
  equals?: boolean
  not?: boolean
}

// implements Required<Prisma.IntFilter>
@InputType()
export class IntFilter {
  equals?: number
  lt?: number
  lte?: number
  gt?: number
  gte?: number
}

@InputType()
export class FloatFilter {
  equals?: number
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number
}

registerEnumType(Prisma.SortOrder, {
  name: 'SortOrder',
})

@ObjectType()
export class AggregateCountOutput {
  count: number
}

@InputType()
export class LocationFilterInput {
  @Field(() => Float)
  ne_lat: number

  @Field(() => Float)
  ne_lng: number

  @Field(() => Float)
  sw_lat: number

  @Field(() => Float)
  sw_lng: number
}

@ArgsType()
export class PaginationInput {
  take?: number
  skip?: number
}
</file>

<file path="apps/api/src/common/prisma/prisma.module.ts">
import { Global, Module } from '@nestjs/common'
import { PrismaService } from './prisma.service'

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
</file>

<file path="apps/api/src/common/prisma/prisma.service.ts">
import { Injectable, OnModuleInit } from '@nestjs/common'
import { PrismaClient } from '@prisma/client'

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect()
  }
}
</file>

<file path="apps/api/src/common/types/index.ts">
export type Role = 'admin' | 'manager' | 'valet'

export type GetUserType = {
  uid: string
  roles: Role[]
}
</file>

<file path="apps/api/src/common/util.ts">
export const toTitleCase = (str: string) => {
  return str
    .replace(/([A-Z])/g, ' $1') // insert a space before all capital letters
    .replace(/^./, function (str) {
      return str.toUpperCase()
    }) // uppercase the first character
}

export const generateSixDigitNumber = () => {
  return Math.floor(Math.random() * 900000) + 100000
}
</file>

<file path="apps/api/src/models/addresses/graphql/dtos/create-address.input.ts">
import { InputType, OmitType, PickType } from '@nestjs/graphql'
import { Address } from '../entity/address.entity'

@InputType()
export class CreateAddressInput extends OmitType(
  Address,
  ['createdAt', 'updatedAt', 'id'],
  InputType,
) {}

@InputType()
export class CreateAddressInputWithoutGarageId extends PickType(
  CreateAddressInput,
  ['address', 'lat', 'lng'],
  InputType,
) {}
</file>

<file path="apps/api/src/models/addresses/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { AddressOrderByWithRelationInput } from './order-by.args'
import { AddressWhereInput, AddressWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.AddressScalarFieldEnum, {
  name: 'AddressScalarFieldEnum',
})

@ArgsType()
class FindManyAddressArgsStrict
  implements
    RestrictProperties<
      FindManyAddressArgsStrict,
      Omit<Prisma.AddressFindManyArgs, 'include' | 'select'>
    >
{
  where: AddressWhereInput
  orderBy: AddressOrderByWithRelationInput[]
  cursor: AddressWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.AddressScalarFieldEnum])
  distinct: Prisma.AddressScalarFieldEnum[]
}

@ArgsType()
export class FindManyAddressArgs extends PartialType(
  FindManyAddressArgsStrict,
) {}

@ArgsType()
export class FindUniqueAddressArgs {
  where: AddressWhereUniqueInput
}
</file>

<file path="apps/api/src/models/addresses/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { GarageOrderByWithRelationInput } from 'src/models/garages/graphql/dtos/order-by.args'

@InputType()
export class AddressOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      AddressOrderByWithRelationInputStrict,
      Prisma.AddressOrderByWithRelationInput
    >
{
  @Field(() => Prisma.SortOrder)
  id: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  address: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  lat: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  lng: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  garageId: Prisma.SortOrder
  Garage: GarageOrderByWithRelationInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class AddressOrderByWithRelationInput extends PartialType(
  AddressOrderByWithRelationInputStrict,
) {}

@InputType()
export class AddressOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/addresses/graphql/dtos/update-address.input.ts">
import { CreateAddressInput } from './create-address.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Address } from '@prisma/client'

@InputType()
export class UpdateAddressInput extends PartialType(CreateAddressInput) {
  id: Address['id']
}
</file>

<file path="apps/api/src/models/addresses/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  FloatFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { GarageRelationFilter } from 'src/models/garages/graphql/dtos/where.args'

@InputType()
export class AddressWhereUniqueInput {
  id: number
}

@InputType()
export class AddressWhereInputStrict
  implements
    RestrictProperties<AddressWhereInputStrict, Prisma.AddressWhereInput>
{
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  address: StringFilter
  lat: FloatFilter
  lng: FloatFilter
  garageId: IntFilter
  Garage: GarageRelationFilter

  AND: AddressWhereInput[]
  OR: AddressWhereInput[]
  NOT: AddressWhereInput[]
}

@InputType()
export class AddressWhereInput extends PartialType(AddressWhereInputStrict) {}

@InputType()
export class AddressListRelationFilter {
  every?: AddressWhereInput
  some?: AddressWhereInput
  none?: AddressWhereInput
}

@InputType()
export class AddressRelationFilter {
  is?: AddressWhereInput
  isNot?: AddressWhereInput
}
</file>

<file path="apps/api/src/models/addresses/graphql/entity/address.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { Address as AddressType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class Address implements RestrictProperties<Address, AddressType> {
  id: number
  createdAt: Date
  updatedAt: Date
  address: string
  lat: number
  lng: number
  @Field({ nullable: true })
  garageId: number
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/addresses/graphql/addresses.resolver.ts">
import {
  Resolver,
  Query,
  Mutation,
  Args,
  ResolveField,
  Parent,
} from '@nestjs/graphql'
import { AddressesService } from './addresses.service'
import { Address } from './entity/address.entity'
import { FindManyAddressArgs, FindUniqueAddressArgs } from './dtos/find.args'
import { CreateAddressInput } from './dtos/create-address.input'
import { UpdateAddressInput } from './dtos/update-address.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { Garage } from 'src/models/garages/graphql/entity/garage.entity'

@Resolver(() => Address)
export class AddressesResolver {
  constructor(
    private readonly addressesService: AddressesService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated()
  @Mutation(() => Address)
  async createAddress(
    @Args('createAddressInput') args: CreateAddressInput,
    @GetUser() user: GetUserType,
  ) {
    const garage = await this.prisma.garage.findUnique({
      where: { id: args.garageId },
      include: { Company: { include: { Managers: true } } },
    })
    checkRowLevelPermission(
      user,
      garage.Company.Managers.map((man) => man.uid),
    )
    return this.addressesService.create(args)
  }

  @Query(() => [Address], { name: 'addresses' })
  findAll(@Args() args: FindManyAddressArgs) {
    return this.addressesService.findAll(args)
  }

  @Query(() => Address, { name: 'address' })
  findOne(@Args() args: FindUniqueAddressArgs) {
    return this.addressesService.findOne(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Address)
  async updateAddress(
    @Args('updateAddressInput') args: UpdateAddressInput,
    @GetUser() user: GetUserType,
  ) {
    const address = await this.prisma.address.findUnique({
      where: { id: args.id },
      include: {
        Garage: {
          include: { Company: { include: { Managers: true } } },
        },
      },
    })
    checkRowLevelPermission(
      user,
      address.Garage.Company.Managers.map((man) => man.uid),
    )
    return this.addressesService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Address)
  async removeAddress(
    @Args() args: FindUniqueAddressArgs,
    @GetUser() user: GetUserType,
  ) {
    const address = await this.prisma.address.findUnique({
      where: { id: args.where.id },
      include: {
        Garage: {
          include: { Company: { include: { Managers: true } } },
        },
      },
    })
    checkRowLevelPermission(
      user,
      address.Garage.Company.Managers.map((man) => man.uid),
    )
    return this.addressesService.remove(args)
  }

  @ResolveField(() => Garage, { nullable: true })
  garage(@Parent() address: Address) {
    return this.prisma.company.findFirst({ where: { id: address.garageId } })
  }
}
</file>

<file path="apps/api/src/models/addresses/graphql/addresses.service.ts">
import { Injectable } from '@nestjs/common'
import { FindManyAddressArgs, FindUniqueAddressArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateAddressInput } from './dtos/create-address.input'
import { UpdateAddressInput } from './dtos/update-address.input'

@Injectable()
export class AddressesService {
  constructor(private readonly prisma: PrismaService) {}
  create(createAddressInput: CreateAddressInput) {
    return this.prisma.address.create({
      data: createAddressInput,
    })
  }

  findAll(args: FindManyAddressArgs) {
    return this.prisma.address.findMany(args)
  }

  findOne(args: FindUniqueAddressArgs) {
    return this.prisma.address.findUnique(args)
  }

  update(updateAddressInput: UpdateAddressInput) {
    const { id, ...data } = updateAddressInput
    return this.prisma.address.update({
      where: { id },
      data: data,
    })
  }

  remove(args: FindUniqueAddressArgs) {
    return this.prisma.address.delete(args)
  }
}
</file>

<file path="apps/api/src/models/addresses/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { AddressEntity } from '../entity/address.entity'

export class CreateAddress extends OmitType(AddressEntity, [
  'createdAt',
  'updatedAt',
  'id',
]) {}
</file>

<file path="apps/api/src/models/addresses/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class AddressQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.AddressScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.AddressScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/addresses/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateAddress } from './create.dto'
import { Address } from '@prisma/client'

export class UpdateAddress extends PartialType(CreateAddress) {
  id: Address['id']
}
</file>

<file path="apps/api/src/models/addresses/rest/entity/address.entity.ts">
import { Address } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class AddressEntity
  implements RestrictProperties<AddressEntity, Address>
{
  id: number
  createdAt: Date
  updatedAt: Date
  address: string
  lat: number
  lng: number
  @IsOptional()
  garageId: number
}
</file>

<file path="apps/api/src/models/addresses/rest/addresses.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateAddress } from './dtos/create.dto'
import { AddressQueryDto } from './dtos/query.dto'
import { UpdateAddress } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { AddressEntity } from './entity/address.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('addresses')
@Controller('addresses')
export class AddressesController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: AddressEntity })
  @Post()
  async create(
    @Body() createAddressDto: CreateAddress,
    @GetUser() user: GetUserType,
  ) {
    const garage = await this.prisma.garage.findUnique({
      where: { id: createAddressDto.garageId },
      include: { Company: { include: { Managers: true } } },
    })
    checkRowLevelPermission(
      user,
      garage.Company.Managers.map((manager) => manager.uid),
    )
    return this.prisma.address.create({ data: createAddressDto })
  }

  @ApiOkResponse({ type: [AddressEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: AddressQueryDto) {
    return this.prisma.address.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: AddressEntity })
  @Get(':id')
  findOne(@Param('id') id: number) {
    return this.prisma.address.findUnique({ where: { id } })
  }

  @ApiOkResponse({ type: AddressEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':id')
  async update(
    @Param('id') id: number,
    @Body() updateAddressDto: UpdateAddress,
    @GetUser() user: GetUserType,
  ) {
    const address = await this.prisma.address.findUnique({
      where: { id },
      include: {
        Garage: { include: { Company: { include: { Managers: true } } } },
      },
    })
    checkRowLevelPermission(
      user,
      address.Garage.Company.Managers.map((manager) => manager.uid),
    )
    return this.prisma.address.update({
      where: { id },
      data: updateAddressDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':id')
  async remove(@Param('id') id: number, @GetUser() user: GetUserType) {
    const address = await this.prisma.address.findUnique({
      where: { id },
      include: {
        Garage: { include: { Company: { include: { Managers: true } } } },
      },
    })
    checkRowLevelPermission(
      user,
      address.Garage.Company.Managers.map((manager) => manager.uid),
    )
    return this.prisma.address.delete({ where: { id } })
  }
}
</file>

<file path="apps/api/src/models/addresses/addresses.module.ts">
import { Module } from '@nestjs/common'
import { AddressesService } from './graphql/addresses.service'
import { AddressesResolver } from './graphql/addresses.resolver'
import { AddressesController } from './rest/addresses.controller'

@Module({
  providers: [AddressesResolver, AddressesService],
  exports: [AddressesService],
  controllers: [AddressesController],
})
export class AddressesModule {}
</file>

<file path="apps/api/src/models/admins/graphql/dtos/create-admin.input.ts">
import { InputType, PickType } from '@nestjs/graphql'
import { Admin } from '../entity/admin.entity'

@InputType()
export class CreateAdminInput extends PickType(Admin, ['uid'], InputType) {}
</file>

<file path="apps/api/src/models/admins/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { AdminOrderByWithRelationInput } from './order-by.args'
import { AdminWhereInput, AdminWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.AdminScalarFieldEnum, {
  name: 'AdminScalarFieldEnum',
})

@ArgsType()
class FindManyAdminArgsStrict
  implements
    RestrictProperties<
      FindManyAdminArgsStrict,
      Omit<Prisma.AdminFindManyArgs, 'include' | 'select'>
    >
{
  where: AdminWhereInput
  orderBy: AdminOrderByWithRelationInput[]
  cursor: AdminWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.AdminScalarFieldEnum])
  distinct: Prisma.AdminScalarFieldEnum[]
}

@ArgsType()
export class FindManyAdminArgs extends PartialType(FindManyAdminArgsStrict) {}

@ArgsType()
export class FindUniqueAdminArgs {
  where: AdminWhereUniqueInput
}
</file>

<file path="apps/api/src/models/admins/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { UserOrderByWithRelationInput } from 'src/models/users/graphql/dtos/order-by.args'
import { VerificationOrderByRelationAggregateInput } from 'src/models/verifications/graphql/dtos/order-by.args'

@InputType()
export class AdminOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      AdminOrderByWithRelationInputStrict,
      Prisma.AdminOrderByWithRelationInput
    >
{
  Verifications: VerificationOrderByRelationAggregateInput
  @Field(() => Prisma.SortOrder)
  uid: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  User: UserOrderByWithRelationInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class AdminOrderByWithRelationInput extends PartialType(
  AdminOrderByWithRelationInputStrict,
) {}

@InputType()
export class AdminOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/admins/graphql/dtos/update-admin.input.ts">
import { CreateAdminInput } from './create-admin.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Admin } from '@prisma/client'

@InputType()
export class UpdateAdminInput extends PartialType(CreateAdminInput) {
  uid: Admin['uid']
}
</file>

<file path="apps/api/src/models/admins/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { UserRelationFilter } from 'src/models/users/graphql/dtos/where.args'
import { VerificationListRelationFilter } from 'src/models/verifications/graphql/dtos/where.args'

@InputType()
export class AdminWhereUniqueInput {
  uid: string
}

@InputType()
export class AdminWhereInputStrict
  implements RestrictProperties<AdminWhereInputStrict, Prisma.AdminWhereInput>
{
  Verifications: VerificationListRelationFilter
  uid: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  User: UserRelationFilter
  // Todo: Add the below field decorator only to the $Enums types.
  // @Field(() => $Enums.x)

  AND: AdminWhereInput[]
  OR: AdminWhereInput[]
  NOT: AdminWhereInput[]
}

@InputType()
export class AdminWhereInput extends PartialType(AdminWhereInputStrict) {}

@InputType()
export class AdminListRelationFilter {
  every?: AdminWhereInput
  some?: AdminWhereInput
  none?: AdminWhereInput
}

@InputType()
export class AdminRelationFilter {
  is?: AdminWhereInput
  isNot?: AdminWhereInput
}
</file>

<file path="apps/api/src/models/admins/graphql/entity/admin.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { Admin as AdminType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class Admin implements RestrictProperties<Admin, AdminType> {
  @Field()
  uid: string
  createdAt: Date
  updatedAt: Date
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/admins/graphql/admins.resolver.ts">
import {
  Resolver,
  Query,
  Mutation,
  Args,
  ResolveField,
  Parent,
} from '@nestjs/graphql'
import { AdminsService } from './admins.service'
import { Admin } from './entity/admin.entity'
import { FindManyAdminArgs, FindUniqueAdminArgs } from './dtos/find.args'
import { CreateAdminInput } from './dtos/create-admin.input'
import { UpdateAdminInput } from './dtos/update-admin.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { User } from 'src/models/users/graphql/entity/user.entity'
import { Verification } from 'src/models/verifications/graphql/entity/verification.entity'
import { AdminWhereInput } from './dtos/where.args'

@AllowAuthenticated('admin')
@Resolver(() => Admin)
export class AdminsResolver {
  constructor(
    private readonly adminsService: AdminsService,
    private readonly prisma: PrismaService,
  ) {}

  @Mutation(() => Admin)
  createAdmin(
    @Args('createAdminInput') args: CreateAdminInput,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, args.uid)
    return this.adminsService.create(args)
  }

  @Query(() => [Admin], { name: 'admins' })
  findAll(@Args() args: FindManyAdminArgs) {
    return this.adminsService.findAll(args)
  }

  @Query(() => Admin, { name: 'admin' })
  findOne(@Args() args: FindUniqueAdminArgs) {
    return this.adminsService.findOne(args)
  }

  @AllowAuthenticated()
  @Query(() => Admin, { name: 'adminMe' })
  adminMe(@GetUser() user: GetUserType) {
    return this.adminsService.findOne({ where: { uid: user.uid } })
  }

  @AllowAuthenticated()
  @Mutation(() => Admin)
  async updateAdmin(
    @Args('updateAdminInput') args: UpdateAdminInput,
    @GetUser() user: GetUserType,
  ) {
    const admin = await this.prisma.admin.findUnique({
      where: { uid: args.uid },
    })
    checkRowLevelPermission(user, admin.uid)
    return this.adminsService.update(args)
  }

  @Mutation(() => Admin)
  async removeAdmin(
    @Args() args: FindUniqueAdminArgs,
    @GetUser() user: GetUserType,
  ) {
    const admin = await this.prisma.admin.findUnique(args)
    console.log('remove admin', user, admin.uid)
    checkRowLevelPermission(user, admin.uid)
    return this.adminsService.remove(args)
  }

  @ResolveField(() => User, { nullable: true })
  user(@Parent() admin: Admin) {
    return this.prisma.user.findUnique({ where: { uid: admin.uid } })
  }

  @ResolveField(() => [Verification])
  verifications(@Parent() parent: Admin) {
    return this.prisma.verification.findMany({
      where: { adminId: parent.uid },
    })
  }

  @ResolveField(() => Number)
  async verificationsCount(@Parent() parent: Admin) {
    return this.prisma.verification.count({
      where: { adminId: parent.uid },
    })
  }

  @Query(() => Number, {
    name: 'adminsCount',
  })
  async adminsCount(
    @Args('where', { nullable: true })
    where: AdminWhereInput,
  ) {
    return this.prisma.admin.count({
      where,
    })
  }
}
</file>

<file path="apps/api/src/models/admins/graphql/admins.service.ts">
import { Injectable } from '@nestjs/common'
import { FindManyAdminArgs, FindUniqueAdminArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateAdminInput } from './dtos/create-admin.input'
import { UpdateAdminInput } from './dtos/update-admin.input'

@Injectable()
export class AdminsService {
  constructor(private readonly prisma: PrismaService) {}
  create(createAdminInput: CreateAdminInput) {
    return this.prisma.admin.create({
      data: createAdminInput,
    })
  }

  findAll(args: FindManyAdminArgs) {
    return this.prisma.admin.findMany(args)
  }

  findOne(args: FindUniqueAdminArgs) {
    return this.prisma.admin.findUnique(args)
  }

  update(updateAdminInput: UpdateAdminInput) {
    const { uid, ...data } = updateAdminInput
    return this.prisma.admin.update({
      where: { uid },
      data: data,
    })
  }

  remove(args: FindUniqueAdminArgs) {
    return this.prisma.admin.delete(args)
  }
}
</file>

<file path="apps/api/src/models/admins/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { AdminEntity } from '../entity/admin.entity'

export class CreateAdmin extends OmitType(AdminEntity, [
  'createdAt',
  'updatedAt',
]) {}
</file>

<file path="apps/api/src/models/admins/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class AdminQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.AdminScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.AdminScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/admins/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateAdmin } from './create.dto'
import { Admin } from '@prisma/client'

export class UpdateAdmin extends PartialType(CreateAdmin) {
  uid: Admin['uid']
}
</file>

<file path="apps/api/src/models/admins/rest/entity/admin.entity.ts">
import { Admin } from '@prisma/client'
import { IsDate, IsString, IsInt } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class AdminEntity implements RestrictProperties<AdminEntity, Admin> {
  uid: string
  createdAt: Date
  updatedAt: Date
}
</file>

<file path="apps/api/src/models/admins/rest/admins.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateAdmin } from './dtos/create.dto'
import { AdminQueryDto } from './dtos/query.dto'
import { UpdateAdmin } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { AdminEntity } from './entity/admin.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('admins')
@Controller('admins')
export class AdminsController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: AdminEntity })
  @Post()
  create(@Body() createAdminDto: CreateAdmin, @GetUser() user: GetUserType) {
    checkRowLevelPermission(user, createAdminDto.uid)
    return this.prisma.admin.create({ data: createAdminDto })
  }

  @ApiOkResponse({ type: [AdminEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: AdminQueryDto) {
    return this.prisma.admin.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: AdminEntity })
  @Get(':uid')
  findOne(@Param('uid') uid: string) {
    return this.prisma.admin.findUnique({ where: { uid } })
  }

  @ApiOkResponse({ type: AdminEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':uid')
  async update(
    @Param('uid') uid: string,
    @Body() updateAdminDto: UpdateAdmin,
    @GetUser() user: GetUserType,
  ) {
    const admin = await this.prisma.admin.findUnique({ where: { uid } })
    checkRowLevelPermission(user, admin.uid)
    return this.prisma.admin.update({
      where: { uid },
      data: updateAdminDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':uid')
  async remove(@Param('uid') uid: string, @GetUser() user: GetUserType) {
    const admin = await this.prisma.admin.findUnique({ where: { uid } })
    checkRowLevelPermission(user, admin.uid)
    return this.prisma.admin.delete({ where: { uid } })
  }
}
</file>

<file path="apps/api/src/models/admins/admins.module.ts">
import { Module } from '@nestjs/common'
import { AdminsService } from './graphql/admins.service'
import { AdminsResolver } from './graphql/admins.resolver'
import { AdminsController } from './rest/admins.controller'

@Module({
  providers: [AdminsResolver, AdminsService],
  exports: [AdminsService],
  controllers: [AdminsController],
})
export class AdminsModule {}
</file>

<file path="apps/api/src/models/booking-timelines/graphql/dtos/create-booking-timeline.input.ts">
import { InputType, OmitType, PickType } from '@nestjs/graphql'
import { BookingTimeline } from '../entity/booking-timeline.entity'

@InputType()
export class CreateBookingTimelineInput extends PickType(
  BookingTimeline,
  ['bookingId', 'status'],
  InputType,
) {}
</file>

<file path="apps/api/src/models/booking-timelines/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { BookingTimelineOrderByWithRelationInput } from './order-by.args'
import {
  BookingTimelineWhereInput,
  BookingTimelineWhereUniqueInput,
} from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.BookingTimelineScalarFieldEnum, {
  name: 'BookingTimelineScalarFieldEnum',
})

@ArgsType()
class FindManyBookingTimelineArgsStrict
  implements
    RestrictProperties<
      FindManyBookingTimelineArgsStrict,
      Omit<Prisma.BookingTimelineFindManyArgs, 'include' | 'select'>
    >
{
  where: BookingTimelineWhereInput
  orderBy: BookingTimelineOrderByWithRelationInput[]
  cursor: BookingTimelineWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.BookingTimelineScalarFieldEnum])
  distinct: Prisma.BookingTimelineScalarFieldEnum[]
}

@ArgsType()
export class FindManyBookingTimelineArgs extends PartialType(
  FindManyBookingTimelineArgsStrict,
) {}

@ArgsType()
export class FindUniqueBookingTimelineArgs {
  where: BookingTimelineWhereUniqueInput
}
</file>

<file path="apps/api/src/models/booking-timelines/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { BookingOrderByWithRelationInput } from 'src/models/bookings/graphql/dtos/order-by.args'
import { ManagerOrderByWithRelationInput } from 'src/models/managers/graphql/dtos/order-by.args'
import { ValetOrderByWithRelationInput } from 'src/models/valets/graphql/dtos/order-by.args'

@InputType()
export class BookingTimelineOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      BookingTimelineOrderByWithRelationInputStrict,
      Prisma.BookingTimelineOrderByWithRelationInput
    >
{
  @Field(() => Prisma.SortOrder)
  id: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  timestamp: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  status: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  bookingId: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  valetId: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  managerId: Prisma.SortOrder
  Booking: BookingOrderByWithRelationInput
  Valet: ValetOrderByWithRelationInput
  Manager: ManagerOrderByWithRelationInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class BookingTimelineOrderByWithRelationInput extends PartialType(
  BookingTimelineOrderByWithRelationInputStrict,
) {}

@InputType()
export class BookingTimelineOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/booking-timelines/graphql/dtos/update-booking-timeline.input.ts">
import { CreateBookingTimelineInput } from './create-booking-timeline.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { BookingTimeline } from '@prisma/client'

@InputType()
export class UpdateBookingTimelineInput extends PartialType(
  CreateBookingTimelineInput,
) {
  id: BookingTimeline['id']
}
</file>

<file path="apps/api/src/models/booking-timelines/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { $Enums, Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { BookingRelationFilter } from 'src/models/bookings/graphql/dtos/where.args'
import { ManagerRelationFilter } from 'src/models/managers/graphql/dtos/where.args'
import { ValetRelationFilter } from 'src/models/valets/graphql/dtos/where.args'

@InputType()
export class BookingTimelineWhereUniqueInput {
  id: number
}

@InputType()
export class BookingTimelineWhereInputStrict
  implements
    RestrictProperties<
      BookingTimelineWhereInputStrict,
      Prisma.BookingTimelineWhereInput
    >
{
  id: IntFilter
  timestamp: DateTimeFilter
  @Field(() => $Enums.BookingStatus)
  status: $Enums.BookingStatus
  bookingId: IntFilter
  valetId: StringFilter
  managerId: StringFilter
  Booking: BookingRelationFilter
  Valet: ValetRelationFilter
  Manager: ManagerRelationFilter

  AND: BookingTimelineWhereInput[]
  OR: BookingTimelineWhereInput[]
  NOT: BookingTimelineWhereInput[]
}

@InputType()
export class BookingTimelineWhereInput extends PartialType(
  BookingTimelineWhereInputStrict,
) {}

@InputType()
export class BookingTimelineListRelationFilter {
  every?: BookingTimelineWhereInput
  some?: BookingTimelineWhereInput
  none?: BookingTimelineWhereInput
}

@InputType()
export class BookingTimelineRelationFilter {
  is?: BookingTimelineWhereInput
  isNot?: BookingTimelineWhereInput
}
</file>

<file path="apps/api/src/models/booking-timelines/graphql/entity/booking-timeline.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { $Enums, BookingTimeline as BookingTimelineType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class BookingTimeline
  implements RestrictProperties<BookingTimeline, BookingTimelineType>
{
  id: number
  timestamp: Date
  @Field(() => $Enums.BookingStatus)
  status: $Enums.BookingStatus
  bookingId: number
  @Field({ nullable: true })
  valetId: string
  @Field({ nullable: true })
  managerId: string
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/booking-timelines/graphql/booking-timelines.resolver.ts">
import { Resolver, Query, Mutation, Args } from '@nestjs/graphql'
import { BookingTimelinesService } from './booking-timelines.service'
import { BookingTimeline } from './entity/booking-timeline.entity'
import {
  FindManyBookingTimelineArgs,
  FindUniqueBookingTimelineArgs,
} from './dtos/find.args'
import { CreateBookingTimelineInput } from './dtos/create-booking-timeline.input'
import { UpdateBookingTimelineInput } from './dtos/update-booking-timeline.input'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@Resolver(() => BookingTimeline)
export class BookingTimelinesResolver {
  constructor(
    private readonly bookingTimelinesService: BookingTimelinesService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated('admin', 'manager')
  @Mutation(() => BookingTimeline)
  async createBookingTimeline(
    @Args('createBookingTimelineInput')
    { bookingId, status }: CreateBookingTimelineInput,
    @GetUser() user: GetUserType,
  ) {
    const booking = await this.prisma.booking.findUnique({
      where: { id: bookingId },
      select: {
        Slot: {
          select: {
            Garage: {
              select: {
                Company: {
                  select: { Managers: { select: { uid: true } } },
                },
              },
            },
          },
        },
      },
    })
    checkRowLevelPermission(
      user,
      booking.Slot.Garage.Company.Managers.map((manager) => manager.uid),
    )

    const [updatedBooking, bookingTimeline] = await this.prisma.$transaction([
      this.prisma.booking.update({
        data: { status: status },
        where: { id: bookingId },
      }),
      this.prisma.bookingTimeline.create({
        data: { bookingId, managerId: user.uid, status },
      }),
    ])
    return bookingTimeline
  }

  @Query(() => [BookingTimeline], { name: 'bookingTimelines' })
  findAll(@Args() args: FindManyBookingTimelineArgs) {
    return this.bookingTimelinesService.findAll(args)
  }

  @Query(() => BookingTimeline, { name: 'bookingTimeline' })
  findOne(@Args() args: FindUniqueBookingTimelineArgs) {
    return this.bookingTimelinesService.findOne(args)
  }

  @AllowAuthenticated('admin')
  @Mutation(() => BookingTimeline)
  async updateBookingTimeline(
    @Args('updateBookingTimelineInput') args: UpdateBookingTimelineInput,
  ) {
    return this.bookingTimelinesService.update(args)
  }

  @AllowAuthenticated('admin')
  @Mutation(() => BookingTimeline)
  async removeBookingTimeline(@Args() args: FindUniqueBookingTimelineArgs) {
    return this.bookingTimelinesService.remove(args)
  }
}
</file>

<file path="apps/api/src/models/booking-timelines/graphql/booking-timelines.service.ts">
import { Injectable } from '@nestjs/common'
import {
  FindManyBookingTimelineArgs,
  FindUniqueBookingTimelineArgs,
} from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateBookingTimelineInput } from './dtos/create-booking-timeline.input'
import { UpdateBookingTimelineInput } from './dtos/update-booking-timeline.input'

@Injectable()
export class BookingTimelinesService {
  constructor(private readonly prisma: PrismaService) {}
  create(createBookingTimelineInput: CreateBookingTimelineInput) {
    return this.prisma.bookingTimeline.create({
      data: createBookingTimelineInput,
    })
  }

  findAll(args: FindManyBookingTimelineArgs) {
    return this.prisma.bookingTimeline.findMany(args)
  }

  findOne(args: FindUniqueBookingTimelineArgs) {
    return this.prisma.bookingTimeline.findUnique(args)
  }

  update(updateBookingTimelineInput: UpdateBookingTimelineInput) {
    const { id, ...data } = updateBookingTimelineInput
    return this.prisma.bookingTimeline.update({
      where: { id },
      data: data,
    })
  }

  remove(args: FindUniqueBookingTimelineArgs) {
    return this.prisma.bookingTimeline.delete(args)
  }
}
</file>

<file path="apps/api/src/models/booking-timelines/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { BookingTimelineEntity } from '../entity/booking-timeline.entity'

export class CreateBookingTimeline extends OmitType(BookingTimelineEntity, [
  'id',
]) {}
</file>

<file path="apps/api/src/models/booking-timelines/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class BookingTimelineQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.BookingTimelineScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.BookingTimelineScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/booking-timelines/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateBookingTimeline } from './create.dto'
import { BookingTimeline } from '@prisma/client'

export class UpdateBookingTimeline extends PartialType(CreateBookingTimeline) {
  id: BookingTimeline['id']
}
</file>

<file path="apps/api/src/models/booking-timelines/rest/entity/booking-timeline.entity.ts">
import { $Enums, BookingTimeline } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class BookingTimelineEntity
  implements RestrictProperties<BookingTimelineEntity, BookingTimeline>
{
  id: number
  timestamp: Date
  status: $Enums.BookingStatus
  bookingId: number
  @IsOptional()
  valetId: string
  @IsOptional()
  managerId: string
}
</file>

<file path="apps/api/src/models/booking-timelines/rest/booking-timelines.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateBookingTimeline } from './dtos/create.dto'
import { BookingTimelineQueryDto } from './dtos/query.dto'
import { UpdateBookingTimeline } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { BookingTimelineEntity } from './entity/booking-timeline.entity'

@ApiTags('booking-timelines')
@Controller('booking-timelines')
export class BookingTimelinesController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: BookingTimelineEntity })
  @Post()
  create(
    @Body() createBookingTimelineDto: CreateBookingTimeline,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, createBookingTimelineDto.managerId)
    return this.prisma.bookingTimeline.create({
      data: createBookingTimelineDto,
    })
  }

  @ApiOkResponse({ type: [BookingTimelineEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: BookingTimelineQueryDto) {
    return this.prisma.bookingTimeline.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: BookingTimelineEntity })
  @Get(':id')
  findOne(@Param('id') id: number) {
    return this.prisma.bookingTimeline.findUnique({ where: { id } })
  }

  @ApiOkResponse({ type: BookingTimelineEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':id')
  async update(
    @Param('id') id: number,
    @Body() updateBookingTimelineDto: UpdateBookingTimeline,
    @GetUser() user: GetUserType,
  ) {
    const bookingTimeline = await this.prisma.bookingTimeline.findUnique({
      where: { id },
    })
    checkRowLevelPermission(user, bookingTimeline.managerId)
    return this.prisma.bookingTimeline.update({
      where: { id },
      data: updateBookingTimelineDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':id')
  async remove(@Param('id') id: number, @GetUser() user: GetUserType) {
    const bookingTimeline = await this.prisma.bookingTimeline.findUnique({
      where: { id },
    })
    checkRowLevelPermission(user, bookingTimeline.managerId)
    return this.prisma.bookingTimeline.delete({ where: { id } })
  }
}
</file>

<file path="apps/api/src/models/booking-timelines/booking-timelines.module.ts">
import { Module } from '@nestjs/common'
import { BookingTimelinesService } from './graphql/booking-timelines.service'
import { BookingTimelinesResolver } from './graphql/booking-timelines.resolver'
import { BookingTimelinesController } from './rest/booking-timelines.controller'

@Module({
  providers: [BookingTimelinesResolver, BookingTimelinesService],
  exports: [BookingTimelinesService],
  controllers: [BookingTimelinesController],
})
export class BookingTimelinesModule {}
</file>

<file path="apps/api/src/models/bookings/graphql/dtos/create-booking.input.ts">
import { Field, Float, InputType, OmitType, PickType } from '@nestjs/graphql'
import { Booking } from '../entity/booking.entity'
import { Garage, SlotType } from '@prisma/client'
import { CreateValetAssignmentInputWithoutBookingId } from 'src/models/valet-assignments/graphql/dtos/create-valet-assignment.input'

@InputType()
export class CreateBookingInput extends PickType(
  Booking,
  ['customerId', 'endTime', 'startTime', 'vehicleNumber', 'phoneNumber'],
  InputType,
) {
  garageId: Garage['id']
  @Field(() => SlotType)
  type: SlotType

  @Field(() => Float)
  pricePerHour?: number
  @Field(() => Float)
  totalPrice?: number

  valetAssignment?: CreateValetAssignmentInputWithoutBookingId
}
</file>

<file path="apps/api/src/models/bookings/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { BookingOrderByWithRelationInput } from './order-by.args'
import { BookingWhereInput, BookingWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.BookingScalarFieldEnum, {
  name: 'BookingScalarFieldEnum',
})

@ArgsType()
class FindManyBookingArgsStrict
  implements
    RestrictProperties<
      FindManyBookingArgsStrict,
      Omit<Prisma.BookingFindManyArgs, 'include' | 'select'>
    >
{
  where: BookingWhereInput
  orderBy: BookingOrderByWithRelationInput[]
  cursor: BookingWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.BookingScalarFieldEnum])
  distinct: Prisma.BookingScalarFieldEnum[]
}

@ArgsType()
export class FindManyBookingArgs extends PartialType(
  FindManyBookingArgsStrict,
) {}

@ArgsType()
export class FindUniqueBookingArgs {
  where: BookingWhereUniqueInput
}
</file>

<file path="apps/api/src/models/bookings/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { BookingTimelineOrderByRelationAggregateInput } from 'src/models/booking-timelines/graphql/dtos/order-by.args'
import { CustomerOrderByWithRelationInput } from 'src/models/customers/graphql/dtos/order-by.args'
import { SlotOrderByWithRelationInput } from 'src/models/slots/graphql/dtos/order-by.args'
import { ValetAssignmentOrderByWithRelationInput } from 'src/models/valet-assignments/graphql/dtos/order-by.args'

@InputType()
export class BookingOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      BookingOrderByWithRelationInputStrict,
      Prisma.BookingOrderByWithRelationInput
    >
{
  @Field(() => Prisma.SortOrder)
  id: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  pricePerHour: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  totalPrice: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  startTime: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  endTime: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  vehicleNumber: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  phoneNumber: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  passcode: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  status: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  slotId: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  customerId: Prisma.SortOrder
  ValetAssignment: ValetAssignmentOrderByWithRelationInput
  Customer: CustomerOrderByWithRelationInput
  Slot: SlotOrderByWithRelationInput
  BookingTimeline: BookingTimelineOrderByRelationAggregateInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class BookingOrderByWithRelationInput extends PartialType(
  BookingOrderByWithRelationInputStrict,
) {}

@InputType()
export class BookingOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/bookings/graphql/dtos/update-booking.input.ts">
import { CreateBookingInput } from './create-booking.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Booking } from '@prisma/client'

@InputType()
export class UpdateBookingInput extends PartialType(CreateBookingInput) {
  id: Booking['id']
}
</file>

<file path="apps/api/src/models/bookings/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { $Enums, BookingStatus, Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  FloatFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { BookingTimelineListRelationFilter } from 'src/models/booking-timelines/graphql/dtos/where.args'
import { CustomerRelationFilter } from 'src/models/customers/graphql/dtos/where.args'
import { SlotRelationFilter } from 'src/models/slots/graphql/dtos/where.args'
import { ValetAssignmentRelationFilter } from 'src/models/valet-assignments/graphql/dtos/where.args'

@InputType()
export class BookingWhereUniqueInput {
  id: number
}

@InputType()
export class EnumBookingStatusFilter {
  @Field(() => BookingStatus, { nullable: true })
  equals: BookingStatus;
  @Field(() => [BookingStatus], { nullable: true })
  in: BookingStatus[]
  @Field(() => [BookingStatus], { nullable: true })
  notIn: BookingStatus[]
  @Field(() => BookingStatus, { nullable: true })
  not: BookingStatus
}

@InputType()
export class BookingWhereInputStrict
  implements
    RestrictProperties<BookingWhereInputStrict, Prisma.BookingWhereInput>
{
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  pricePerHour: FloatFilter
  totalPrice: FloatFilter
  startTime: DateTimeFilter
  endTime: DateTimeFilter
  vehicleNumber: StringFilter
  phoneNumber: StringFilter
  passcode: StringFilter

  status: EnumBookingStatusFilter
  slotId: IntFilter
  customerId: StringFilter
  ValetAssignment: ValetAssignmentRelationFilter
  Customer: CustomerRelationFilter
  Slot: SlotRelationFilter
  BookingTimeline: BookingTimelineListRelationFilter

  AND: BookingWhereInput[]
  OR: BookingWhereInput[]
  NOT: BookingWhereInput[]
}

@InputType()
export class BookingWhereInput extends PartialType(BookingWhereInputStrict) {}

@InputType()
export class BookingListRelationFilter {
  every?: BookingWhereInput
  some?: BookingWhereInput
  none?: BookingWhereInput
}

@InputType()
export class BookingRelationFilter {
  is?: BookingWhereInput
  isNot?: BookingWhereInput
}
</file>

<file path="apps/api/src/models/bookings/graphql/entity/booking.entity.ts">
import { Field, ObjectType, registerEnumType } from '@nestjs/graphql'
import { $Enums, Booking as BookingType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType($Enums.BookingStatus, {
  name: 'BookingStatus',
})

@ObjectType()
export class Booking implements RestrictProperties<Booking, BookingType> {
  id: number
  createdAt: Date
  updatedAt: Date
  @Field({ nullable: true })
  pricePerHour: number
  @Field({ nullable: true })
  totalPrice: number
  startTime: Date
  endTime: Date
  vehicleNumber: string
  @Field({ nullable: true })
  phoneNumber: string
  @Field({ nullable: true })
  passcode: string
  @Field(() => $Enums.BookingStatus)
  status: $Enums.BookingStatus
  slotId: number
  customerId: string
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/bookings/graphql/bookings.resolver.ts">
import {
  Resolver,
  ResolveField,
  Query,
  Mutation,
  Args,
  Parent,
} from '@nestjs/graphql'
import { BookingsService } from './bookings.service'
import { Booking } from './entity/booking.entity'
import { FindManyBookingArgs, FindUniqueBookingArgs } from './dtos/find.args'
import { CreateBookingInput } from './dtos/create-booking.input'
import { UpdateBookingInput } from './dtos/update-booking.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { Slot } from 'src/models/slots/graphql/entity/slot.entity'
import { Customer } from 'src/models/customers/graphql/entity/customer.entity'
import { ValetAssignment } from 'src/models/valet-assignments/graphql/entity/valet-assignment.entity'
import { AggregateCountOutput } from 'src/common/dtos/common.input'
import { BookingWhereInput } from './dtos/where.args'
import { BookingTimeline } from 'src/models/booking-timelines/graphql/entity/booking-timeline.entity'
import { BadRequestException } from '@nestjs/common'

@Resolver(() => Booking)
export class BookingsResolver {
  constructor(
    private readonly bookingsService: BookingsService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated()
  @Mutation(() => Booking)
  createBooking(
    @Args('createBookingInput') args: CreateBookingInput,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, args.customerId)
    return this.bookingsService.create(args)
  }

  @AllowAuthenticated('admin')
  @Query(() => [Booking], { name: 'bookings' })
  findAll(@Args() args: FindManyBookingArgs) {
    return this.bookingsService.findAll(args)
  }

  @AllowAuthenticated('valet')
  @Query(() => [Booking], { name: 'bookingsForValet' })
  async bookingsForValet(
    @Args() args: FindManyBookingArgs,
    @GetUser() user: GetUserType,
  ) {
    const company = await this.prisma.company.findFirst({
      where: { Valets: { some: { uid: user.uid } } },
    })
    return this.bookingsService.findAll({
      ...args,
      where: {
        ...args.where,
        Slot: { is: { Garage: { is: { companyId: { equals: company.id } } } } },
      },
    })
  }

  @AllowAuthenticated()
  @Query(() => [Booking], { name: 'bookingsForCustomer' })
  bookingsForCustomer(
    @Args() args: FindManyBookingArgs,
    @GetUser() user: GetUserType,
  ) {
    return this.bookingsService.findAll({
      ...args,
      where: { ...args.where, customerId: { equals: user.uid } },
    })
  }

  @AllowAuthenticated('manager', 'admin')
  @Query(() => [Booking], { name: 'bookingsForGarage' })
  async bookingsForGarage(
    @Args()
    { cursor, distinct, orderBy, skip, take, where }: FindManyBookingArgs,
    @GetUser() user: GetUserType,
  ) {
    const garageId = where.Slot.is.garageId.equals
    if (!garageId) {
      throw new BadRequestException('Pass garage id in where.Slot.is.garageId')
    }
    const garage = await this.prisma.garage.findUnique({
      where: { id: garageId },
      include: { Company: { include: { Managers: true } } },
    })

    checkRowLevelPermission(
      user,
      garage.Company.Managers.map((manager) => manager.uid),
    )

    return this.bookingsService.findAll({
      cursor,
      distinct,
      orderBy,
      skip,
      take,
      where: {
        ...where,
        Slot: { is: { garageId: { equals: garageId } } },
      },
    })
  }

  @Query(() => AggregateCountOutput)
  async bookingsCount(
    @Args('where', { nullable: true })
    where: BookingWhereInput,
  ) {
    const bookings = await this.prisma.booking.aggregate({
      where,
      _count: { _all: true },
    })
    return { count: bookings._count._all }
  }

  @Query(() => Booking, { name: 'booking' })
  findOne(@Args() args: FindUniqueBookingArgs) {
    return this.bookingsService.findOne(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Booking)
  async updateBooking(
    @Args('updateBookingInput') args: UpdateBookingInput,
    @GetUser() user: GetUserType,
  ) {
    const booking = await this.prisma.booking.findUnique({
      where: { id: args.id },
    })
    checkRowLevelPermission(user, booking.customerId)
    return this.bookingsService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Booking)
  async removeBooking(
    @Args() args: FindUniqueBookingArgs,
    @GetUser() user: GetUserType,
  ) {
    const booking = await this.prisma.booking.findUnique(args)
    checkRowLevelPermission(user, booking.customerId)
    return this.bookingsService.remove(args)
  }

  @ResolveField(() => Slot)
  slot(@Parent() booking: Booking) {
    return this.prisma.slot.findFirst({ where: { id: booking.slotId } })
  }

  @ResolveField(() => Customer)
  customer(@Parent() booking: Booking) {
    return this.prisma.customer.findFirst({
      where: { uid: booking.customerId },
    })
  }

  @ResolveField(() => [BookingTimeline])
  bookingTimeline(@Parent() booking: Booking) {
    return this.prisma.bookingTimeline.findMany({
      where: { bookingId: booking.id },
    })
  }

  @ResolveField(() => ValetAssignment, { nullable: true })
  valetAssignment(@Parent() booking: Booking) {
    return this.prisma.valetAssignment.findFirst({
      where: { bookingId: booking.id },
    })
  }
}
</file>

<file path="apps/api/src/models/bookings/graphql/bookings.service.ts">
import { Injectable, NotFoundException } from '@nestjs/common'
import { FindManyBookingArgs, FindUniqueBookingArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateBookingInput } from './dtos/create-booking.input'
import { UpdateBookingInput } from './dtos/update-booking.input'
import { generateSixDigitNumber } from 'src/common/util'
import { SlotType } from '@prisma/client'

@Injectable()
export class BookingsService {
  constructor(private readonly prisma: PrismaService) {}
  async create({
    customerId,
    endTime,
    garageId,
    startTime,
    type,
    vehicleNumber,
    phoneNumber,
    pricePerHour,
    totalPrice,
    valetAssignment,
  }: CreateBookingInput) {
    // Create customer
    const customer = await this.prisma.customer.findUnique({
      where: { uid: customerId },
    })

    if (!customer?.uid) {
      await this.prisma.customer.create({
        data: { uid: customerId },
      })
    }

    const passcode = generateSixDigitNumber().toString()

    let startDate: Date
    let endDate: Date

    // If startTime or endTime are strings, convert them to Date objects
    if (typeof startTime === 'string') {
      startDate = new Date(startTime)
    }
    if (typeof endTime === 'string') {
      endDate = new Date(endTime)
    }

    const slot = await this.getFreeSlot({
      endTime: endDate,
      startTime: startDate,
      garageId,
      type,
    })

    if (!slot) {
      throw new NotFoundException('No slots found.')
    }

    return this.prisma.$transaction(async (tx) => {
      const booking = await tx.booking.create({
        data: {
          endTime: new Date(endTime).toISOString(),
          startTime: new Date(startTime).toISOString(),
          vehicleNumber,
          customerId,
          phoneNumber,
          passcode,
          slotId: slot.id,
          pricePerHour,
          totalPrice,
          ...(valetAssignment
            ? { ValetAssignment: { create: valetAssignment } }
            : null),
        },
      })
      await tx.bookingTimeline.create({
        data: { bookingId: booking.id, status: 'BOOKED' },
      })

      return booking
    })
  }

  findAll(args: FindManyBookingArgs) {
    return this.prisma.booking.findMany(args)
  }

  findOne(args: FindUniqueBookingArgs) {
    return this.prisma.booking.findUnique(args)
  }

  update(updateBookingInput: UpdateBookingInput) {
    const { id, ...data } = updateBookingInput
    return this.prisma.booking.update({
      where: { id },
      data: data,
    })
  }

  remove(args: FindUniqueBookingArgs) {
    return this.prisma.booking.delete(args)
  }

  getFreeSlot({
    garageId,
    startTime,
    endTime,
    type,
  }: {
    garageId: number
    startTime: string | Date
    endTime: string | Date
    type: SlotType
  }) {
    return this.prisma.slot.findFirst({
      where: {
        garageId: garageId,
        type: type,
        Bookings: {
          none: {
            OR: [
              { startTime: { lt: endTime }, endTime: { gt: startTime } },
              { startTime: { gt: startTime }, endTime: { lt: endTime } },
            ],
          },
        },
      },
    })
  }
}
</file>

<file path="apps/api/src/models/bookings/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { BookingEntity } from '../entity/booking.entity'

export class CreateBooking extends OmitType(BookingEntity, [
  'createdAt',
  'updatedAt',
  'id',
]) {}
</file>

<file path="apps/api/src/models/bookings/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class BookingQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.BookingScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.BookingScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/bookings/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateBooking } from './create.dto'
import { Booking } from '@prisma/client'

export class UpdateBooking extends PartialType(CreateBooking) {
  id: Booking['id']
}
</file>

<file path="apps/api/src/models/bookings/rest/entity/booking.entity.ts">
import { $Enums, Booking } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class BookingEntity
  implements RestrictProperties<BookingEntity, Booking>
{
  id: number
  createdAt: Date
  updatedAt: Date
  @IsOptional()
  pricePerHour: number
  @IsOptional()
  totalPrice: number
  startTime: Date
  endTime: Date
  vehicleNumber: string
  @IsOptional()
  phoneNumber: string
  @IsOptional()
  passcode: string
  status: $Enums.BookingStatus
  slotId: number
  customerId: string
}
</file>

<file path="apps/api/src/models/bookings/rest/bookings.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateBooking } from './dtos/create.dto'
import { BookingQueryDto } from './dtos/query.dto'
import { UpdateBooking } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { BookingEntity } from './entity/booking.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('bookings')
@Controller('bookings')
export class BookingsController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: BookingEntity })
  @Post()
  create(
    @Body() createBookingDto: CreateBooking,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, createBookingDto.customerId)
    return this.prisma.booking.create({ data: createBookingDto })
  }

  @ApiOkResponse({ type: [BookingEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: BookingQueryDto) {
    return this.prisma.booking.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: BookingEntity })
  @Get(':id')
  findOne(@Param('id') id: number) {
    return this.prisma.booking.findUnique({ where: { id } })
  }

  @ApiOkResponse({ type: BookingEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':id')
  async update(
    @Param('id') id: number,
    @Body() updateBookingDto: UpdateBooking,
    @GetUser() user: GetUserType,
  ) {
    const booking = await this.prisma.booking.findUnique({ where: { id } })
    checkRowLevelPermission(user, booking.customerId)
    return this.prisma.booking.update({
      where: { id },
      data: updateBookingDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':id')
  async remove(@Param('id') id: number, @GetUser() user: GetUserType) {
    const booking = await this.prisma.booking.findUnique({ where: { id } })
    checkRowLevelPermission(user, booking.customerId)
    return this.prisma.booking.delete({ where: { id } })
  }
}
</file>

<file path="apps/api/src/models/bookings/bookings.module.ts">
import { Module } from '@nestjs/common'
import { BookingsService } from './graphql/bookings.service'
import { BookingsResolver } from './graphql/bookings.resolver'
import { BookingsController } from './rest/bookings.controller'

@Module({
  providers: [BookingsResolver, BookingsService],
  exports: [BookingsService],
  controllers: [BookingsController],
})
export class BookingsModule {}
</file>

<file path="apps/api/src/models/companies/graphql/dtos/create-company.input.ts">
import { InputType, PickType } from '@nestjs/graphql'
import { Company } from '../entity/company.entity'

@InputType()
export class CreateCompanyInput extends PickType(
  Company,
  ['displayName', 'description'],
  InputType,
) {
  managerId: string
  managerName?: string
}
</file>

<file path="apps/api/src/models/companies/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { CompanyOrderByWithRelationInput } from './order-by.args'
import { CompanyWhereInput, CompanyWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.CompanyScalarFieldEnum, {
  name: 'CompanyScalarFieldEnum',
})

@ArgsType()
class FindManyCompanyArgsStrict
  implements
    RestrictProperties<
      FindManyCompanyArgsStrict,
      Omit<Prisma.CompanyFindManyArgs, 'include' | 'select'>
    >
{
  where: CompanyWhereInput
  orderBy: CompanyOrderByWithRelationInput[]
  cursor: CompanyWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.CompanyScalarFieldEnum])
  distinct: Prisma.CompanyScalarFieldEnum[]
}

@ArgsType()
export class FindManyCompanyArgs extends PartialType(
  FindManyCompanyArgsStrict,
) {}

@ArgsType()
export class FindUniqueCompanyArgs {
  where: CompanyWhereUniqueInput
}
</file>

<file path="apps/api/src/models/companies/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { GarageOrderByRelationAggregateInput } from 'src/models/garages/graphql/dtos/order-by.args'
import { ManagerOrderByRelationAggregateInput } from 'src/models/managers/graphql/dtos/order-by.args'
import { ValetOrderByRelationAggregateInput } from 'src/models/valets/graphql/dtos/order-by.args'

@InputType()
export class CompanyOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      CompanyOrderByWithRelationInputStrict,
      Prisma.CompanyOrderByWithRelationInput
    >
{
  @Field(() => Prisma.SortOrder)
  id: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  displayName: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  description: Prisma.SortOrder
  Garages: GarageOrderByRelationAggregateInput
  Managers: ManagerOrderByRelationAggregateInput
  Valets: ValetOrderByRelationAggregateInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class CompanyOrderByWithRelationInput extends PartialType(
  CompanyOrderByWithRelationInputStrict,
) {}

@InputType()
export class CompanyOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/companies/graphql/dtos/update-company.input.ts">
import { CreateCompanyInput } from './create-company.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Company } from '@prisma/client'

@InputType()
export class UpdateCompanyInput extends PartialType(CreateCompanyInput) {
  id: Company['id']
}
</file>

<file path="apps/api/src/models/companies/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { GarageListRelationFilter } from 'src/models/garages/graphql/dtos/where.args'
import { ManagerListRelationFilter } from 'src/models/managers/graphql/dtos/where.args'
import { ValetListRelationFilter } from 'src/models/valets/graphql/dtos/where.args'

@InputType()
export class CompanyWhereUniqueInput {
  id: number
}

@InputType()
export class CompanyWhereInputStrict
  implements
    RestrictProperties<CompanyWhereInputStrict, Prisma.CompanyWhereInput>
{
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  description: StringFilter
  Garages: GarageListRelationFilter
  Managers: ManagerListRelationFilter
  Valets: ValetListRelationFilter

  AND: CompanyWhereInput[]
  OR: CompanyWhereInput[]
  NOT: CompanyWhereInput[]
}

@InputType()
export class CompanyWhereInput extends PartialType(CompanyWhereInputStrict) {}

@InputType()
export class CompanyListRelationFilter {
  every?: CompanyWhereInput
  some?: CompanyWhereInput
  none?: CompanyWhereInput
}

@InputType()
export class CompanyRelationFilter {
  is?: CompanyWhereInput
  isNot?: CompanyWhereInput
}
</file>

<file path="apps/api/src/models/companies/graphql/entity/company.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { Company as CompanyType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class Company implements RestrictProperties<Company, CompanyType> {
  id: number
  createdAt: Date
  updatedAt: Date
  @Field({ nullable: true })
  displayName: string
  @Field({ nullable: true })
  description: string
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/companies/graphql/companies.resolver.ts">
import {
  Resolver,
  Query,
  Mutation,
  Args,
  ResolveField,
  Parent,
} from '@nestjs/graphql'
import { CompaniesService } from './companies.service'
import { Company } from './entity/company.entity'
import { FindManyCompanyArgs, FindUniqueCompanyArgs } from './dtos/find.args'
import { CreateCompanyInput } from './dtos/create-company.input'
import { UpdateCompanyInput } from './dtos/update-company.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { Manager } from 'src/models/managers/graphql/entity/manager.entity'
import { Garage } from 'src/models/garages/graphql/entity/garage.entity'

@Resolver(() => Company)
export class CompaniesResolver {
  constructor(
    private readonly companiesService: CompaniesService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated()
  @Mutation(() => Company)
  createCompany(
    @Args('createCompanyInput') args: CreateCompanyInput,
    @GetUser() user: GetUserType,
  ) {
    const managerId = args.managerId

    checkRowLevelPermission(user, managerId)
    return this.companiesService.create(args)
  }

  @AllowAuthenticated()
  @Query(() => [Company], { name: 'companies' })
  findAll(@Args() args: FindManyCompanyArgs) {
    return this.companiesService.findAll(args)
  }

  @AllowAuthenticated()
  @Query(() => Company)
  myCompany(@GetUser() user: GetUserType) {
    return this.prisma.company.findFirst({
      where: { Managers: { some: { uid: user.uid } } },
    })
  }

  @Query(() => Company, { name: 'company' })
  findOne(@Args() args: FindUniqueCompanyArgs) {
    return this.companiesService.findOne(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Company)
  async updateCompany(
    @Args('updateCompanyInput') args: UpdateCompanyInput,
    @GetUser() user: GetUserType,
  ) {
    const company = await this.prisma.company.findUnique({
      where: { id: args.id },
      include: { Managers: true },
    })
    checkRowLevelPermission(
      user,
      company.Managers.map((man) => man.uid),
    )
    return this.companiesService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Company)
  async removeCompany(
    @Args() args: FindUniqueCompanyArgs,
    @GetUser() user: GetUserType,
  ) {
    const company = await this.prisma.company.findUnique({
      ...args,
      include: { Managers: true },
    })
    checkRowLevelPermission(
      user,
      company.Managers.map((man) => man.uid),
    )
    return this.companiesService.remove(args)
  }

  @ResolveField(() => [Garage])
  garages(@Parent() company: Company) {
    return this.prisma.garage.findMany({ where: { companyId: company.id } })
  }

  @ResolveField(() => [Manager])
  managers(@Parent() company: Company) {
    return this.prisma.manager.findMany({ where: { companyId: company.id } })
  }
}
</file>

<file path="apps/api/src/models/companies/graphql/companies.service.ts">
import { Injectable } from '@nestjs/common'
import { FindManyCompanyArgs, FindUniqueCompanyArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateCompanyInput } from './dtos/create-company.input'
import { UpdateCompanyInput } from './dtos/update-company.input'

@Injectable()
export class CompaniesService {
  constructor(private readonly prisma: PrismaService) {}
  async create({
    description,
    displayName,
    managerId,
    managerName,
  }: CreateCompanyInput) {
    return this.prisma.company.create({
      data: {
        description,
        displayName,
        Managers: {
          create: {
            displayName: managerName,
            uid: managerId,
          },
        },
      },
    })
  }

  findAll(args: FindManyCompanyArgs) {
    return this.prisma.company.findMany(args)
  }

  findOne(args: FindUniqueCompanyArgs) {
    return this.prisma.company.findUnique(args)
  }

  update(updateCompanyInput: UpdateCompanyInput) {
    const { id, ...data } = updateCompanyInput
    return this.prisma.company.update({
      where: { id },
      data: data,
    })
  }

  remove(args: FindUniqueCompanyArgs) {
    return this.prisma.company.delete(args)
  }
}
</file>

<file path="apps/api/src/models/companies/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { CompanyEntity } from '../entity/company.entity'

export class CreateCompany extends OmitType(CompanyEntity, [
  'createdAt',
  'updatedAt',
  'id',
]) {}
</file>

<file path="apps/api/src/models/companies/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class CompanyQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.CompanyScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.CompanyScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/companies/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateCompany } from './create.dto'
import { Company } from '@prisma/client'

export class UpdateCompany extends PartialType(CreateCompany) {
  id: Company['id']
}
</file>

<file path="apps/api/src/models/companies/rest/entity/company.entity.ts">
import { Company } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class CompanyEntity
  implements RestrictProperties<CompanyEntity, Company>
{
  id: number
  createdAt: Date
  updatedAt: Date
  @IsOptional()
  displayName: string
  @IsOptional()
  description: string
}
</file>

<file path="apps/api/src/models/companies/rest/companies.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateCompany } from './dtos/create.dto'
import { CompanyQueryDto } from './dtos/query.dto'
import { UpdateCompany } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { CompanyEntity } from './entity/company.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('companies')
@Controller('companies')
export class CompaniesController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: CompanyEntity })
  @Post()
  create(@Body() createCompanyDto: CreateCompany) {
    return this.prisma.company.create({ data: createCompanyDto })
  }

  @ApiOkResponse({ type: [CompanyEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: CompanyQueryDto) {
    return this.prisma.company.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: CompanyEntity })
  @Get(':id')
  findOne(@Param('id') id: number) {
    return this.prisma.company.findUnique({ where: { id } })
  }

  @ApiOkResponse({ type: CompanyEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':id')
  async update(
    @Param('id') id: number,
    @Body() updateCompanyDto: UpdateCompany,
    @GetUser() user: GetUserType,
  ) {
    const company = await this.prisma.company.findUnique({
      where: { id },
      include: { Managers: true },
    })
    checkRowLevelPermission(
      user,
      company.Managers.map((manager) => manager.uid),
    )
    return this.prisma.company.update({
      where: { id },
      data: updateCompanyDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':id')
  async remove(@Param('id') id: number, @GetUser() user: GetUserType) {
    const company = await this.prisma.company.findUnique({
      where: { id },
      include: { Managers: true },
    })
    checkRowLevelPermission(
      user,
      company.Managers.map((manager) => manager.uid),
    )
    return this.prisma.company.delete({ where: { id } })
  }
}
</file>

<file path="apps/api/src/models/companies/companies.module.ts">
import { Module } from '@nestjs/common'
import { CompaniesService } from './graphql/companies.service'
import { CompaniesResolver } from './graphql/companies.resolver'
import { CompaniesController } from './rest/companies.controller'

@Module({
  providers: [CompaniesResolver, CompaniesService],
  exports: [CompaniesService],
  controllers: [CompaniesController],
})
export class CompaniesModule {}
</file>

<file path="apps/api/src/models/customers/graphql/dtos/create-customer.input.ts">
import { InputType, PickType } from '@nestjs/graphql'
import { Customer } from '../entity/customer.entity'

@InputType()
export class CreateCustomerInput extends PickType(
  Customer,
  ['uid', 'displayName'],
  InputType,
) {}
</file>

<file path="apps/api/src/models/customers/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { CustomerOrderByWithRelationInput } from './order-by.args'
import { CustomerWhereInput, CustomerWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.CustomerScalarFieldEnum, {
  name: 'CustomerScalarFieldEnum',
})

@ArgsType()
class FindManyCustomerArgsStrict
  implements
    RestrictProperties<
      FindManyCustomerArgsStrict,
      Omit<Prisma.CustomerFindManyArgs, 'include' | 'select'>
    >
{
  where: CustomerWhereInput
  orderBy: CustomerOrderByWithRelationInput[]
  cursor: CustomerWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.CustomerScalarFieldEnum])
  distinct: Prisma.CustomerScalarFieldEnum[]
}

@ArgsType()
export class FindManyCustomerArgs extends PartialType(
  FindManyCustomerArgsStrict,
) {}

@ArgsType()
export class FindUniqueCustomerArgs {
  where: CustomerWhereUniqueInput
}
</file>

<file path="apps/api/src/models/customers/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { BookingOrderByRelationAggregateInput } from 'src/models/bookings/graphql/dtos/order-by.args'
import { ReviewOrderByRelationAggregateInput } from 'src/models/reviews/graphql/dtos/order-by.args'
import { UserOrderByWithRelationInput } from 'src/models/users/graphql/dtos/order-by.args'

@InputType()
export class CustomerOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      CustomerOrderByWithRelationInputStrict,
      Prisma.CustomerOrderByWithRelationInput
    >
{
  User: UserOrderByWithRelationInput
  @Field(() => Prisma.SortOrder)
  uid: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  displayName: Prisma.SortOrder

  Bookings: BookingOrderByRelationAggregateInput
  Reviews: ReviewOrderByRelationAggregateInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class CustomerOrderByWithRelationInput extends PartialType(
  CustomerOrderByWithRelationInputStrict,
) {}

@InputType()
export class CustomerOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/customers/graphql/dtos/update-customer.input.ts">
import { CreateCustomerInput } from './create-customer.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Customer } from '@prisma/client'

@InputType()
export class UpdateCustomerInput extends PartialType(CreateCustomerInput) {
  uid: Customer['uid']
}
</file>

<file path="apps/api/src/models/customers/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { BookingListRelationFilter } from 'src/models/bookings/graphql/dtos/where.args'
import { ReviewListRelationFilter } from 'src/models/reviews/graphql/dtos/where.args'
import { UserRelationFilter } from 'src/models/users/graphql/dtos/where.args'

@InputType()
export class CustomerWhereUniqueInput {
  uid: string
}

@InputType()
export class CustomerWhereInputStrict
  implements
    RestrictProperties<CustomerWhereInputStrict, Prisma.CustomerWhereInput>
{
  User: UserRelationFilter
  uid: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  Bookings: BookingListRelationFilter
  Reviews: ReviewListRelationFilter

  AND: CustomerWhereInput[]
  OR: CustomerWhereInput[]
  NOT: CustomerWhereInput[]
}

@InputType()
export class CustomerWhereInput extends PartialType(CustomerWhereInputStrict) {}

@InputType()
export class CustomerListRelationFilter {
  every?: CustomerWhereInput
  some?: CustomerWhereInput
  none?: CustomerWhereInput
}

@InputType()
export class CustomerRelationFilter {
  is?: CustomerWhereInput
  isNot?: CustomerWhereInput
}
</file>

<file path="apps/api/src/models/customers/graphql/entity/customer.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { Customer as CustomerType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class Customer implements RestrictProperties<Customer, CustomerType> {
  uid: string
  createdAt: Date
  updatedAt: Date
  @Field({ nullable: true })
  displayName: string
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/customers/graphql/customers.resolver.ts">
import {
  Resolver,
  Query,
  Mutation,
  Args,
  Parent,
  ResolveField,
} from '@nestjs/graphql'
import { CustomersService } from './customers.service'
import { Customer } from './entity/customer.entity'
import { FindManyCustomerArgs, FindUniqueCustomerArgs } from './dtos/find.args'
import { CreateCustomerInput } from './dtos/create-customer.input'
import { UpdateCustomerInput } from './dtos/update-customer.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { User } from 'src/models/users/graphql/entity/user.entity'
import { Booking } from 'src/models/bookings/graphql/entity/booking.entity'

@Resolver(() => Customer)
export class CustomersResolver {
  constructor(
    private readonly customersService: CustomersService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated()
  @Mutation(() => Customer)
  createCustomer(
    @Args('createCustomerInput') args: CreateCustomerInput,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, args.uid)
    return this.customersService.create(args)
  }

  @Query(() => [Customer], { name: 'customers' })
  findAll(@Args() args: FindManyCustomerArgs) {
    return this.customersService.findAll(args)
  }

  @Query(() => Customer, { name: 'customer' })
  findOne(@Args() args: FindUniqueCustomerArgs) {
    return this.customersService.findOne(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Customer)
  async updateCustomer(
    @Args('updateCustomerInput') args: UpdateCustomerInput,
    @GetUser() user: GetUserType,
  ) {
    const customer = await this.prisma.customer.findUnique({
      where: { uid: args.uid },
    })
    checkRowLevelPermission(user, customer.uid)
    return this.customersService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Customer)
  async removeCustomer(
    @Args() args: FindUniqueCustomerArgs,
    @GetUser() user: GetUserType,
  ) {
    const customer = await this.prisma.customer.findUnique(args)
    checkRowLevelPermission(user, customer.uid)
    return this.customersService.remove(args)
  }

  @ResolveField(() => User, { nullable: true })
  user(@Parent() customer: Customer) {
    return this.prisma.user.findUnique({ where: { uid: customer.uid } })
  }

  @ResolveField(() => [Booking])
  bookings(@Parent() customer: Customer) {
    return this.prisma.booking.findMany({ where: { customerId: customer.uid } })
  }
}
</file>

<file path="apps/api/src/models/customers/graphql/customers.service.ts">
import { Injectable } from '@nestjs/common'
import { FindManyCustomerArgs, FindUniqueCustomerArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateCustomerInput } from './dtos/create-customer.input'
import { UpdateCustomerInput } from './dtos/update-customer.input'

@Injectable()
export class CustomersService {
  constructor(private readonly prisma: PrismaService) {}
  create(createCustomerInput: CreateCustomerInput) {
    return this.prisma.customer.create({
      data: createCustomerInput,
    })
  }

  findAll(args: FindManyCustomerArgs) {
    return this.prisma.customer.findMany(args)
  }

  findOne(args: FindUniqueCustomerArgs) {
    return this.prisma.customer.findUnique(args)
  }

  update(updateCustomerInput: UpdateCustomerInput) {
    const { uid, ...data } = updateCustomerInput
    return this.prisma.customer.update({
      where: { uid },
      data: data,
    })
  }

  remove(args: FindUniqueCustomerArgs) {
    return this.prisma.customer.delete(args)
  }
}
</file>

<file path="apps/api/src/models/customers/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { CustomerEntity } from '../entity/customer.entity'

export class CreateCustomer extends OmitType(CustomerEntity, [
  'createdAt',
  'updatedAt',
]) {}
</file>

<file path="apps/api/src/models/customers/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class CustomerQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.CustomerScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.CustomerScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/customers/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateCustomer } from './create.dto'
import { Customer } from '@prisma/client'

export class UpdateCustomer extends PartialType(CreateCustomer) {
  uid: Customer['uid']
}
</file>

<file path="apps/api/src/models/customers/rest/entity/customer.entity.ts">
import { Customer } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class CustomerEntity
  implements RestrictProperties<CustomerEntity, Customer>
{
  uid: string
  createdAt: Date
  updatedAt: Date
  @IsOptional()
  displayName: string
}
</file>

<file path="apps/api/src/models/customers/rest/customers.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateCustomer } from './dtos/create.dto'
import { CustomerQueryDto } from './dtos/query.dto'
import { UpdateCustomer } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { CustomerEntity } from './entity/customer.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('customers')
@Controller('customers')
export class CustomersController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: CustomerEntity })
  @Post()
  create(
    @Body() createCustomerDto: CreateCustomer,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, createCustomerDto.uid)
    return this.prisma.customer.create({ data: createCustomerDto })
  }

  @ApiOkResponse({ type: [CustomerEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: CustomerQueryDto) {
    return this.prisma.customer.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: CustomerEntity })
  @Get(':uid')
  findOne(@Param('uid') uid: string) {
    return this.prisma.customer.findUnique({ where: { uid } })
  }

  @ApiOkResponse({ type: CustomerEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':uid')
  async update(
    @Param('uid') uid: string,
    @Body() updateCustomerDto: UpdateCustomer,
    @GetUser() user: GetUserType,
  ) {
    const customer = await this.prisma.customer.findUnique({ where: { uid } })
    checkRowLevelPermission(user, customer.uid)
    return this.prisma.customer.update({
      where: { uid },
      data: updateCustomerDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':uid')
  async remove(@Param('uid') uid: string, @GetUser() user: GetUserType) {
    const customer = await this.prisma.customer.findUnique({ where: { uid } })
    checkRowLevelPermission(user, customer.uid)
    return this.prisma.customer.delete({ where: { uid } })
  }
}
</file>

<file path="apps/api/src/models/customers/customers.module.ts">
import { Module } from '@nestjs/common'
import { CustomersService } from './graphql/customers.service'
import { CustomersResolver } from './graphql/customers.resolver'
import { CustomersController } from './rest/customers.controller'

@Module({
  providers: [CustomersResolver, CustomersService],
  exports: [CustomersService],
  controllers: [CustomersController],
})
export class CustomersModule {}
</file>

<file path="apps/api/src/models/garages/graphql/dtos/create-garage.input.ts">
import { InputType, PickType } from '@nestjs/graphql'
import { Garage } from '../entity/garage.entity'
import { CreateAddressInputWithoutGarageId } from 'src/models/addresses/graphql/dtos/create-address.input'
import { CreateSlotInputWithoutGarageId } from 'src/models/slots/graphql/dtos/create-slot.input'

@InputType()
export class CreateGarageInput extends PickType(
  Garage,
  ['description', 'displayName', 'images'],
  InputType,
) {
  Address: CreateAddressInputWithoutGarageId
  Slots: CreateSlotInputWithoutGarageId[]
}
</file>

<file path="apps/api/src/models/garages/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { GarageOrderByWithRelationInput } from './order-by.args'
import { GarageWhereInput, GarageWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.GarageScalarFieldEnum, {
  name: 'GarageScalarFieldEnum',
})

@ArgsType()
class FindManyGarageArgsStrict
  implements
    RestrictProperties<
      FindManyGarageArgsStrict,
      Omit<Prisma.GarageFindManyArgs, 'include' | 'select'>
    >
{
  where: GarageWhereInput
  orderBy: GarageOrderByWithRelationInput[]
  cursor: GarageWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.GarageScalarFieldEnum])
  distinct: Prisma.GarageScalarFieldEnum[]
}

@ArgsType()
export class FindManyGarageArgs extends PartialType(FindManyGarageArgsStrict) {}

@ArgsType()
export class FindUniqueGarageArgs {
  where: GarageWhereUniqueInput
}
</file>

<file path="apps/api/src/models/garages/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { AddressOrderByWithRelationInput } from 'src/models/addresses/graphql/dtos/order-by.args'
import { CompanyOrderByWithRelationInput } from 'src/models/companies/graphql/dtos/order-by.args'
import { ReviewOrderByRelationAggregateInput } from 'src/models/reviews/graphql/dtos/order-by.args'
import { SlotOrderByRelationAggregateInput } from 'src/models/slots/graphql/dtos/order-by.args'
import { VerificationOrderByWithRelationInput } from 'src/models/verifications/graphql/dtos/order-by.args'

@InputType()
export class GarageOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      GarageOrderByWithRelationInputStrict,
      Prisma.GarageOrderByWithRelationInput
    >
{
  @Field(() => Prisma.SortOrder)
  id: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  displayName: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  description: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  images: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  companyId: Prisma.SortOrder
  Company: CompanyOrderByWithRelationInput
  Address: AddressOrderByWithRelationInput
  Verification: VerificationOrderByWithRelationInput
  Reviews: ReviewOrderByRelationAggregateInput
  Slots: SlotOrderByRelationAggregateInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class GarageOrderByWithRelationInput extends PartialType(
  GarageOrderByWithRelationInputStrict,
) {}

@InputType()
export class GarageOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/garages/graphql/dtos/search-filter.input.ts">
import { InputType, ObjectType, PickType } from '@nestjs/graphql'
import { FindManyGarageArgs } from './find.args'
import { Slot } from 'src/models/slots/graphql/entity/slot.entity'

@InputType()
export class DateFilterInput {
  start: string
  end: string
}

@InputType()
export class GarageFilter extends PickType(
  FindManyGarageArgs,
  ['where', 'orderBy', 'skip', 'take'],
  InputType,
) {}

@ObjectType()
export class MinimalSlotGroupBy extends PickType(Slot, [
  'type',
  'pricePerHour',
]) {
  count: number
}
</file>

<file path="apps/api/src/models/garages/graphql/dtos/update-garage.input.ts">
import { CreateGarageInput } from './create-garage.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Garage } from '@prisma/client'

@InputType()
export class UpdateGarageInput extends PartialType(CreateGarageInput) {
  id: Garage['id']
}
</file>

<file path="apps/api/src/models/garages/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
  StringListFilter,
} from 'src/common/dtos/common.input'
import { AddressRelationFilter } from 'src/models/addresses/graphql/dtos/where.args'
import { CompanyRelationFilter } from 'src/models/companies/graphql/dtos/where.args'
import { ReviewListRelationFilter } from 'src/models/reviews/graphql/dtos/where.args'
import { SlotListRelationFilter } from 'src/models/slots/graphql/dtos/where.args'
import { VerificationRelationFilter } from 'src/models/verifications/graphql/dtos/where.args'

@InputType()
export class GarageWhereUniqueInput {
  id: number
}

@InputType()
export class GarageWhereInputStrict
  implements
    RestrictProperties<GarageWhereInputStrict, Prisma.GarageWhereInput>
{
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  description: StringFilter
  images: StringListFilter
  companyId: IntFilter
  Company: CompanyRelationFilter
  Address: AddressRelationFilter
  Verification: VerificationRelationFilter
  Reviews: ReviewListRelationFilter
  Slots: SlotListRelationFilter

  AND: GarageWhereInput[]
  OR: GarageWhereInput[]
  NOT: GarageWhereInput[]
}

@InputType()
export class GarageWhereInput extends PartialType(GarageWhereInputStrict) {}

@InputType()
export class GarageListRelationFilter {
  every?: GarageWhereInput
  some?: GarageWhereInput
  none?: GarageWhereInput
}

@InputType()
export class GarageRelationFilter {
  is?: GarageWhereInput
  isNot?: GarageWhereInput
}
</file>

<file path="apps/api/src/models/garages/graphql/entity/garage.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { Garage as GarageType, SlotType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class Garage implements RestrictProperties<Garage, GarageType> {
  id: number
  createdAt: Date
  updatedAt: Date
  @Field({ nullable: true })
  displayName: string
  @Field({ nullable: true })
  description: string
  images: string[]
  companyId: number
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}

@ObjectType()
export class SlotTypeCount {
  @Field(() => SlotType)
  type: SlotType
  count?: number
}
</file>

<file path="apps/api/src/models/garages/graphql/garages.resolver.ts">
import {
  Resolver,
  Query,
  Mutation,
  Args,
  ResolveField,
  Parent,
} from '@nestjs/graphql'
import { GaragesService } from './garages.service'
import { Garage, SlotTypeCount } from './entity/garage.entity'
import { FindManyGarageArgs, FindUniqueGarageArgs } from './dtos/find.args'
import { CreateGarageInput } from './dtos/create-garage.input'
import { UpdateGarageInput } from './dtos/update-garage.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { Slot } from 'src/models/slots/graphql/entity/slot.entity'
import { Address } from 'src/models/addresses/graphql/entity/address.entity'
import { Company } from 'src/models/companies/graphql/entity/company.entity'
import { Verification } from 'src/models/verifications/graphql/entity/verification.entity'
import {
  DateFilterInput,
  GarageFilter,
  MinimalSlotGroupBy,
} from './dtos/search-filter.input'
import {
  AggregateCountOutput,
  LocationFilterInput,
} from 'src/common/dtos/common.input'
import { SlotWhereInput } from 'src/models/slots/graphql/dtos/where.args'
import { BadRequestException } from '@nestjs/common'
import { GarageWhereInput } from './dtos/where.args'

@Resolver(() => Garage)
export class GaragesResolver {
  constructor(
    private readonly garagesService: GaragesService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated('manager')
  @Mutation(() => Garage)
  async createGarage(
    @Args('createGarageInput') args: CreateGarageInput,
    @GetUser() user: GetUserType,
  ) {
    const company = await this.prisma.company.findFirst({
      where: { Managers: { some: { uid: user.uid } } },
    })
    if (!company?.id) {
      throw new BadRequestException(
        'No company associated with the manager id.',
      )
    }

    return this.garagesService.create({ ...args, companyId: company.id })
  }

  @Query(() => [Garage], { name: 'garages' })
  findAll(@Args() args: FindManyGarageArgs) {
    return this.garagesService.findAll(args)
  }

  @Query(() => Garage, { name: 'garage' })
  findOne(@Args() args: FindUniqueGarageArgs) {
    return this.garagesService.findOne(args)
  }

  @Query(() => [Garage], { name: 'searchGarages' })
  async searchGarages(
    @Args('dateFilter') dateFilter: DateFilterInput,
    @Args('locationFilter') locationFilter: LocationFilterInput,
    @Args('slotsFilter', { nullable: true }) slotsFilter: SlotWhereInput,
    @Args('garageFilter', { nullable: true }) args: GarageFilter,
  ) {
    const { start, end } = dateFilter
    const { ne_lat, ne_lng, sw_lat, sw_lng } = locationFilter

    let startDate = new Date(start)
    let endDate = new Date(end)
    const currentDate = new Date()

    const diffInSeconds = Math.floor(
      (endDate.getTime() - startDate.getTime()) / 1000,
    )

    if (startDate.getTime() < currentDate.getTime()) {
      // Set startDate as current time
      startDate = new Date()
      const updatedEndDate = new Date(startDate)
      updatedEndDate.setSeconds(updatedEndDate.getSeconds() + diffInSeconds)
      endDate = updatedEndDate
    }

    if (startDate.getTime() > endDate.getTime()) {
      throw new BadRequestException(
        'Start time should be earlier than the end time.',
      )
    }

    const { where = {}, ...garageFilters } = args || {}

    return this.prisma.garage.findMany({
      ...garageFilters,
      where: {
        ...where,
        Address: {
          lat: { lte: ne_lat, gte: sw_lat },
          lng: { lte: ne_lng, gte: sw_lng },
        },
        Slots: {
          some: {
            ...slotsFilter,
            Bookings: {
              none: {
                OR: [
                  {
                    startTime: { lt: endDate },
                    endTime: { gt: startDate },
                  },
                  {
                    startTime: { gt: startDate },
                    endTime: { lt: endDate },
                  },
                ],
              },
            },
          },
        },
      },
    })
  }

  @ResolveField(() => [SlotTypeCount])
  async slotCounts(@Parent() garage: Garage) {
    const slotCounts = await this.prisma.slot.groupBy({
      by: ['type'],
      where: {
        garageId: garage.id,
      },
      _count: {
        type: true,
      },
    })

    return slotCounts.map(({ type, _count }) => ({
      type,
      count: _count.type,
    }))
  }

  @ResolveField(() => [MinimalSlotGroupBy], {
    name: 'availableSlots',
  })
  async availableSlots(
    @Parent() garage: Garage,
    @Args('slotsFilter', { nullable: true }) slotsFilter: SlotWhereInput,
    @Args('dateFilter') dateFilter: DateFilterInput,
  ) {
    const { start, end } = dateFilter
    const startDate = new Date(start)
    const endDate = new Date(end)

    const groupBySlots = await this.prisma.slot.groupBy({
      by: ['type'],
      _count: { type: true },
      _min: { pricePerHour: true },
      where: {
        ...slotsFilter,
        garageId: { equals: garage.id },
        Bookings: {
          none: {
            OR: [
              {
                startTime: { lt: endDate },
                endTime: { gt: startDate },
              },
              {
                startTime: { gt: startDate },
                endTime: { lt: endDate },
              },
            ],
          },
        },
      },
    })

    return groupBySlots.map(({ _count, type, _min }) => ({
      type,
      count: _count.type,
      pricePerHour: _min.pricePerHour,
    }))
  }

  @AllowAuthenticated()
  @Mutation(() => Garage)
  async updateGarage(
    @Args('updateGarageInput') args: UpdateGarageInput,
    @GetUser() user: GetUserType,
  ) {
    const garage = await this.prisma.garage.findUnique({
      where: { id: args.id },
      include: { Company: { include: { Managers: true } } },
    })
    checkRowLevelPermission(
      user,
      garage.Company.Managers.map((man) => man.uid),
    )
    return this.garagesService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Garage)
  async removeGarage(
    @Args() args: FindUniqueGarageArgs,
    @GetUser() user: GetUserType,
  ) {
    const garage = await this.prisma.garage.findUnique({
      where: { id: args.where.id },
      include: { Company: { include: { Managers: true } } },
    })
    checkRowLevelPermission(
      user,
      garage.Company.Managers.map((man) => man.uid),
    )
    return this.garagesService.remove(args)
  }

  @ResolveField(() => Verification, { nullable: true })
  async verification(@Parent() parent: Garage) {
    return this.prisma.verification.findUnique({
      where: { garageId: parent.id },
    })
  }

  @ResolveField(() => Company)
  company(@Parent() garage: Garage) {
    return this.prisma.company.findFirst({ where: { id: garage.companyId } })
  }

  @ResolveField(() => Address, { nullable: true })
  address(@Parent() garage: Garage) {
    return this.prisma.address.findFirst({ where: { garageId: garage.id } })
  }

  @ResolveField(() => [Slot])
  slots(@Parent() garage: Garage) {
    return this.prisma.slot.findMany({ where: { garageId: garage.id } })
  }

  @Query(() => AggregateCountOutput, {
    name: 'garagesCount',
  })
  async garagesCount(
    @Args('where', { nullable: true })
    where: GarageWhereInput,
  ) {
    const garages = await this.prisma.garage.aggregate({
      _count: { _all: true },
      where,
    })
    return { count: garages._count._all }
  }
}
</file>

<file path="apps/api/src/models/garages/graphql/garages.service.ts">
import { Injectable } from '@nestjs/common'
import { FindManyGarageArgs, FindUniqueGarageArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateGarageInput } from './dtos/create-garage.input'
import { UpdateGarageInput } from './dtos/update-garage.input'
import { CreateSlotInputWithoutGarageId } from 'src/models/slots/graphql/dtos/create-slot.input'
import { Prisma, SlotType } from '@prisma/client'

@Injectable()
export class GaragesService {
  constructor(private readonly prisma: PrismaService) {}
  async create({
    Address,
    companyId,
    description,
    displayName,
    images,
    Slots,
  }: CreateGarageInput & { companyId: number }) {
    // Check if any slot has a count greater than 20
    if (Slots.some((slot) => slot.count > 10)) {
      throw new Error('Slot count cannot be more than 20 for any slot type.')
    }
    return this.prisma.$transaction(async (tx) => {
      const createdGarage = await tx.garage.create({
        data: {
          Address: { create: Address },
          companyId,
          description,
          displayName,
          images,
        },
      })
      const slotsByType = this.groupSlotsByType(Slots, createdGarage.id)

      const createSlots = await tx.slot.createMany({
        data: slotsByType,
      })

      return createdGarage
    })
  }

  findAll(args: FindManyGarageArgs) {
    return this.prisma.garage.findMany(args)
  }

  findOne(args: FindUniqueGarageArgs) {
    return this.prisma.garage.findUnique(args)
  }

  update(updateGarageInput: UpdateGarageInput) {
    const { id, Address, Slots, ...data } = updateGarageInput
    return this.prisma.garage.update({
      where: { id },
      data: data,
    })
  }

  remove(args: FindUniqueGarageArgs) {
    return this.prisma.garage.delete(args)
  }

  groupSlotsByType(
    slots: CreateSlotInputWithoutGarageId[],
    garageId: number,
  ): Prisma.SlotCreateManyInput[] {
    const slotsByType = []
    const slotCounts = {
      CAR: 0,
      HEAVY: 0,
      BIKE: 0,
      BICYCLE: 0,
    }

    slots.forEach(({ count, ...slot }) => {
      for (let i = 0; i < count; i++) {
        slotsByType.push({
          ...slot,
          displayName: `${slot.type} ${slotCounts[slot.type]}`,
          garageId,
        })
        slotCounts[slot.type]++
      }
    })

    return slotsByType
  }
}
</file>

<file path="apps/api/src/models/garages/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { GarageEntity } from '../entity/garage.entity'

export class CreateGarage extends OmitType(GarageEntity, [
  'createdAt',
  'updatedAt',
  'id',
]) {}
</file>

<file path="apps/api/src/models/garages/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class GarageQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.GarageScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.GarageScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/garages/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateGarage } from './create.dto'
import { Garage } from '@prisma/client'

export class UpdateGarage extends PartialType(CreateGarage) {
  id: Garage['id']
}
</file>

<file path="apps/api/src/models/garages/rest/entity/garage.entity.ts">
import { Garage } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class GarageEntity implements RestrictProperties<GarageEntity, Garage> {
  id: number
  createdAt: Date
  updatedAt: Date
  @IsOptional()
  displayName: string
  @IsOptional()
  description: string
  images: string[]
  companyId: number
}
</file>

<file path="apps/api/src/models/garages/rest/garages.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateGarage } from './dtos/create.dto'
import { GarageQueryDto } from './dtos/query.dto'
import { UpdateGarage } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { GarageEntity } from './entity/garage.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('garages')
@Controller('garages')
export class GaragesController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: GarageEntity })
  @Post()
  async create(
    @Body() createGarageDto: CreateGarage,
    @GetUser() user: GetUserType,
  ) {
    const company = await this.prisma.company.findUnique({
      where: { id: createGarageDto.companyId },
      include: { Managers: true },
    })
    checkRowLevelPermission(
      user,
      company.Managers.map((manager) => manager.uid),
    )
    return this.prisma.garage.create({ data: createGarageDto })
  }

  @ApiOkResponse({ type: [GarageEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: GarageQueryDto) {
    return this.prisma.garage.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: GarageEntity })
  @Get(':id')
  findOne(@Param('id') id: number) {
    return this.prisma.garage.findUnique({ where: { id } })
  }

  @ApiOkResponse({ type: GarageEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':id')
  async update(
    @Param('id') id: number,
    @Body() updateGarageDto: UpdateGarage,
    @GetUser() user: GetUserType,
  ) {
    const garage = await this.prisma.garage.findUnique({
      where: { id },
      include: { Company: { include: { Managers: true } } },
    })
    checkRowLevelPermission(
      user,
      garage.Company.Managers.map((manager) => manager.uid),
    )
    return this.prisma.garage.update({
      where: { id },
      data: updateGarageDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':id')
  async remove(@Param('id') id: number, @GetUser() user: GetUserType) {
    const garage = await this.prisma.garage.findUnique({
      where: { id },
      include: { Company: { include: { Managers: true } } },
    })
    checkRowLevelPermission(
      user,
      garage.Company.Managers.map((manager) => manager.uid),
    )
    return this.prisma.garage.delete({ where: { id } })
  }
}
</file>

<file path="apps/api/src/models/garages/garages.module.ts">
import { Module } from '@nestjs/common'
import { GaragesService } from './graphql/garages.service'
import { GaragesResolver } from './graphql/garages.resolver'
import { GaragesController } from './rest/garages.controller'

@Module({
  providers: [GaragesResolver, GaragesService],
  exports: [GaragesService],
  controllers: [GaragesController],
})
export class GaragesModule {}
</file>

<file path="apps/api/src/models/managers/graphql/dtos/create-manager.input.ts">
import { InputType, PickType } from '@nestjs/graphql'
import { Manager } from '../entity/manager.entity'

@InputType()
export class CreateManagerInput extends PickType(
  Manager,
  ['uid', 'displayName'],
  InputType,
) {}
</file>

<file path="apps/api/src/models/managers/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { ManagerOrderByWithRelationInput } from './order-by.args'
import { ManagerWhereInput, ManagerWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.ManagerScalarFieldEnum, {
  name: 'ManagerScalarFieldEnum',
})

@ArgsType()
class FindManyManagerArgsStrict
  implements
    RestrictProperties<
      FindManyManagerArgsStrict,
      Omit<Prisma.ManagerFindManyArgs, 'include' | 'select'>
    >
{
  where: ManagerWhereInput
  orderBy: ManagerOrderByWithRelationInput[]
  cursor: ManagerWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.ManagerScalarFieldEnum])
  distinct: Prisma.ManagerScalarFieldEnum[]
}

@ArgsType()
export class FindManyManagerArgs extends PartialType(
  FindManyManagerArgsStrict,
) {}

@ArgsType()
export class FindUniqueManagerArgs {
  where: ManagerWhereUniqueInput
}
</file>

<file path="apps/api/src/models/managers/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { BookingTimelineOrderByRelationAggregateInput } from 'src/models/booking-timelines/graphql/dtos/order-by.args'
import { CompanyOrderByWithRelationInput } from 'src/models/companies/graphql/dtos/order-by.args'
import { UserOrderByWithRelationInput } from 'src/models/users/graphql/dtos/order-by.args'

@InputType()
export class ManagerOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      ManagerOrderByWithRelationInputStrict,
      Prisma.ManagerOrderByWithRelationInput
    >
{
  User: UserOrderByWithRelationInput
  @Field(() => Prisma.SortOrder)
  uid: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  displayName: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  companyId: Prisma.SortOrder

  Company: CompanyOrderByWithRelationInput
  BookingTimeline: BookingTimelineOrderByRelationAggregateInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class ManagerOrderByWithRelationInput extends PartialType(
  ManagerOrderByWithRelationInputStrict,
) {}

@InputType()
export class ManagerOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/managers/graphql/dtos/update-manager.input.ts">
import { CreateManagerInput } from './create-manager.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Manager } from '@prisma/client'

@InputType()
export class UpdateManagerInput extends PartialType(CreateManagerInput) {
  uid: Manager['uid']
}
</file>

<file path="apps/api/src/models/managers/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { BookingTimelineListRelationFilter } from 'src/models/booking-timelines/graphql/dtos/where.args'
import { CompanyRelationFilter } from 'src/models/companies/graphql/dtos/where.args'
import { UserRelationFilter } from 'src/models/users/graphql/dtos/where.args'

@InputType()
export class ManagerWhereUniqueInput {
  uid: string
}

@InputType()
export class ManagerWhereInputStrict
  implements
    RestrictProperties<ManagerWhereInputStrict, Prisma.ManagerWhereInput>
{
  User: UserRelationFilter
  uid: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  companyId: IntFilter
  Company: CompanyRelationFilter
  BookingTimeline: BookingTimelineListRelationFilter
  // Todo: Add the below field decorator only to the $Enums types.
  // @Field(() => $Enums.x)

  AND: ManagerWhereInput[]
  OR: ManagerWhereInput[]
  NOT: ManagerWhereInput[]
}

@InputType()
export class ManagerWhereInput extends PartialType(ManagerWhereInputStrict) {}

@InputType()
export class ManagerListRelationFilter {
  every?: ManagerWhereInput
  some?: ManagerWhereInput
  none?: ManagerWhereInput
}

@InputType()
export class ManagerRelationFilter {
  is?: ManagerWhereInput
  isNot?: ManagerWhereInput
}
</file>

<file path="apps/api/src/models/managers/graphql/entity/manager.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { Manager as ManagerType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class Manager implements RestrictProperties<Manager, ManagerType> {
  uid: string
  createdAt: Date
  updatedAt: Date
  @Field({ nullable: true })
  displayName: string
  companyId: number
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/managers/graphql/managers.resolver.ts">
import {
  Resolver,
  Query,
  Mutation,
  Args,
  ResolveField,
  Parent,
} from '@nestjs/graphql'
import { ManagersService } from './managers.service'
import { Manager } from './entity/manager.entity'
import { FindManyManagerArgs, FindUniqueManagerArgs } from './dtos/find.args'
import { CreateManagerInput } from './dtos/create-manager.input'
import { UpdateManagerInput } from './dtos/update-manager.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { Company } from 'src/models/companies/graphql/entity/company.entity'

@Resolver(() => Manager)
export class ManagersResolver {
  constructor(
    private readonly managersService: ManagersService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated()
  @Mutation(() => Manager)
  createManager(
    @Args('createManagerInput') args: CreateManagerInput,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, args.uid)
    return this.managersService.create(args)
  }

  @Query(() => [Manager], { name: 'managers' })
  findAll(@Args() args: FindManyManagerArgs) {
    return this.managersService.findAll(args)
  }

  @Query(() => Manager, { name: 'manager' })
  findOne(@Args() args: FindUniqueManagerArgs) {
    return this.managersService.findOne(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Manager)
  async updateManager(
    @Args('updateManagerInput') args: UpdateManagerInput,
    @GetUser() user: GetUserType,
  ) {
    const manager = await this.prisma.manager.findUnique({
      where: { uid: args.uid },
    })
    checkRowLevelPermission(user, manager.uid)
    return this.managersService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Manager)
  async removeManager(
    @Args() args: FindUniqueManagerArgs,
    @GetUser() user: GetUserType,
  ) {
    const manager = await this.prisma.manager.findUnique(args)
    checkRowLevelPermission(user, manager.uid)
    return this.managersService.remove(args)
  }

  @ResolveField(() => Company, { nullable: true })
  company(@Parent() manager: Manager) {
    return this.prisma.company.findUnique({ where: { id: manager.companyId } })
  }
}
</file>

<file path="apps/api/src/models/managers/graphql/managers.service.ts">
import { Injectable } from '@nestjs/common'
import { FindManyManagerArgs, FindUniqueManagerArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateManagerInput } from './dtos/create-manager.input'
import { UpdateManagerInput } from './dtos/update-manager.input'

@Injectable()
export class ManagersService {
  constructor(private readonly prisma: PrismaService) {}
  create(createManagerInput: CreateManagerInput) {
    return this.prisma.manager.create({
      data: createManagerInput,
    })
  }

  findAll(args: FindManyManagerArgs) {
    return this.prisma.manager.findMany(args)
  }

  findOne(args: FindUniqueManagerArgs) {
    return this.prisma.manager.findUnique(args)
  }

  update(updateManagerInput: UpdateManagerInput) {
    const { uid, ...data } = updateManagerInput
    return this.prisma.manager.update({
      where: { uid },
      data: data,
    })
  }

  remove(args: FindUniqueManagerArgs) {
    return this.prisma.manager.delete(args)
  }
}
</file>

<file path="apps/api/src/models/managers/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { ManagerEntity } from '../entity/manager.entity'

export class CreateManager extends OmitType(ManagerEntity, [
  'createdAt',
  'updatedAt',
]) {}
</file>

<file path="apps/api/src/models/managers/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class ManagerQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.ManagerScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.ManagerScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/managers/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateManager } from './create.dto'
import { Manager } from '@prisma/client'

export class UpdateManager extends PartialType(CreateManager) {
  uid: Manager['uid']
}
</file>

<file path="apps/api/src/models/managers/rest/entity/manager.entity.ts">
import { Manager } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class ManagerEntity
  implements RestrictProperties<ManagerEntity, Manager>
{
  uid: string
  createdAt: Date
  updatedAt: Date
  @IsOptional()
  displayName: string
  @IsOptional()
  companyId: number
}
</file>

<file path="apps/api/src/models/managers/rest/managers.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateManager } from './dtos/create.dto'
import { ManagerQueryDto } from './dtos/query.dto'
import { UpdateManager } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { ManagerEntity } from './entity/manager.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('managers')
@Controller('managers')
export class ManagersController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: ManagerEntity })
  @Post()
  create(
    @Body() createManagerDto: CreateManager,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, createManagerDto.uid)
    return this.prisma.manager.create({ data: createManagerDto })
  }

  @ApiOkResponse({ type: [ManagerEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: ManagerQueryDto) {
    return this.prisma.manager.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: ManagerEntity })
  @Get(':uid')
  findOne(@Param('uid') uid: string) {
    return this.prisma.manager.findUnique({ where: { uid } })
  }

  @ApiOkResponse({ type: ManagerEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':uid')
  async update(
    @Param('uid') uid: string,
    @Body() updateManagerDto: UpdateManager,
    @GetUser() user: GetUserType,
  ) {
    const manager = await this.prisma.manager.findUnique({ where: { uid } })
    checkRowLevelPermission(user, manager.uid)
    return this.prisma.manager.update({
      where: { uid },
      data: updateManagerDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':uid')
  async remove(@Param('uid') uid: string, @GetUser() user: GetUserType) {
    const manager = await this.prisma.manager.findUnique({ where: { uid } })
    checkRowLevelPermission(user, manager.uid)
    return this.prisma.manager.delete({ where: { uid } })
  }
}
</file>

<file path="apps/api/src/models/managers/managers.module.ts">
import { Module } from '@nestjs/common'
import { ManagersService } from './graphql/managers.service'
import { ManagersResolver } from './graphql/managers.resolver'
import { ManagersController } from './rest/managers.controller'

@Module({
  providers: [ManagersResolver, ManagersService],
  exports: [ManagersService],
  controllers: [ManagersController],
})
export class ManagersModule {}
</file>

<file path="apps/api/src/models/reviews/graphql/dtos/create-review.input.ts">
import { InputType, OmitType, PickType } from '@nestjs/graphql'
import { Review } from '../entity/review.entity'

@InputType()
export class CreateReviewInput extends OmitType(
  Review,
  ['createdAt', 'updatedAt', 'id'],
  InputType,
) {}
</file>

<file path="apps/api/src/models/reviews/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { ReviewOrderByWithRelationInput } from './order-by.args'
import { ReviewWhereInput, ReviewWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.ReviewScalarFieldEnum, {
  name: 'ReviewScalarFieldEnum',
})

@ArgsType()
class FindManyReviewArgsStrict
  implements
    RestrictProperties<
      FindManyReviewArgsStrict,
      Omit<Prisma.ReviewFindManyArgs, 'include' | 'select'>
    >
{
  where: ReviewWhereInput
  orderBy: ReviewOrderByWithRelationInput[]
  cursor: ReviewWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.ReviewScalarFieldEnum])
  distinct: Prisma.ReviewScalarFieldEnum[]
}

@ArgsType()
export class FindManyReviewArgs extends PartialType(FindManyReviewArgsStrict) {}

@ArgsType()
export class FindUniqueReviewArgs {
  where: ReviewWhereUniqueInput
}
</file>

<file path="apps/api/src/models/reviews/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { CustomerOrderByWithRelationInput } from 'src/models/customers/graphql/dtos/order-by.args'
import { GarageOrderByWithRelationInput } from 'src/models/garages/graphql/dtos/order-by.args'

@InputType()
export class ReviewOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      ReviewOrderByWithRelationInputStrict,
      Prisma.ReviewOrderByWithRelationInput
    >
{
  @Field(() => Prisma.SortOrder)
  id: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  rating: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  comment: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  customerId: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  garageId: Prisma.SortOrder
  Customer: CustomerOrderByWithRelationInput
  Garage: GarageOrderByWithRelationInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class ReviewOrderByWithRelationInput extends PartialType(
  ReviewOrderByWithRelationInputStrict,
) {}

@InputType()
export class ReviewOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/reviews/graphql/dtos/update-review.input.ts">
import { CreateReviewInput } from './create-review.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Review } from '@prisma/client'

@InputType()
export class UpdateReviewInput extends PartialType(CreateReviewInput) {
  id: Review['id']
}
</file>

<file path="apps/api/src/models/reviews/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { CustomerRelationFilter } from 'src/models/customers/graphql/dtos/where.args'
import { GarageRelationFilter } from 'src/models/garages/graphql/dtos/where.args'

@InputType()
export class ReviewWhereUniqueInput {
  id: number
}

@InputType()
export class ReviewWhereInputStrict
  implements
    RestrictProperties<ReviewWhereInputStrict, Prisma.ReviewWhereInput>
{
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  rating: IntFilter
  comment: StringFilter
  customerId: StringFilter
  garageId: IntFilter
  Customer: CustomerRelationFilter
  Garage: GarageRelationFilter

  AND: ReviewWhereInput[]
  OR: ReviewWhereInput[]
  NOT: ReviewWhereInput[]
}

@InputType()
export class ReviewWhereInput extends PartialType(ReviewWhereInputStrict) {}

@InputType()
export class ReviewListRelationFilter {
  every?: ReviewWhereInput
  some?: ReviewWhereInput
  none?: ReviewWhereInput
}

@InputType()
export class ReviewRelationFilter {
  is?: ReviewWhereInput
  isNot?: ReviewWhereInput
}
</file>

<file path="apps/api/src/models/reviews/graphql/entity/review.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { Review as ReviewType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class Review implements RestrictProperties<Review, ReviewType> {
  id: number
  createdAt: Date
  updatedAt: Date
  rating: number
  @Field({ nullable: true })
  comment: string
  customerId: string
  garageId: number
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/reviews/graphql/reviews.resolver.ts">
import { Resolver, Query, Mutation, Args } from '@nestjs/graphql'
import { ReviewsService } from './reviews.service'
import { Review } from './entity/review.entity'
import { FindManyReviewArgs, FindUniqueReviewArgs } from './dtos/find.args'
import { CreateReviewInput } from './dtos/create-review.input'
import { UpdateReviewInput } from './dtos/update-review.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'

@Resolver(() => Review)
export class ReviewsResolver {
  constructor(
    private readonly reviewsService: ReviewsService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated()
  @Mutation(() => Review)
  createReview(
    @Args('createReviewInput') args: CreateReviewInput,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, args.customerId)
    return this.reviewsService.create(args)
  }

  @Query(() => [Review], { name: 'reviews' })
  findAll(@Args() args: FindManyReviewArgs) {
    return this.reviewsService.findAll(args)
  }

  @Query(() => Review, { name: 'review' })
  findOne(@Args() args: FindUniqueReviewArgs) {
    return this.reviewsService.findOne(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Review)
  async updateReview(
    @Args('updateReviewInput') args: UpdateReviewInput,
    @GetUser() user: GetUserType,
  ) {
    const review = await this.prisma.review.findUnique({
      where: { id: args.id },
    })
    checkRowLevelPermission(user, review.customerId)
    return this.reviewsService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Review)
  async removeReview(
    @Args() args: FindUniqueReviewArgs,
    @GetUser() user: GetUserType,
  ) {
    const review = await this.prisma.review.findUnique(args)
    checkRowLevelPermission(user, review.customerId)
    return this.reviewsService.remove(args)
  }
}
</file>

<file path="apps/api/src/models/reviews/graphql/reviews.service.ts">
import { Injectable } from '@nestjs/common'
import { FindManyReviewArgs, FindUniqueReviewArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateReviewInput } from './dtos/create-review.input'
import { UpdateReviewInput } from './dtos/update-review.input'

@Injectable()
export class ReviewsService {
  constructor(private readonly prisma: PrismaService) {}
  create(createReviewInput: CreateReviewInput) {
    return this.prisma.review.create({
      data: createReviewInput,
    })
  }

  findAll(args: FindManyReviewArgs) {
    return this.prisma.review.findMany(args)
  }

  findOne(args: FindUniqueReviewArgs) {
    return this.prisma.review.findUnique(args)
  }

  update(updateReviewInput: UpdateReviewInput) {
    const { id, ...data } = updateReviewInput
    return this.prisma.review.update({
      where: { id },
      data: data,
    })
  }

  remove(args: FindUniqueReviewArgs) {
    return this.prisma.review.delete(args)
  }
}
</file>

<file path="apps/api/src/models/reviews/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { ReviewEntity } from '../entity/review.entity'

export class CreateReview extends OmitType(ReviewEntity, [
  'createdAt',
  'updatedAt',
  'id',
]) {}
</file>

<file path="apps/api/src/models/reviews/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class ReviewQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.ReviewScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.ReviewScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/reviews/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateReview } from './create.dto'
import { Review } from '@prisma/client'

export class UpdateReview extends PartialType(CreateReview) {
  id: Review['id']
}
</file>

<file path="apps/api/src/models/reviews/rest/entity/review.entity.ts">
import { Review } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class ReviewEntity implements RestrictProperties<ReviewEntity, Review> {
  id: number
  createdAt: Date
  updatedAt: Date
  rating: number
  @IsOptional()
  comment: string
  customerId: string
  garageId: number
}
</file>

<file path="apps/api/src/models/reviews/rest/reviews.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateReview } from './dtos/create.dto'
import { ReviewQueryDto } from './dtos/query.dto'
import { UpdateReview } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { ReviewEntity } from './entity/review.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('reviews')
@Controller('reviews')
export class ReviewsController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: ReviewEntity })
  @Post()
  create(@Body() createReviewDto: CreateReview, @GetUser() user: GetUserType) {
    checkRowLevelPermission(user, createReviewDto.customerId)
    return this.prisma.review.create({ data: createReviewDto })
  }

  @ApiOkResponse({ type: [ReviewEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: ReviewQueryDto) {
    return this.prisma.review.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: ReviewEntity })
  @Get(':id')
  findOne(@Param('id') id: number) {
    return this.prisma.review.findUnique({ where: { id } })
  }

  @ApiOkResponse({ type: ReviewEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':id')
  async update(
    @Param('id') id: number,
    @Body() updateReviewDto: UpdateReview,
    @GetUser() user: GetUserType,
  ) {
    const review = await this.prisma.review.findUnique({ where: { id } })
    checkRowLevelPermission(user, review.customerId)
    return this.prisma.review.update({
      where: { id },
      data: updateReviewDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':id')
  async remove(@Param('id') id: number, @GetUser() user: GetUserType) {
    const review = await this.prisma.review.findUnique({ where: { id } })
    checkRowLevelPermission(user, review.customerId)
    return this.prisma.review.delete({ where: { id } })
  }
}
</file>

<file path="apps/api/src/models/reviews/reviews.module.ts">
import { Module } from '@nestjs/common'
import { ReviewsService } from './graphql/reviews.service'
import { ReviewsResolver } from './graphql/reviews.resolver'
import { ReviewsController } from './rest/reviews.controller'

@Module({
  providers: [ReviewsResolver, ReviewsService],
  exports: [ReviewsService],
  controllers: [ReviewsController],
})
export class ReviewsModule {}
</file>

<file path="apps/api/src/models/slots/graphql/dtos/create-slot.input.ts">
import { InputType, OmitType, PickType } from '@nestjs/graphql'
import { Slot } from '../entity/slot.entity'

@InputType()
export class CreateSlotInput extends OmitType(
  Slot,
  ['createdAt', 'updatedAt', 'id'],
  InputType,
) {}

@InputType()
export class CreateSlotInputWithoutGarageId extends OmitType(
  CreateSlotInput,
  ['garageId'],
  InputType,
) {
  count: number
}
</file>

<file path="apps/api/src/models/slots/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { SlotOrderByWithRelationInput } from './order-by.args'
import { SlotWhereInput, SlotWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.SlotScalarFieldEnum, {
  name: 'SlotScalarFieldEnum',
})

@ArgsType()
class FindManySlotArgsStrict
  implements
    RestrictProperties<
      FindManySlotArgsStrict,
      Omit<Prisma.SlotFindManyArgs, 'include' | 'select'>
    >
{
  where: SlotWhereInput
  orderBy: SlotOrderByWithRelationInput[]
  cursor: SlotWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.SlotScalarFieldEnum])
  distinct: Prisma.SlotScalarFieldEnum[]
}

@ArgsType()
export class FindManySlotArgs extends PartialType(FindManySlotArgsStrict) {}

@ArgsType()
export class FindUniqueSlotArgs {
  where: SlotWhereUniqueInput
}
</file>

<file path="apps/api/src/models/slots/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { BookingOrderByRelationAggregateInput } from 'src/models/bookings/graphql/dtos/order-by.args'
import { GarageOrderByWithRelationInput } from 'src/models/garages/graphql/dtos/order-by.args'

@InputType()
export class SlotOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      SlotOrderByWithRelationInputStrict,
      Prisma.SlotOrderByWithRelationInput
    >
{
  @Field(() => Prisma.SortOrder)
  id: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  displayName: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  pricePerHour: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  length: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  width: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  height: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  type: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  garageId: Prisma.SortOrder
  Garage: GarageOrderByWithRelationInput
  Bookings: BookingOrderByRelationAggregateInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class SlotOrderByWithRelationInput extends PartialType(
  SlotOrderByWithRelationInputStrict,
) {}

@InputType()
export class SlotOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/slots/graphql/dtos/update-slot.input.ts">
import { CreateSlotInput } from './create-slot.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Slot } from '@prisma/client'

@InputType()
export class UpdateSlotInput extends PartialType(CreateSlotInput) {
  id: Slot['id']
}
</file>

<file path="apps/api/src/models/slots/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { $Enums, Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  FloatFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { BookingListRelationFilter } from 'src/models/bookings/graphql/dtos/where.args'
import { GarageRelationFilter } from 'src/models/garages/graphql/dtos/where.args'

@InputType()
export class SlotWhereUniqueInput {
  id: number
}

@InputType()
export class EnumSlotTypeFilter {
  @Field(() => $Enums.SlotType, { nullable: true })
  equals?: $Enums.SlotType;
  @Field(() => [$Enums.SlotType], { nullable: true })
  in?: $Enums.SlotType[]
  @Field(() => [$Enums.SlotType], { nullable: true })
  notIn?: $Enums.SlotType[]
  @Field(() => $Enums.SlotType, { nullable: true })
  not?: $Enums.SlotType
}

@InputType()
export class SlotWhereInputStrict
  implements RestrictProperties<SlotWhereInputStrict, Prisma.SlotWhereInput>
{
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  pricePerHour: FloatFilter
  length: IntFilter
  width: IntFilter
  height: IntFilter

  type: EnumSlotTypeFilter
  garageId: IntFilter
  Garage: GarageRelationFilter
  Bookings: BookingListRelationFilter
  // Todo: Add the below field decorator only to the $Enums types.
  // @Field(() => $Enums.x)

  AND: SlotWhereInput[]
  OR: SlotWhereInput[]
  NOT: SlotWhereInput[]
}

@InputType()
export class SlotWhereInput extends PartialType(SlotWhereInputStrict) {}

@InputType()
export class SlotListRelationFilter {
  every?: SlotWhereInput
  some?: SlotWhereInput
  none?: SlotWhereInput
}

@InputType()
export class SlotRelationFilter {
  is?: SlotWhereInput
  isNot?: SlotWhereInput
}
</file>

<file path="apps/api/src/models/slots/graphql/entity/slot.entity.ts">
import { Field, ObjectType, registerEnumType } from '@nestjs/graphql'
import { $Enums, Slot as SlotType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType($Enums.SlotType, {
  name: 'SlotType',
})

@ObjectType()
export class Slot implements RestrictProperties<Slot, SlotType> {
  id: number
  createdAt: Date
  updatedAt: Date

  @Field({ nullable: true })
  displayName: string
  pricePerHour: number
  @Field({ nullable: true })
  length: number
  @Field({ nullable: true })
  width: number
  @Field({ nullable: true })
  height: number
  @Field(() => $Enums.SlotType)
  type: $Enums.SlotType
  garageId: number
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}

@ObjectType()
export class ReturnCount {
  count: number
}
</file>

<file path="apps/api/src/models/slots/graphql/slots.resolver.ts">
import {
  Resolver,
  Query,
  Mutation,
  Args,
  ResolveField,
  Parent,
} from '@nestjs/graphql'
import { SlotsService } from './slots.service'
import { ReturnCount, Slot } from './entity/slot.entity'
import { FindManySlotArgs, FindUniqueSlotArgs } from './dtos/find.args'
import { CreateSlotInput } from './dtos/create-slot.input'
import { UpdateSlotInput } from './dtos/update-slot.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { Garage } from 'src/models/garages/graphql/entity/garage.entity'
import { Booking } from 'src/models/bookings/graphql/entity/booking.entity'

@Resolver(() => Slot)
export class SlotsResolver {
  constructor(
    private readonly slotsService: SlotsService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated()
  @Mutation(() => Slot)
  async createSlot(
    @Args('createSlotInput') args: CreateSlotInput,
    @GetUser() user: GetUserType,
  ) {
    const garage = await this.prisma.garage.findUnique({
      where: { id: args.garageId },
      include: { Company: { include: { Managers: true } } },
    })
    checkRowLevelPermission(
      user,
      garage.Company.Managers.map((manager) => manager.uid),
    )
    return this.slotsService.create(args)
  }

  @AllowAuthenticated('manager')
  @Mutation(() => ReturnCount)
  async createManySlots(
    @Args('createSlotInput') args: CreateSlotInput,
    @Args('count', {
      type: () => Number,
    })
    count: number,
    @GetUser() user: GetUserType,
  ) {
    const garage = await this.prisma.garage.findUnique({
      where: { id: args.garageId },
      include: {
        Company: {
          include: { Managers: true },
        },
      },
    })

    checkRowLevelPermission(
      user,
      garage.Company.Managers.map((manager) => manager.uid),
    )

    const typeCount = await this.prisma.slot.count({
      where: { garageId: args.garageId, type: args.type },
    })

    const slots = Array.from({ length: count }).map((num, index) => ({
      ...args,
      displayName: `${args.type} ${typeCount + index + 1}`,
    }))

    return this.prisma.slot.createMany({ data: slots })
  }

  @Query(() => [Slot], { name: 'slots' })
  findAll(@Args() args: FindManySlotArgs) {
    return this.slotsService.findAll(args)
  }

  @Query(() => Slot, { name: 'slot' })
  findOne(@Args() args: FindUniqueSlotArgs) {
    return this.slotsService.findOne(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Slot)
  async updateSlot(
    @Args('updateSlotInput') args: UpdateSlotInput,
    @GetUser() user: GetUserType,
  ) {
    const slot = await this.prisma.slot.findUnique({
      where: { id: args.id },
      include: {
        Garage: {
          include: {
            Company: {
              include: { Managers: true },
            },
          },
        },
      },
    })
    checkRowLevelPermission(
      user,
      slot.Garage.Company.Managers.map((man) => man.uid),
    )
    return this.slotsService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Slot)
  async removeSlot(
    @Args() args: FindUniqueSlotArgs,
    @GetUser() user: GetUserType,
  ) {
    const slot = await this.prisma.slot.findUnique({
      where: { id: args.where.id },
      include: {
        Garage: {
          include: {
            Company: {
              include: { Managers: true },
            },
          },
        },
      },
    })
    checkRowLevelPermission(
      user,
      slot.Garage.Company.Managers.map((man) => man.uid),
    )
    return this.slotsService.remove(args)
  }

  @ResolveField(() => Garage)
  garage(@Parent() slot: Slot) {
    return this.prisma.garage.findUnique({ where: { id: slot.garageId } })
  }

  @ResolveField(() => [Booking])
  bookings(@Parent() slot: Slot) {
    return this.prisma.booking.findMany({ where: { slotId: slot.id } })
  }
}
</file>

<file path="apps/api/src/models/slots/graphql/slots.service.ts">
import { Injectable } from '@nestjs/common'
import { FindManySlotArgs, FindUniqueSlotArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateSlotInput } from './dtos/create-slot.input'
import { UpdateSlotInput } from './dtos/update-slot.input'

@Injectable()
export class SlotsService {
  constructor(private readonly prisma: PrismaService) {}
  create(createSlotInput: CreateSlotInput) {
    return this.prisma.slot.create({
      data: createSlotInput,
    })
  }

  findAll(args: FindManySlotArgs) {
    return this.prisma.slot.findMany(args)
  }

  findOne(args: FindUniqueSlotArgs) {
    return this.prisma.slot.findUnique(args)
  }

  update(updateSlotInput: UpdateSlotInput) {
    const { id, ...data } = updateSlotInput
    return this.prisma.slot.update({
      where: { id },
      data: data,
    })
  }

  remove(args: FindUniqueSlotArgs) {
    return this.prisma.slot.delete(args)
  }
}
</file>

<file path="apps/api/src/models/slots/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { SlotEntity } from '../entity/slot.entity'

export class CreateSlot extends OmitType(SlotEntity, [
  'createdAt',
  'updatedAt',
  'id',
]) {}
</file>

<file path="apps/api/src/models/slots/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class SlotQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.SlotScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.SlotScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/slots/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateSlot } from './create.dto'
import { Slot } from '@prisma/client'

export class UpdateSlot extends PartialType(CreateSlot) {
  id: Slot['id']
}
</file>

<file path="apps/api/src/models/slots/rest/entity/slot.entity.ts">
import { Field } from '@nestjs/graphql'
import { $Enums, Slot } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class SlotEntity implements RestrictProperties<SlotEntity, Slot> {
  id: number
  createdAt: Date
  updatedAt: Date
  @IsOptional()
  displayName: string
  pricePerHour: number
  @IsOptional()
  length: number
  @IsOptional()
  width: number
  @IsOptional()
  height: number

  type: $Enums.SlotType
  garageId: number
}
</file>

<file path="apps/api/src/models/slots/rest/slots.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateSlot } from './dtos/create.dto'
import { SlotQueryDto } from './dtos/query.dto'
import { UpdateSlot } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { SlotEntity } from './entity/slot.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('slots')
@Controller('slots')
export class SlotsController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: SlotEntity })
  @Post()
  async create(
    @Body() createSlotDto: CreateSlot,
    @GetUser() user: GetUserType,
  ) {
    const garage = await this.prisma.garage.findUnique({
      where: { id: createSlotDto.garageId },
      include: { Company: { include: { Managers: true } } },
    })
    checkRowLevelPermission(
      user,
      garage.Company.Managers.map((manager) => manager.uid),
    )
    return this.prisma.slot.create({ data: createSlotDto })
  }

  @ApiOkResponse({ type: [SlotEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: SlotQueryDto) {
    return this.prisma.slot.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: SlotEntity })
  @Get(':id')
  findOne(@Param('id') id: number) {
    return this.prisma.slot.findUnique({ where: { id } })
  }

  @ApiOkResponse({ type: SlotEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':id')
  async update(
    @Param('id') id: number,
    @Body() updateSlotDto: UpdateSlot,
    @GetUser() user: GetUserType,
  ) {
    const slot = await this.prisma.slot.findUnique({
      where: { id },
      include: {
        Garage: {
          include: {
            Company: {
              include: { Managers: true },
            },
          },
        },
      },
    })
    checkRowLevelPermission(
      user,
      slot.Garage.Company.Managers.map((man) => man.uid),
    )
    return this.prisma.slot.update({
      where: { id },
      data: updateSlotDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':id')
  async remove(@Param('id') id: number, @GetUser() user: GetUserType) {
    const slot = await this.prisma.slot.findUnique({
      where: { id },
      include: {
        Garage: {
          include: {
            Company: {
              include: { Managers: true },
            },
          },
        },
      },
    })
    checkRowLevelPermission(
      user,
      slot.Garage.Company.Managers.map((man) => man.uid),
    )
    return this.prisma.slot.delete({ where: { id } })
  }
}
</file>

<file path="apps/api/src/models/slots/slots.module.ts">
import { Module } from '@nestjs/common'
import { SlotsService } from './graphql/slots.service'
import { SlotsResolver } from './graphql/slots.resolver'
import { SlotsController } from './rest/slots.controller'

@Module({
  providers: [SlotsResolver, SlotsService],
  exports: [SlotsService],
  controllers: [SlotsController],
})
export class SlotsModule {}
</file>

<file path="apps/api/src/models/stripe/dto/create-stripe-session.dto.ts">
import { TotalPrice } from '@autospace/util/types'
import { CreateBookingInput } from 'src/models/bookings/graphql/dtos/create-booking.input'

export class CreateStripeDto {
  uid: string
  totalPriceObj: TotalPrice
  bookingData: CreateBookingInput
}
</file>

<file path="apps/api/src/models/stripe/stripe.controller.ts">
import {
  BadRequestException,
  Body,
  Controller,
  Get,
  Post,
  Query,
  Res,
} from '@nestjs/common'
import StripeService from './stripe.service'
import { BookingsService } from '../bookings/graphql/bookings.service'
import { CreateStripeDto } from './dto/create-stripe-session.dto'
import { CreateBookingInput } from '../bookings/graphql/dtos/create-booking.input'
import { Response } from 'express'

@Controller('stripe')
export class StripeController {
  constructor(
    private readonly stripeService: StripeService,
    private readonly bookingService: BookingsService,
  ) {}

  @Get()
  helloStripe() {
    return 'Hello Stripe'
  }

  @Post()
  create(@Body() createStripeDto: CreateStripeDto) {
    return this.stripeService.createStripeSession(createStripeDto)
  }

  @Get('success')
  async handleStripeSuccess(
    @Query('session_id') sessionId: string,
    @Res() res: Response,
  ) {
    if (!sessionId) {
      throw new BadRequestException('Session id missing.')
    }

    const session = await this.stripeService.stripe.checkout.sessions.retrieve(
      sessionId,
    )

    const { uid, bookingData } = session.metadata

    const bookingInput: CreateBookingInput = JSON.parse(bookingData)
    const newBooking = await this.bookingService.create(bookingInput)
    res.redirect(process.env.BOOKINGS_REDIRECT_URL)
  }
}
</file>

<file path="apps/api/src/models/stripe/stripe.module.ts">
import { Module } from '@nestjs/common'

import { StripeController } from './stripe.controller'
import StripeService from './stripe.service'
import { BookingsService } from '../bookings/graphql/bookings.service'

@Module({
  controllers: [StripeController],
  providers: [StripeService, BookingsService],
})
export class StripeModule {}
</file>

<file path="apps/api/src/models/stripe/stripe.service.ts">
import Stripe from 'stripe'

import { Injectable } from '@nestjs/common'
import { CreateStripeDto } from './dto/create-stripe-session.dto'
import { toTitleCase } from 'src/common/util'

@Injectable()
export default class StripeService {
  public stripe: Stripe

  constructor() {
    this.stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
      apiVersion: '2024-04-10',
    })
  }

  async createStripeSession({
    totalPriceObj,
    uid,
    bookingData,
  }: CreateStripeDto) {
    const session = await this.stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: Object.entries(totalPriceObj)
        .filter(([, price]) => price > 0)
        .map(([name, price]) => ({
          quantity: 1,
          price_data: {
            product_data: {
              name: toTitleCase(name),
            },
            currency: 'usd',
            unit_amount: price * 100,
          },
        })),
      mode: 'payment',
      success_url: process.env.STRIPE_SUCCESS_URL,
      cancel_url: process.env.STRIPE_CANCEL_URL,
      metadata: {
        uid,
        bookingData: JSON.stringify(bookingData),
      },
    })

    return { sessionId: session.id }
  }
}
</file>

<file path="apps/api/src/models/users/graphql/dtos/create-user.input.ts">
import {
  Field,
  InputType,
  ObjectType,
  PickType,
  registerEnumType,
} from '@nestjs/graphql'
import { User } from '../entity/user.entity'
import { AuthProviderType } from '@prisma/client'

registerEnumType(AuthProviderType, {
  name: 'AuthProviderType',
})

@InputType()
export class RegisterWithProviderInput extends PickType(
  User,
  ['uid', 'name', 'image'],
  InputType,
) {
  @Field(() => AuthProviderType)
  type: AuthProviderType
}

@InputType()
export class RegisterWithCredentialsInput extends PickType(
  User,
  ['name', 'image'],
  InputType,
) {
  email: string
  password: string
}

@InputType()
export class LoginInput extends PickType(RegisterWithCredentialsInput, [
  'email',
  'password',
]) {}

@ObjectType()
export class LoginOutput {
  token: string
  user: User
}
</file>

<file path="apps/api/src/models/users/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { UserOrderByWithRelationInput } from './order-by.args'
import { UserWhereInput, UserWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.UserScalarFieldEnum, {
  name: 'UserScalarFieldEnum',
})

@ArgsType()
class FindManyUserArgsStrict
  implements
    RestrictProperties<
      FindManyUserArgsStrict,
      Omit<Prisma.UserFindManyArgs, 'include' | 'select'>
    >
{
  where: UserWhereInput
  orderBy: UserOrderByWithRelationInput[]
  cursor: UserWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.UserScalarFieldEnum])
  distinct: Prisma.UserScalarFieldEnum[]
}

@ArgsType()
export class FindManyUserArgs extends PartialType(FindManyUserArgsStrict) {}

@ArgsType()
export class FindUniqueUserArgs {
  where: UserWhereUniqueInput
}
</file>

<file path="apps/api/src/models/users/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { CustomerOrderByWithRelationInput } from 'src/models/customers/graphql/dtos/order-by.args'
import { ManagerOrderByWithRelationInput } from 'src/models/managers/graphql/dtos/order-by.args'
import { ValetOrderByWithRelationInput } from 'src/models/valets/graphql/dtos/order-by.args'

@InputType()
export class UserOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      UserOrderByWithRelationInputStrict,
      Omit<
        Prisma.UserOrderByWithRelationInput,
        'Credentials' | 'AuthProvider' | 'Admin' | 'image'
      >
    >
{
  Customer: CustomerOrderByWithRelationInput
  Manager: ManagerOrderByWithRelationInput
  Valet: ValetOrderByWithRelationInput
  @Field(() => Prisma.SortOrder)
  uid: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  name: Prisma.SortOrder

  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class UserOrderByWithRelationInput extends PartialType(
  UserOrderByWithRelationInputStrict,
) {}

@InputType()
export class UserOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/users/graphql/dtos/update-user.input.ts">
import { InputType, PartialType } from '@nestjs/graphql'
import { User } from '../entity/user.entity'

@InputType()
export class UpdateUserInput extends PartialType(User) {
  uid: User['uid']
}
</file>

<file path="apps/api/src/models/users/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { CustomerRelationFilter } from 'src/models/customers/graphql/dtos/where.args'
import { ManagerRelationFilter } from 'src/models/managers/graphql/dtos/where.args'
import { ValetRelationFilter } from 'src/models/valets/graphql/dtos/where.args'

@InputType()
export class UserWhereUniqueInput {
  uid: string
}

@InputType()
export class UserWhereInputStrict
  implements
    RestrictProperties<
      UserWhereInputStrict,
      Omit<
        Prisma.UserWhereInput,
        'Credentials' | 'AuthProvider' | 'Admin' | 'image'
      >
    >
{
  Customer: CustomerRelationFilter
  Manager: ManagerRelationFilter
  Valet: ValetRelationFilter
  uid: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  name: StringFilter

  AND: UserWhereInput[]
  OR: UserWhereInput[]
  NOT: UserWhereInput[]
}

@InputType()
export class UserWhereInput extends PartialType(UserWhereInputStrict) {}

@InputType()
export class UserListRelationFilter {
  every?: UserWhereInput
  some?: UserWhereInput
  none?: UserWhereInput
}

@InputType()
export class UserRelationFilter {
  is?: UserWhereInput
  isNot?: UserWhereInput
}
</file>

<file path="apps/api/src/models/users/graphql/entity/user.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { $Enums, User as UserType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class User implements RestrictProperties<User, UserType> {
  @Field({ nullable: true })
  image: string
  uid: string
  createdAt: Date
  updatedAt: Date
  @Field({ nullable: true })
  name: string

  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}

@ObjectType()
export class AuthProvider {
  uid: string
  @Field(() => $Enums.AuthProviderType)
  type: $Enums.AuthProviderType
}
</file>

<file path="apps/api/src/models/users/graphql/users.resolver.ts">
import {
  Resolver,
  Query,
  Mutation,
  Args,
  ResolveField,
  Parent,
} from '@nestjs/graphql'
import { UsersService } from './users.service'
import { AuthProvider, User } from './entity/user.entity'
import { FindManyUserArgs, FindUniqueUserArgs } from './dtos/find.args'
import {
  LoginInput,
  LoginOutput,
  RegisterWithCredentialsInput,
  RegisterWithProviderInput,
} from './dtos/create-user.input'
import { UpdateUserInput } from './dtos/update-user.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { Admin } from 'src/models/admins/graphql/entity/admin.entity'
import { Manager } from 'src/models/managers/graphql/entity/manager.entity'
import { Valet } from 'src/models/valets/graphql/entity/valet.entity'
import { Customer } from 'src/models/customers/graphql/entity/customer.entity'

@Resolver(() => User)
export class UsersResolver {
  constructor(
    private readonly usersService: UsersService,
    private readonly prisma: PrismaService,
  ) {}

  @Mutation(() => User)
  async registerWithCredentials(
    @Args('registerWithCredentialsInput')
    args: RegisterWithCredentialsInput,
  ) {
    return this.usersService.registerWithCredentials(args)
  }

  @Mutation(() => User)
  async registerWithProvider(
    @Args('registerWithProviderInput') args: RegisterWithProviderInput,
  ) {
    return this.usersService.registerWithProvider(args)
  }

  @Mutation(() => LoginOutput)
  async login(@Args('loginInput') args: LoginInput) {
    return this.usersService.login(args)
  }

  @AllowAuthenticated()
  @Query(() => User)
  whoami(@GetUser() user: GetUserType) {
    return this.usersService.findOne({ where: { uid: user.uid } })
  }

  @Query(() => [User], { name: 'users' })
  findAll(@Args() args: FindManyUserArgs) {
    return this.usersService.findAll(args)
  }

  @Query(() => User, { name: 'user' })
  findOne(@Args() args: FindUniqueUserArgs) {
    return this.usersService.findOne(args)
  }

  @AllowAuthenticated()
  @Mutation(() => User)
  async updateUser(
    @Args('updateUserInput') args: UpdateUserInput,
    @GetUser() user: GetUserType,
  ) {
    const userInfo = await this.prisma.user.findUnique({
      where: { uid: args.uid },
    })
    checkRowLevelPermission(user, userInfo.uid)
    return this.usersService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => User)
  async removeUser(
    @Args() args: FindUniqueUserArgs,
    @GetUser() user: GetUserType,
  ) {
    const userInfo = await this.prisma.user.findUnique(args)
    checkRowLevelPermission(user, userInfo.uid)
    return this.usersService.remove(args)
  }

  @Query(() => AuthProvider, { name: 'getAuthProvider', nullable: true })
  getAuthProvider(@Args('uid') uid: string) {
    return this.prisma.authProvider.findUnique({ where: { uid } })
  }

  @ResolveField(() => Admin, { nullable: true })
  admin(@Parent() user: User) {
    return this.prisma.admin.findUnique({ where: { uid: user.uid } })
  }

  @ResolveField(() => Manager, { nullable: true })
  manager(@Parent() user: User) {
    return this.prisma.manager.findUnique({ where: { uid: user.uid } })
  }

  @ResolveField(() => Valet, { nullable: true })
  valet(@Parent() user: User) {
    return this.prisma.valet.findUnique({ where: { uid: user.uid } })
  }

  @ResolveField(() => Customer, { nullable: true })
  customer(@Parent() user: User) {
    return this.prisma.customer.findUnique({ where: { uid: user.uid } })
  }
}
</file>

<file path="apps/api/src/models/users/graphql/users.service.ts">
import {
  BadRequestException,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common'
import { FindManyUserArgs, FindUniqueUserArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import {
  LoginInput,
  LoginOutput,
  RegisterWithCredentialsInput,
  RegisterWithProviderInput,
} from './dtos/create-user.input'
import { UpdateUserInput } from './dtos/update-user.input'
import * as bcrypt from 'bcryptjs'
import { v4 as uuid } from 'uuid'
import { JwtService } from '@nestjs/jwt'

@Injectable()
export class UsersService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly jwtService: JwtService,
  ) {}
  registerWithProvider({ image, name, uid, type }: RegisterWithProviderInput) {
    return this.prisma.user.create({
      data: {
        uid,
        name,
        image,
        AuthProvider: {
          create: {
            type,
          },
        },
      },
    })
  }

  async registerWithCredentials({
    email,
    name,
    password,
    image,
  }: RegisterWithCredentialsInput) {
    const existingUser = await this.prisma.credentials.findUnique({
      where: { email },
    })

    if (existingUser) {
      throw new BadRequestException('User already exists with this email.')
    }

    // Hash the password
    const salt = bcrypt.genSaltSync()
    const passwordHash = bcrypt.hashSync(password, salt)

    const uid = uuid()

    return this.prisma.user.create({
      data: {
        uid,
        name,
        image,
        Credentials: {
          create: {
            email,
            passwordHash,
          },
        },
        AuthProvider: {
          create: {
            type: 'CREDENTIALS',
          },
        },
      },
      include: {
        Credentials: true,
      },
    })
  }

  async login({ email, password }: LoginInput): Promise<LoginOutput> {
    const user = await this.prisma.user.findFirst({
      where: {
        Credentials: { email },
      },
      include: {
        Credentials: true,
      },
    })

    if (!user) {
      throw new UnauthorizedException('Invalid email or password.')
    }

    const isPasswordValid = bcrypt.compareSync(
      password,
      user.Credentials.passwordHash,
    )

    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid email or password.')
    }

    const jwtToken = this.jwtService.sign(
      { uid: user.uid },
      {
        algorithm: 'HS256',
      },
    )

    return { token: jwtToken, user }
  }

  findAll(args: FindManyUserArgs) {
    return this.prisma.user.findMany(args)
  }

  findOne(args: FindUniqueUserArgs) {
    return this.prisma.user.findUnique(args)
  }

  update(updateUserInput: UpdateUserInput) {
    const { uid, ...data } = updateUserInput
    return this.prisma.user.update({
      where: { uid },
      data: data,
    })
  }

  remove(args: FindUniqueUserArgs) {
    return this.prisma.user.delete(args)
  }
}
</file>

<file path="apps/api/src/models/users/rest/dtos/create.dto.ts">
import { OmitType, PickType } from '@nestjs/swagger'
import { UserEntity } from '../entity/user.entity'

export class CreateUser extends PickType(UserEntity, ['uid', 'name']) {}
</file>

<file path="apps/api/src/models/users/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class UserQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.UserScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.UserScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/users/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateUser } from './create.dto'
import { User } from '@prisma/client'

export class UpdateUser extends PartialType(CreateUser) {
  uid: User['uid']
}
</file>

<file path="apps/api/src/models/users/rest/entity/user.entity.ts">
import { User } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class UserEntity implements RestrictProperties<UserEntity, User> {
  uid: string
  createdAt: Date
  updatedAt: Date
  @IsOptional()
  name: string
  @IsOptional()
  image: string
}
</file>

<file path="apps/api/src/models/users/rest/users.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateUser } from './dtos/create.dto'
import { UserQueryDto } from './dtos/query.dto'
import { UpdateUser } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { UserEntity } from './entity/user.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('users')
@Controller('users')
export class UsersController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: UserEntity })
  @Post()
  create(@Body() createUserDto: CreateUser, @GetUser() user: GetUserType) {
    checkRowLevelPermission(user, createUserDto.uid)
    return this.prisma.user.create({ data: createUserDto })
  }

  @ApiOkResponse({ type: [UserEntity] })
  @Get()
  findAll(
    @Query() { skip, take, order, sortBy, search, searchBy }: UserQueryDto,
  ) {
    return this.prisma.user.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
      ...(searchBy
        ? { where: { [searchBy]: { contains: search, mode: 'insensitive' } } }
        : null),
    })
  }

  @ApiOkResponse({ type: UserEntity })
  @Get(':uid')
  findOne(@Param('uid') uid: string) {
    return this.prisma.user.findUnique({ where: { uid } })
  }

  @ApiOkResponse({ type: UserEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':uid')
  async update(
    @Param('uid') uid: string,
    @Body() updateUserDto: UpdateUser,
    @GetUser() user: GetUserType,
  ) {
    const userInfo = await this.prisma.user.findUnique({ where: { uid } })
    checkRowLevelPermission(user, userInfo.uid)
    return this.prisma.user.update({
      where: { uid },
      data: updateUserDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':uid')
  async remove(@Param('uid') uid: string, @GetUser() user: GetUserType) {
    const userInfo = await this.prisma.user.findUnique({ where: { uid } })
    checkRowLevelPermission(user, userInfo.uid)
    return this.prisma.user.delete({ where: { uid } })
  }
}
</file>

<file path="apps/api/src/models/users/users.module.ts">
import { Module } from '@nestjs/common'
import { UsersService } from './graphql/users.service'
import { UsersResolver } from './graphql/users.resolver'
import { UsersController } from './rest/users.controller'

@Module({
  providers: [UsersResolver, UsersService],
  exports: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {}
</file>

<file path="apps/api/src/models/valet-assignments/graphql/dtos/create-valet-assignment.input.ts">
import { Field, InputType, OmitType, PickType } from '@nestjs/graphql'
import { ValetAssignment } from '../entity/valet-assignment.entity'

@InputType()
export class CreateValetAssignmentInput extends OmitType(
  ValetAssignment,
  ['createdAt', 'updatedAt'],
  InputType,
) {}

@InputType()
export class CreateValetAssignmentInputWithoutBookingId {
  pickupLat: number
  pickupLng: number
  returnLat?: number
  returnLng?: number
}
</file>

<file path="apps/api/src/models/valet-assignments/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { ValetAssignmentOrderByWithRelationInput } from './order-by.args'
import {
  ValetAssignmentWhereInput,
  ValetAssignmentWhereUniqueInput,
} from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.ValetAssignmentScalarFieldEnum, {
  name: 'ValetAssignmentScalarFieldEnum',
})

@ArgsType()
class FindManyValetAssignmentArgsStrict
  implements
    RestrictProperties<
      FindManyValetAssignmentArgsStrict,
      Omit<Prisma.ValetAssignmentFindManyArgs, 'include' | 'select'>
    >
{
  where: ValetAssignmentWhereInput
  orderBy: ValetAssignmentOrderByWithRelationInput[]
  cursor: ValetAssignmentWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.ValetAssignmentScalarFieldEnum])
  distinct: Prisma.ValetAssignmentScalarFieldEnum[]
}

@ArgsType()
export class FindManyValetAssignmentArgs extends PartialType(
  FindManyValetAssignmentArgsStrict,
) {}

@ArgsType()
export class FindUniqueValetAssignmentArgs {
  where: ValetAssignmentWhereUniqueInput
}
</file>

<file path="apps/api/src/models/valet-assignments/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { BookingOrderByWithRelationInput } from 'src/models/bookings/graphql/dtos/order-by.args'
import { ValetOrderByWithRelationInput } from 'src/models/valets/graphql/dtos/order-by.args'

@InputType()
export class ValetAssignmentOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      ValetAssignmentOrderByWithRelationInputStrict,
      Prisma.ValetAssignmentOrderByWithRelationInput
    >
{
  @Field(() => Prisma.SortOrder)
  bookingId: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  pickupLat: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  pickupLng: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  returnLat: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  returnLng: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  pickupValetId: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  returnValetId: Prisma.SortOrder
  PickupValet: ValetOrderByWithRelationInput
  ReturnValet: ValetOrderByWithRelationInput
  Booking: BookingOrderByWithRelationInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class ValetAssignmentOrderByWithRelationInput extends PartialType(
  ValetAssignmentOrderByWithRelationInputStrict,
) {}

@InputType()
export class ValetAssignmentOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/valet-assignments/graphql/dtos/update-valet-assignment.input.ts">
import { CreateValetAssignmentInput } from './create-valet-assignment.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { ValetAssignment } from '@prisma/client'

@InputType()
export class UpdateValetAssignmentInput extends PartialType(
  CreateValetAssignmentInput,
) {
  bookingId: ValetAssignment['bookingId']
}
</file>

<file path="apps/api/src/models/valet-assignments/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  FloatFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { BookingRelationFilter } from 'src/models/bookings/graphql/dtos/where.args'
import { ValetRelationFilter } from 'src/models/valets/graphql/dtos/where.args'

@InputType()
export class ValetAssignmentWhereUniqueInput {
  bookingId: number
}

@InputType()
export class ValetAssignmentWhereInputStrict
  implements
    RestrictProperties<
      ValetAssignmentWhereInputStrict,
      Prisma.ValetAssignmentWhereInput
    >
{
  bookingId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  pickupLat: FloatFilter
  pickupLng: FloatFilter
  returnLat: FloatFilter
  returnLng: FloatFilter
  pickupValetId: StringFilter
  returnValetId: StringFilter
  PickupValet: ValetRelationFilter
  ReturnValet: ValetRelationFilter
  Booking: BookingRelationFilter

  AND: ValetAssignmentWhereInput[]
  OR: ValetAssignmentWhereInput[]
  NOT: ValetAssignmentWhereInput[]
}

@InputType()
export class ValetAssignmentWhereInput extends PartialType(
  ValetAssignmentWhereInputStrict,
) {}

@InputType()
export class ValetAssignmentListRelationFilter {
  every?: ValetAssignmentWhereInput
  some?: ValetAssignmentWhereInput
  none?: ValetAssignmentWhereInput
}

@InputType()
export class ValetAssignmentRelationFilter {
  is?: ValetAssignmentWhereInput
  isNot?: ValetAssignmentWhereInput
}
</file>

<file path="apps/api/src/models/valet-assignments/graphql/entity/valet-assignment.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { ValetAssignment as ValetAssignmentType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class ValetAssignment
  implements RestrictProperties<ValetAssignment, ValetAssignmentType>
{
  bookingId: number
  createdAt: Date
  updatedAt: Date
  pickupLat: number
  pickupLng: number
  @Field({ nullable: true })
  returnLat: number
  @Field({ nullable: true })
  returnLng: number
  @Field({ nullable: true })
  pickupValetId: string
  @Field({ nullable: true })
  returnValetId: string
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/valet-assignments/graphql/valet-assignments.resolver.ts">
import {
  ResolveField,
  Parent,
  Resolver,
  Query,
  Mutation,
  Args,
} from '@nestjs/graphql'
import { ValetAssignmentsService } from './valet-assignments.service'
import { ValetAssignment } from './entity/valet-assignment.entity'
import {
  FindManyValetAssignmentArgs,
  FindUniqueValetAssignmentArgs,
} from './dtos/find.args'
import { CreateValetAssignmentInput } from './dtos/create-valet-assignment.input'
import { UpdateValetAssignmentInput } from './dtos/update-valet-assignment.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { Valet } from 'src/models/valets/graphql/entity/valet.entity'

@Resolver(() => ValetAssignment)
export class ValetAssignmentsResolver {
  constructor(
    private readonly valetAssignmentsService: ValetAssignmentsService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated()
  @Mutation(() => ValetAssignment)
  createValetAssignment(
    @Args('createValetAssignmentInput') args: CreateValetAssignmentInput,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, [args.pickupValetId, args.returnValetId])
    return this.valetAssignmentsService.create(args)
  }

  @Query(() => [ValetAssignment], { name: 'valetAssignments' })
  findAll(@Args() args: FindManyValetAssignmentArgs) {
    return this.valetAssignmentsService.findAll(args)
  }

  @Query(() => ValetAssignment, { name: 'valetAssignment' })
  findOne(@Args() args: FindUniqueValetAssignmentArgs) {
    return this.valetAssignmentsService.findOne(args)
  }

  @AllowAuthenticated()
  @Mutation(() => ValetAssignment)
  async updateValetAssignment(
    @Args('updateValetAssignmentInput') args: UpdateValetAssignmentInput,
    @GetUser() user: GetUserType,
  ) {
    const valetAssignment = await this.prisma.valetAssignment.findUnique({
      where: { bookingId: args.bookingId },
    })
    checkRowLevelPermission(user, [
      valetAssignment.pickupValetId,
      valetAssignment.returnValetId,
    ])
    return this.valetAssignmentsService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => ValetAssignment)
  async removeValetAssignment(
    @Args() args: FindUniqueValetAssignmentArgs,
    @GetUser() user: GetUserType,
  ) {
    const valetAssignment = await this.prisma.valetAssignment.findUnique(args)
    checkRowLevelPermission(user, [
      valetAssignment.pickupValetId,
      valetAssignment.returnValetId,
    ])
    return this.valetAssignmentsService.remove(args)
  }

  @ResolveField(() => Valet, { nullable: true })
  pickupValet(@Parent() parent: ValetAssignment) {
    if (!parent.pickupValetId) {
      return null
    }
    return this.prisma.valet.findUnique({
      where: { uid: parent.pickupValetId },
    })
  }

  @ResolveField(() => Valet, { nullable: true })
  returnValet(@Parent() parent: ValetAssignment) {
    if (!parent.returnValetId) {
      return null
    }
    return this.prisma.valet.findUnique({
      where: { uid: parent.returnValetId },
    })
  }
}
</file>

<file path="apps/api/src/models/valet-assignments/graphql/valet-assignments.service.ts">
import { Injectable } from '@nestjs/common'
import {
  FindManyValetAssignmentArgs,
  FindUniqueValetAssignmentArgs,
} from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateValetAssignmentInput } from './dtos/create-valet-assignment.input'
import { UpdateValetAssignmentInput } from './dtos/update-valet-assignment.input'

@Injectable()
export class ValetAssignmentsService {
  constructor(private readonly prisma: PrismaService) {}
  create(createValetAssignmentInput: CreateValetAssignmentInput) {
    return this.prisma.valetAssignment.create({
      data: createValetAssignmentInput,
    })
  }

  findAll(args: FindManyValetAssignmentArgs) {
    return this.prisma.valetAssignment.findMany(args)
  }

  findOne(args: FindUniqueValetAssignmentArgs) {
    return this.prisma.valetAssignment.findUnique(args)
  }

  update(updateValetAssignmentInput: UpdateValetAssignmentInput) {
    const { bookingId, ...data } = updateValetAssignmentInput
    return this.prisma.valetAssignment.update({
      where: { bookingId },
      data: data,
    })
  }

  remove(args: FindUniqueValetAssignmentArgs) {
    return this.prisma.valetAssignment.delete(args)
  }
}
</file>

<file path="apps/api/src/models/valet-assignments/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { ValetAssignmentEntity } from '../entity/valet-assignment.entity'

export class CreateValetAssignment extends OmitType(ValetAssignmentEntity, [
  'createdAt',
  'updatedAt',
]) {}
</file>

<file path="apps/api/src/models/valet-assignments/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class ValetAssignmentQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.ValetAssignmentScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.ValetAssignmentScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/valet-assignments/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateValetAssignment } from './create.dto'
import { ValetAssignment } from '@prisma/client'

export class UpdateValetAssignment extends PartialType(CreateValetAssignment) {
  bookingId: ValetAssignment['bookingId']
}
</file>

<file path="apps/api/src/models/valet-assignments/rest/entity/valet-assignment.entity.ts">
import { ValetAssignment } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class ValetAssignmentEntity
  implements RestrictProperties<ValetAssignmentEntity, ValetAssignment>
{
  bookingId: number
  createdAt: Date
  updatedAt: Date
  pickupLat: number
  pickupLng: number
  @IsOptional()
  returnLat: number
  @IsOptional()
  returnLng: number
  pickupValetId: string
  returnValetId: string
}
</file>

<file path="apps/api/src/models/valet-assignments/rest/valet-assignments.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateValetAssignment } from './dtos/create.dto'
import { ValetAssignmentQueryDto } from './dtos/query.dto'
import { UpdateValetAssignment } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { ValetAssignmentEntity } from './entity/valet-assignment.entity'

@ApiTags('valet-assignments')
@Controller('valet-assignments')
export class ValetAssignmentsController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: ValetAssignmentEntity })
  @Post()
  create(
    @Body() createValetAssignmentDto: CreateValetAssignment,
    @GetUser() user: GetUserType,
  ) {
    checkRowLevelPermission(user, [
      createValetAssignmentDto.pickupValetId,
      createValetAssignmentDto.returnValetId,
    ])
    return this.prisma.valetAssignment.create({
      data: createValetAssignmentDto,
    })
  }

  @ApiOkResponse({ type: [ValetAssignmentEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: ValetAssignmentQueryDto) {
    return this.prisma.valetAssignment.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: ValetAssignmentEntity })
  @Get(':bookingId')
  findOne(@Param('bookingId') bookingId: number) {
    return this.prisma.valetAssignment.findUnique({ where: { bookingId } })
  }

  @ApiOkResponse({ type: ValetAssignmentEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':bookingId')
  async update(
    @Param('bookingId') bookingId: number,
    @Body() updateValetAssignmentDto: UpdateValetAssignment,
    @GetUser() user: GetUserType,
  ) {
    const valetAssignment = await this.prisma.valetAssignment.findUnique({
      where: { bookingId },
    })
    checkRowLevelPermission(user, [
      valetAssignment.pickupValetId,
      valetAssignment.returnValetId,
    ])
    return this.prisma.valetAssignment.update({
      where: { bookingId },
      data: updateValetAssignmentDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':bookingId')
  async remove(
    @Param('bookingId') bookingId: number,
    @GetUser() user: GetUserType,
  ) {
    const valetAssignment = await this.prisma.valetAssignment.findUnique({
      where: { bookingId },
    })
    checkRowLevelPermission(user, [
      valetAssignment.pickupValetId,
      valetAssignment.returnValetId,
    ])
    return this.prisma.valetAssignment.delete({ where: { bookingId } })
  }
}
</file>

<file path="apps/api/src/models/valet-assignments/valet-assignments.module.ts">
import { Module } from '@nestjs/common'
import { ValetAssignmentsService } from './graphql/valet-assignments.service'
import { ValetAssignmentsResolver } from './graphql/valet-assignments.resolver'
import { ValetAssignmentsController } from './rest/valet-assignments.controller'

@Module({
  providers: [ValetAssignmentsResolver, ValetAssignmentsService],
  exports: [ValetAssignmentsService],
  controllers: [ValetAssignmentsController],
})
export class ValetAssignmentsModule {}
</file>

<file path="apps/api/src/models/valets/graphql/dtos/create-valet.input.ts">
import { InputType, OmitType, PickType } from '@nestjs/graphql'
import { Valet } from '../entity/valet.entity'

@InputType()
export class CreateValetInput extends OmitType(
  Valet,
  ['createdAt', 'updatedAt'],
  InputType,
) {}
</file>

<file path="apps/api/src/models/valets/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { ValetOrderByWithRelationInput } from './order-by.args'
import { ValetWhereInput, ValetWhereUniqueInput } from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.ValetScalarFieldEnum, {
  name: 'ValetScalarFieldEnum',
})

@ArgsType()
class FindManyValetArgsStrict
  implements
    RestrictProperties<
      FindManyValetArgsStrict,
      Omit<Prisma.ValetFindManyArgs, 'include' | 'select'>
    >
{
  where: ValetWhereInput
  orderBy: ValetOrderByWithRelationInput[]
  cursor: ValetWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.ValetScalarFieldEnum])
  distinct: Prisma.ValetScalarFieldEnum[]
}

@ArgsType()
export class FindManyValetArgs extends PartialType(FindManyValetArgsStrict) {}

@ArgsType()
export class FindUniqueValetArgs {
  where: ValetWhereUniqueInput
}
</file>

<file path="apps/api/src/models/valets/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { BookingTimelineOrderByRelationAggregateInput } from 'src/models/booking-timelines/graphql/dtos/order-by.args'
import { CompanyOrderByWithRelationInput } from 'src/models/companies/graphql/dtos/order-by.args'
import { UserOrderByWithRelationInput } from 'src/models/users/graphql/dtos/order-by.args'
import { ValetAssignmentOrderByRelationAggregateInput } from 'src/models/valet-assignments/graphql/dtos/order-by.args'

@InputType()
export class ValetOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      ValetOrderByWithRelationInputStrict,
      Prisma.ValetOrderByWithRelationInput
    >
{
  User: UserOrderByWithRelationInput
  @Field(() => Prisma.SortOrder)
  uid: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  displayName: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  image: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  licenceID: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  companyId: Prisma.SortOrder
  Company: CompanyOrderByWithRelationInput
  BookingTimeline: BookingTimelineOrderByRelationAggregateInput
  PickupAssignments: ValetAssignmentOrderByRelationAggregateInput
  ReturnAssignments: ValetAssignmentOrderByRelationAggregateInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class ValetOrderByWithRelationInput extends PartialType(
  ValetOrderByWithRelationInputStrict,
) {}

@InputType()
export class ValetOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/valets/graphql/dtos/update-valet.input.ts">
import { CreateValetInput } from './create-valet.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Valet } from '@prisma/client'

@InputType()
export class UpdateValetInput extends PartialType(CreateValetInput) {
  uid: Valet['uid']
}
</file>

<file path="apps/api/src/models/valets/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  DateTimeFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { BookingTimelineListRelationFilter } from 'src/models/booking-timelines/graphql/dtos/where.args'
import { CompanyRelationFilter } from 'src/models/companies/graphql/dtos/where.args'
import { UserRelationFilter } from 'src/models/users/graphql/dtos/where.args'
import { ValetAssignmentListRelationFilter } from 'src/models/valet-assignments/graphql/dtos/where.args'

@InputType()
export class ValetWhereUniqueInput {
  uid: string
}

@InputType()
export class ValetWhereInputStrict
  implements RestrictProperties<ValetWhereInputStrict, Prisma.ValetWhereInput>
{
  User: UserRelationFilter
  uid: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  image: StringFilter
  licenceID: StringFilter
  companyId: IntFilter
  Company: CompanyRelationFilter
  BookingTimeline: BookingTimelineListRelationFilter
  PickupAssignments: ValetAssignmentListRelationFilter
  ReturnAssignments: ValetAssignmentListRelationFilter

  AND: ValetWhereInput[]
  OR: ValetWhereInput[]
  NOT: ValetWhereInput[]
}

@InputType()
export class ValetWhereInput extends PartialType(ValetWhereInputStrict) {}

@InputType()
export class ValetListRelationFilter {
  every?: ValetWhereInput
  some?: ValetWhereInput
  none?: ValetWhereInput
}

@InputType()
export class ValetRelationFilter {
  is?: ValetWhereInput
  isNot?: ValetWhereInput
}
</file>

<file path="apps/api/src/models/valets/graphql/entity/valet.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { Valet as ValetType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class Valet implements RestrictProperties<Valet, ValetType> {
  uid: string
  createdAt: Date
  updatedAt: Date
  displayName: string
  @Field({ nullable: true })
  image: string
  licenceID: string
  @Field({ nullable: true })
  companyId: number
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/valets/graphql/valets.resolver.ts">
import { Resolver, Query, Mutation, Args } from '@nestjs/graphql'
import { ValetsService } from './valets.service'
import { Valet } from './entity/valet.entity'
import { FindManyValetArgs, FindUniqueValetArgs } from './dtos/find.args'
import { CreateValetInput } from './dtos/create-valet.input'
import { UpdateValetInput } from './dtos/update-valet.input'
import { checkRowLevelPermission } from 'src/common/auth/util'
import { GetUserType } from 'src/common/types'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { ValetWhereInput } from './dtos/where.args'
import { Booking } from 'src/models/bookings/graphql/entity/booking.entity'
import { PaginationInput } from 'src/common/dtos/common.input'
import { BookingStatus } from '@prisma/client'
import { BadGatewayException } from '@nestjs/common'

@Resolver(() => Valet)
export class ValetsResolver {
  constructor(
    private readonly valetsService: ValetsService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated()
  @Mutation(() => Valet)
  async createValet(
    @Args('createValetInput') args: CreateValetInput,
    @GetUser() user: GetUserType,
  ) {
    const company = await this.prisma.company.findFirst({
      where: { Managers: { some: { uid: user.uid } } },
    })

    if (!company) {
      throw new BadGatewayException('You do not have a company.')
    }
    return this.valetsService.create({ ...args, companyId: company.id })
  }

  @Query(() => [Valet], { name: 'valets' })
  findAll(@Args() args: FindManyValetArgs) {
    return this.valetsService.findAll(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Booking)
  async assignValet(
    @Args('bookingId') bookingId: number,
    @Args('status') status: BookingStatus,
    @GetUser() user: GetUserType,
  ) {
    const booking = await this.prisma.booking.findUnique({
      where: { id: bookingId },
      select: {
        Slot: {
          select: {
            Garage: {
              select: {
                Company: { select: { Managers: true, Valets: true } },
              },
            },
          },
        },
      },
    })

    checkRowLevelPermission(user, [
      ...booking.Slot.Garage.Company.Managers.map((manager) => manager.uid),
      ...booking.Slot.Garage.Company.Valets.map((valet) => valet.uid),
    ])

    const [updatedBooking, bookingTimeline] = await this.prisma.$transaction([
      this.prisma.booking.update({
        where: { id: bookingId },
        data: {
          status,
          ...(status === BookingStatus.VALET_ASSIGNED_FOR_CHECK_IN && {
            ValetAssignment: {
              update: { pickupValetId: user.uid },
            },
          }),
          ...(status === BookingStatus.VALET_ASSIGNED_FOR_CHECK_OUT && {
            ValetAssignment: {
              update: { returnValetId: user.uid },
            },
          }),
        },
      }),
      this.prisma.bookingTimeline.create({
        data: {
          bookingId,
          valetId: user.uid,
          status,
        },
      }),
    ])

    return updatedBooking
  }

  @AllowAuthenticated('manager', 'admin')
  @Query(() => [Valet], { name: 'companyValets' })
  async companyValets(
    @Args() args: FindManyValetArgs,
    @GetUser() user: GetUserType,
  ) {
    const company = await this.prisma.company.findFirst({
      where: { Managers: { some: { uid: user.uid } } },
    })
    return this.valetsService.findAll({
      ...args,
      where: { ...args.where, companyId: { equals: company.id } },
    })
  }

  @AllowAuthenticated()
  @Query(() => Number)
  async companyValetsTotal(
    @Args('where', { nullable: true }) where: ValetWhereInput,
    @GetUser() user: GetUserType,
  ) {
    const company = await this.prisma.company.findFirst({
      where: { Managers: { some: { uid: user.uid } } },
    })

    return this.prisma.valet.count({
      where: { ...where, companyId: { equals: company.id } },
    })
  }

  @Query(() => Valet, { name: 'valet' })
  findOne(@Args() args: FindUniqueValetArgs) {
    return this.valetsService.findOne(args)
  }

  @AllowAuthenticated()
  @Query(() => Valet, { name: 'valetMe', nullable: true })
  valetMe(@GetUser() user: GetUserType) {
    return this.valetsService.findOne({ where: { uid: user.uid } })
  }

  @AllowAuthenticated('valet')
  @Query(() => [Booking], { name: 'valetPickups' })
  async valetPickups(
    @Args() { skip, take }: PaginationInput,
    @GetUser() user: GetUserType,
  ) {
    const valet = await this.valetsService.validValet(user.uid)
    return this.prisma.booking.findMany({
      skip,
      take,
      where: {
        Slot: { Garage: { companyId: valet.companyId } },
        ValetAssignment: {
          pickupLat: { not: undefined },
          pickupValetId: null,
        },
      },
    })
  }

  @AllowAuthenticated()
  @Query(() => Number)
  async valetPickupsTotal(@GetUser() user: GetUserType) {
    const valet = await this.valetsService.validValet(user.uid)
    return this.prisma.booking.count({
      where: {
        Slot: { Garage: { companyId: valet.companyId } },
        ValetAssignment: {
          pickupLat: { not: undefined },
          pickupValetId: null,
        },
      },
    })
  }

  @AllowAuthenticated()
  @Query(() => [Booking], { name: 'valetDrops' })
  async valetDrops(
    @Args() { skip, take }: PaginationInput,
    @GetUser() user: GetUserType,
  ) {
    const valet = await this.valetsService.validValet(user.uid)

    return this.prisma.booking.findMany({
      skip,
      take,
      where: {
        Slot: { Garage: { companyId: valet.companyId } },
        ValetAssignment: {
          returnLat: { not: null },
          returnValetId: null,
        },
      },
    })
  }

  @AllowAuthenticated()
  @Query(() => Number)
  async valetDropsTotal(@GetUser() user: GetUserType) {
    const valet = await this.valetsService.validValet(user.uid)

    return this.prisma.booking.count({
      where: {
        Slot: { Garage: { companyId: valet.companyId } },
        ValetAssignment: {
          returnLat: { not: null },
          returnValetId: null,
        },
      },
    })
  }

  @AllowAuthenticated()
  @Mutation(() => Valet)
  async updateValet(
    @Args('updateValetInput') args: UpdateValetInput,
    @GetUser() user: GetUserType,
  ) {
    const valet = await this.prisma.valet.findUnique({
      where: { uid: args.uid },
    })
    checkRowLevelPermission(user, valet.uid)
    return this.valetsService.update(args)
  }

  @AllowAuthenticated()
  @Mutation(() => Valet)
  async removeValet(
    @Args() args: FindUniqueValetArgs,
    @GetUser() user: GetUserType,
  ) {
    const valet = await this.prisma.valet.findUnique(args)
    checkRowLevelPermission(user, valet.uid)
    return this.valetsService.remove(args)
  }
}
</file>

<file path="apps/api/src/models/valets/graphql/valets.service.ts">
import { BadRequestException, Injectable } from '@nestjs/common'
import { FindManyValetArgs, FindUniqueValetArgs } from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateValetInput } from './dtos/create-valet.input'
import { UpdateValetInput } from './dtos/update-valet.input'

@Injectable()
export class ValetsService {
  constructor(private readonly prisma: PrismaService) {}
  create(createValetInput: CreateValetInput) {
    return this.prisma.valet.create({
      data: createValetInput,
    })
  }

  findAll(args: FindManyValetArgs) {
    return this.prisma.valet.findMany(args)
  }

  findOne(args: FindUniqueValetArgs) {
    return this.prisma.valet.findUnique(args)
  }

  update(updateValetInput: UpdateValetInput) {
    const { uid, ...data } = updateValetInput
    return this.prisma.valet.update({
      where: { uid },
      data: data,
    })
  }

  remove(args: FindUniqueValetArgs) {
    return this.prisma.valet.delete(args)
  }

  async validValet(uid: string) {
    const valet = await this.prisma.valet.findUnique({
      where: { uid: uid },
    })
    if (!valet) {
      throw new BadRequestException('You are not a valet.')
    }
    return valet
  }
}
</file>

<file path="apps/api/src/models/valets/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { ValetEntity } from '../entity/valet.entity'

export class CreateValet extends OmitType(ValetEntity, [
  'createdAt',
  'updatedAt',
]) {}
</file>

<file path="apps/api/src/models/valets/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class ValetQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.ValetScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.ValetScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/valets/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateValet } from './create.dto'
import { Valet } from '@prisma/client'

export class UpdateValet extends PartialType(CreateValet) {
  uid: Valet['uid']
}
</file>

<file path="apps/api/src/models/valets/rest/entity/valet.entity.ts">
import { Valet } from '@prisma/client'
import { IsDate, IsString, IsInt, IsOptional } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class ValetEntity implements RestrictProperties<ValetEntity, Valet> {
  uid: string
  createdAt: Date
  updatedAt: Date
  displayName: string
  @IsOptional()
  image: string
  licenceID: string
  @IsOptional()
  companyId: number
}
</file>

<file path="apps/api/src/models/valets/rest/valets.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateValet } from './dtos/create.dto'
import { ValetQueryDto } from './dtos/query.dto'
import { UpdateValet } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { ValetEntity } from './entity/valet.entity'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { GetUserType } from 'src/common/types'
import { checkRowLevelPermission } from 'src/common/auth/util'

@ApiTags('valets')
@Controller('valets')
export class ValetsController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated()
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: ValetEntity })
  @Post()
  create(@Body() createValetDto: CreateValet, @GetUser() user: GetUserType) {
    checkRowLevelPermission(user, createValetDto.uid)
    return this.prisma.valet.create({ data: createValetDto })
  }

  @ApiOkResponse({ type: [ValetEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: ValetQueryDto) {
    return this.prisma.valet.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: ValetEntity })
  @Get(':uid')
  findOne(@Param('uid') uid: string) {
    return this.prisma.valet.findUnique({ where: { uid } })
  }

  @ApiOkResponse({ type: ValetEntity })
  @ApiBearerAuth()
  @AllowAuthenticated()
  @Patch(':uid')
  async update(
    @Param('uid') uid: string,
    @Body() updateValetDto: UpdateValet,
    @GetUser() user: GetUserType,
  ) {
    const valet = await this.prisma.valet.findUnique({ where: { uid } })
    checkRowLevelPermission(user, valet.uid)
    return this.prisma.valet.update({
      where: { uid },
      data: updateValetDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated()
  @Delete(':uid')
  async remove(@Param('uid') uid: string, @GetUser() user: GetUserType) {
    const valet = await this.prisma.valet.findUnique({ where: { uid } })
    checkRowLevelPermission(user, valet.uid)
    return this.prisma.valet.delete({ where: { uid } })
  }
}
</file>

<file path="apps/api/src/models/valets/valets.module.ts">
import { Module } from '@nestjs/common'
import { ValetsService } from './graphql/valets.service'
import { ValetsResolver } from './graphql/valets.resolver'
import { ValetsController } from './rest/valets.controller'

@Module({
  providers: [ValetsResolver, ValetsService],
  exports: [ValetsService],
  controllers: [ValetsController],
})
export class ValetsModule {}
</file>

<file path="apps/api/src/models/verifications/graphql/dtos/create-verification.input.ts">
import { InputType, OmitType, PickType } from '@nestjs/graphql'
import { Verification } from '../entity/verification.entity'

@InputType()
export class CreateVerificationInput extends OmitType(
  Verification,
  ['createdAt', 'updatedAt', 'adminId'],
  InputType,
) {}
</file>

<file path="apps/api/src/models/verifications/graphql/dtos/find.args.ts">
import { ArgsType, Field, registerEnumType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { VerificationOrderByWithRelationInput } from './order-by.args'
import {
  VerificationWhereInput,
  VerificationWhereUniqueInput,
} from './where.args'
import { RestrictProperties } from 'src/common/dtos/common.input'

registerEnumType(Prisma.VerificationScalarFieldEnum, {
  name: 'VerificationScalarFieldEnum',
})

@ArgsType()
class FindManyVerificationArgsStrict
  implements
    RestrictProperties<
      FindManyVerificationArgsStrict,
      Omit<Prisma.VerificationFindManyArgs, 'include' | 'select'>
    >
{
  where: VerificationWhereInput
  orderBy: VerificationOrderByWithRelationInput[]
  cursor: VerificationWhereUniqueInput
  take: number
  skip: number
  @Field(() => [Prisma.VerificationScalarFieldEnum])
  distinct: Prisma.VerificationScalarFieldEnum[]
}

@ArgsType()
export class FindManyVerificationArgs extends PartialType(
  FindManyVerificationArgsStrict,
) {}

@ArgsType()
export class FindUniqueVerificationArgs {
  where: VerificationWhereUniqueInput
}
</file>

<file path="apps/api/src/models/verifications/graphql/dtos/order-by.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'
import { AdminOrderByWithRelationInput } from 'src/models/admins/graphql/dtos/order-by.args'
import { GarageOrderByWithRelationInput } from 'src/models/garages/graphql/dtos/order-by.args'

@InputType()
export class VerificationOrderByWithRelationInputStrict
  implements
    RestrictProperties<
      VerificationOrderByWithRelationInputStrict,
      Prisma.VerificationOrderByWithRelationInput
    >
{
  @Field(() => Prisma.SortOrder)
  createdAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  updatedAt: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  verified: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  adminId: Prisma.SortOrder
  @Field(() => Prisma.SortOrder)
  garageId: Prisma.SortOrder
  Admin: AdminOrderByWithRelationInput
  Garage: GarageOrderByWithRelationInput
  // Todo: Add below field decorator to the SortOrder properties.
  // @Field(() => Prisma.SortOrder)
}

@InputType()
export class VerificationOrderByWithRelationInput extends PartialType(
  VerificationOrderByWithRelationInputStrict,
) {}

@InputType()
export class VerificationOrderByRelationAggregateInput {
  @Field(() => Prisma.SortOrder)
  _count?: Prisma.SortOrder
}
</file>

<file path="apps/api/src/models/verifications/graphql/dtos/update-verification.input.ts">
import { CreateVerificationInput } from './create-verification.input'
import { InputType, PartialType } from '@nestjs/graphql'
import { Verification } from '@prisma/client'

@InputType()
export class UpdateVerificationInput extends PartialType(
  CreateVerificationInput,
) {
  garageId: Verification['garageId']
}
</file>

<file path="apps/api/src/models/verifications/graphql/dtos/where.args.ts">
import { Field, InputType, PartialType } from '@nestjs/graphql'
import { Prisma } from '@prisma/client'
import {
  BoolFilter,
  DateTimeFilter,
  IntFilter,
  RestrictProperties,
  StringFilter,
} from 'src/common/dtos/common.input'
import { AdminRelationFilter } from 'src/models/admins/graphql/dtos/where.args'
import { GarageRelationFilter } from 'src/models/garages/graphql/dtos/where.args'

@InputType()
export class VerificationWhereUniqueInput {
  garageId: number
}

@InputType()
export class VerificationWhereInputStrict
  implements
    RestrictProperties<
      VerificationWhereInputStrict,
      Prisma.VerificationWhereInput
    >
{
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  verified: BoolFilter
  adminId: StringFilter
  garageId: IntFilter
  Admin: AdminRelationFilter
  Garage: GarageRelationFilter

  AND: VerificationWhereInput[]
  OR: VerificationWhereInput[]
  NOT: VerificationWhereInput[]
}

@InputType()
export class VerificationWhereInput extends PartialType(
  VerificationWhereInputStrict,
) {}

@InputType()
export class VerificationListRelationFilter {
  every?: VerificationWhereInput
  some?: VerificationWhereInput
  none?: VerificationWhereInput
}

@InputType()
export class VerificationRelationFilter {
  is?: VerificationWhereInput
  isNot?: VerificationWhereInput
}
</file>

<file path="apps/api/src/models/verifications/graphql/entity/verification.entity.ts">
import { Field, ObjectType } from '@nestjs/graphql'
import { Verification as VerificationType } from '@prisma/client'
import { RestrictProperties } from 'src/common/dtos/common.input'

@ObjectType()
export class Verification
  implements RestrictProperties<Verification, VerificationType>
{
  @Field()
  createdAt: Date
  updatedAt: Date
  verified: boolean
  adminId: string
  @Field()
  garageId: number
  // Todo Add below to make optional fields optional.
  // @Field({ nullable: true })
}
</file>

<file path="apps/api/src/models/verifications/graphql/verifications.resolver.ts">
import { Resolver, Query, Mutation, Args } from '@nestjs/graphql'
import { VerificationsService } from './verifications.service'
import { Verification } from './entity/verification.entity'
import {
  FindManyVerificationArgs,
  FindUniqueVerificationArgs,
} from './dtos/find.args'
import { CreateVerificationInput } from './dtos/create-verification.input'
import { UpdateVerificationInput } from './dtos/update-verification.input'
import { AllowAuthenticated, GetUser } from 'src/common/auth/auth.decorator'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { GetUserType } from 'src/common/types'

@Resolver(() => Verification)
export class VerificationsResolver {
  constructor(
    private readonly verificationsService: VerificationsService,
    private readonly prisma: PrismaService,
  ) {}

  @AllowAuthenticated('admin')
  @Mutation(() => Verification)
  createVerification(
    @Args('createVerificationInput') args: CreateVerificationInput,
    @GetUser() user: GetUserType,
  ) {
    return this.verificationsService.create(args, user.uid)
  }

  @Query(() => [Verification], { name: 'verifications' })
  findAll(@Args() args: FindManyVerificationArgs) {
    return this.verificationsService.findAll(args)
  }

  @Query(() => Verification, { name: 'verification' })
  findOne(@Args() args: FindUniqueVerificationArgs) {
    return this.verificationsService.findOne(args)
  }

  @AllowAuthenticated('admin')
  @Mutation(() => Verification)
  async updateVerification(
    @Args('updateVerificationInput') args: UpdateVerificationInput,
  ) {
    return this.verificationsService.update(args)
  }

  @AllowAuthenticated('admin')
  @Mutation(() => Verification)
  async removeVerification(@Args() args: FindUniqueVerificationArgs) {
    return this.verificationsService.remove(args)
  }
}
</file>

<file path="apps/api/src/models/verifications/graphql/verifications.service.ts">
import { Injectable } from '@nestjs/common'
import {
  FindManyVerificationArgs,
  FindUniqueVerificationArgs,
} from './dtos/find.args'
import { PrismaService } from 'src/common/prisma/prisma.service'
import { CreateVerificationInput } from './dtos/create-verification.input'
import { UpdateVerificationInput } from './dtos/update-verification.input'

@Injectable()
export class VerificationsService {
  constructor(private readonly prisma: PrismaService) {}
  create(createVerificationInput: CreateVerificationInput, adminId: string) {
    return this.prisma.verification.create({
      data: { ...createVerificationInput, adminId },
    })
  }

  findAll(args: FindManyVerificationArgs) {
    return this.prisma.verification.findMany(args)
  }

  findOne(args: FindUniqueVerificationArgs) {
    return this.prisma.verification.findUnique(args)
  }

  update(updateVerificationInput: UpdateVerificationInput) {
    const { garageId, ...data } = updateVerificationInput
    return this.prisma.verification.update({
      where: { garageId },
      data: data,
    })
  }

  remove(args: FindUniqueVerificationArgs) {
    return this.prisma.verification.delete(args)
  }
}
</file>

<file path="apps/api/src/models/verifications/rest/dtos/create.dto.ts">
import { OmitType } from '@nestjs/swagger'
import { VerificationEntity } from '../entity/verification.entity'

export class CreateVerification extends OmitType(VerificationEntity, [
  'createdAt',
  'updatedAt',
]) {}
</file>

<file path="apps/api/src/models/verifications/rest/dtos/query.dto.ts">
import { IsIn, IsOptional } from 'class-validator'
import { Prisma } from '@prisma/client'
import { BaseQueryDto } from 'src/common/dtos/common.dto'

export class VerificationQueryDto extends BaseQueryDto {
  @IsOptional()
  @IsIn(Object.values(Prisma.VerificationScalarFieldEnum))
  sortBy?: string

  @IsOptional()
  @IsIn(Object.values(Prisma.VerificationScalarFieldEnum))
  searchBy?: string
}
</file>

<file path="apps/api/src/models/verifications/rest/dtos/update.dto.ts">
import { PartialType } from '@nestjs/swagger'
import { CreateVerification } from './create.dto'
import { Verification } from '@prisma/client'

export class UpdateVerification extends PartialType(CreateVerification) {
  garageId: Verification['garageId']
}
</file>

<file path="apps/api/src/models/verifications/rest/entity/verification.entity.ts">
import { Field } from '@nestjs/graphql'
import { Verification } from '@prisma/client'
import { IsDate, IsString, IsInt } from 'class-validator'
import { RestrictProperties } from 'src/common/dtos/common.input'

export class VerificationEntity
  implements RestrictProperties<VerificationEntity, Verification>
{
  createdAt: Date
  updatedAt: Date
  verified: boolean
  adminId: string
  garageId: number
}
</file>

<file path="apps/api/src/models/verifications/rest/verifications.controller.ts">
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common'

import { PrismaService } from 'src/common/prisma/prisma.service'
import { ApiTags } from '@nestjs/swagger'
import { CreateVerification } from './dtos/create.dto'
import { VerificationQueryDto } from './dtos/query.dto'
import { UpdateVerification } from './dtos/update.dto'
import {
  ApiBearerAuth,
  ApiCreatedResponse,
  ApiOkResponse,
} from '@nestjs/swagger'
import { VerificationEntity } from './entity/verification.entity'
import { AllowAuthenticated } from 'src/common/auth/auth.decorator'

@ApiTags('verifications')
@Controller('verifications')
export class VerificationsController {
  constructor(private readonly prisma: PrismaService) {}

  @AllowAuthenticated('admin')
  @ApiBearerAuth()
  @ApiCreatedResponse({ type: VerificationEntity })
  @Post()
  create(@Body() createVerificationDto: CreateVerification) {
    return this.prisma.verification.create({ data: createVerificationDto })
  }

  @ApiOkResponse({ type: [VerificationEntity] })
  @Get()
  findAll(@Query() { skip, take, order, sortBy }: VerificationQueryDto) {
    return this.prisma.verification.findMany({
      ...(skip ? { skip: +skip } : null),
      ...(take ? { take: +take } : null),
      ...(sortBy ? { orderBy: { [sortBy]: order || 'asc' } } : null),
    })
  }

  @ApiOkResponse({ type: VerificationEntity })
  @Get(':garageId')
  findOne(@Param('garageId') garageId: number) {
    return this.prisma.verification.findUnique({ where: { garageId } })
  }

  @ApiOkResponse({ type: VerificationEntity })
  @ApiBearerAuth()
  @AllowAuthenticated('admin')
  @Patch(':garageId')
  async update(
    @Param('garageId') garageId: number,
    @Body() updateVerificationDto: UpdateVerification,
  ) {
    return this.prisma.verification.update({
      where: { garageId },
      data: updateVerificationDto,
    })
  }

  @ApiBearerAuth()
  @AllowAuthenticated('admin')
  @Delete(':garageId')
  async remove(@Param('garageId') garageId: number) {
    return this.prisma.verification.delete({ where: { garageId } })
  }
}
</file>

<file path="apps/api/src/models/verifications/verifications.module.ts">
import { Module } from '@nestjs/common'
import { VerificationsService } from './graphql/verifications.service'
import { VerificationsResolver } from './graphql/verifications.resolver'
import { VerificationsController } from './rest/verifications.controller'

@Module({
  providers: [VerificationsResolver, VerificationsService],
  exports: [VerificationsService],
  controllers: [VerificationsController],
})
export class VerificationsModule {}
</file>

<file path="apps/api/src/app.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing'
import { AppController } from './app.controller'
import { AppService } from './app.service'

describe('AppController', () => {
  let appController: AppController

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile()

    appController = app.get<AppController>(AppController)
  })

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!')
    })
  })
})
</file>

<file path="apps/api/src/app.controller.ts">
import { Controller, Get } from '@nestjs/common'
import { AppService } from './app.service'

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello()
  }
}
</file>

<file path="apps/api/src/app.module.ts">
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { GraphQLModule } from '@nestjs/graphql'
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo'
import { join } from 'path'
import { ConfigModule } from '@nestjs/config'
import { PrismaModule } from './common/prisma/prisma.module'
import { UsersModule } from './models/users/users.module'
import { JwtModule } from '@nestjs/jwt'
import { AdminsModule } from './models/admins/admins.module'
import { CustomersModule } from './models/customers/customers.module'
import { ManagersModule } from './models/managers/managers.module'
import { ValetsModule } from './models/valets/valets.module'
import { CompaniesModule } from './models/companies/companies.module'
import { GaragesModule } from './models/garages/garages.module'
import { AddressesModule } from './models/addresses/addresses.module'
import { SlotsModule } from './models/slots/slots.module'
import { BookingsModule } from './models/bookings/bookings.module'
import { ValetAssignmentsModule } from './models/valet-assignments/valet-assignments.module'
import { BookingTimelinesModule } from './models/booking-timelines/booking-timelines.module'
import { ReviewsModule } from './models/reviews/reviews.module'
import { VerificationsModule } from './models/verifications/verifications.module'
import { StripeModule } from './models/stripe/stripe.module'

// Todo: Move this to util lib.
const MAX_AGE = 24 * 60 * 60

@Module({
  imports: [
    ConfigModule.forRoot(),
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: MAX_AGE },
    }),
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      introspection: true,
      fieldResolverEnhancers: ['guards'],
      autoSchemaFile: join(process.cwd(), 'src/schema.gql'),
      //   buildSchemaOptions: {
      //      numberScalarMode: 'integer',
      //   },
    }),

    PrismaModule,

    StripeModule,

    UsersModule,
    AdminsModule,
    CustomersModule,
    ManagersModule,
    ValetsModule,
    CompaniesModule,
    GaragesModule,
    AddressesModule,
    SlotsModule,
    BookingsModule,
    ValetAssignmentsModule,
    BookingTimelinesModule,
    ReviewsModule,
    VerificationsModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
</file>

<file path="apps/api/src/app.service.ts">
import { Injectable } from '@nestjs/common'

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World! '
  }
}
</file>

<file path="apps/api/src/main.ts">
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger'
const port = process.env.PORT || 3000

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  app.enableCors()

  const config = new DocumentBuilder()
    .setTitle('Autospace | Karthick Ragavendran')
    .setDescription(
      `The Autospace API.
<h2>Looking for the graphql api?</h2>
Go to <a href="/graphql" target="_blank">/graphql</a>.
Or,
You might also need to use the <a target="_blank" href="https://studio.apollographql.com/sandbox/explorer?endpoint=http://localhost:3000/graphql&document=query users{users{ uid }}
">Apollo explorer</a> for a greater experience.

      `,
    )
    .setVersion('0.1')
    .addBearerAuth()
    .build()

  const document = SwaggerModule.createDocument(app, config)
  SwaggerModule.setup('/', app, document)

  await app.listen(port, '0.0.0.0')
}
bootstrap()
</file>

<file path="apps/api/src/schema.gql">
# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type User {
  image: String
  name: String
  uid: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  admin: Admin
  manager: Manager
  valet: Valet
  customer: Customer
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type AuthProvider {
  type: AuthProviderType!
  uid: String!
}

enum AuthProviderType {
  GOOGLE
  CREDENTIALS
}

type AggregateCountOutput {
  count: Float!
}

type LoginOutput {
  token: String!
  user: User!
}

type Admin {
  uid: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User
  verifications: [Verification!]!
  verificationsCount: Float!
}

type Manager {
  displayName: String
  uid: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  companyId: Float!
  company: Company
}

type Valet {
  image: String
  companyId: Float
  uid: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  displayName: String!
  licenceID: String!
}

type Customer {
  displayName: String
  uid: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User
  bookings: [Booking!]!
}

type Verification {
  createdAt: DateTime!
  garageId: Float!
  updatedAt: DateTime!
  verified: Boolean!
  adminId: String!
}

type Booking {
  pricePerHour: Float
  totalPrice: Float
  phoneNumber: String
  passcode: String
  status: BookingStatus!
  id: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  startTime: DateTime!
  endTime: DateTime!
  vehicleNumber: String!
  slotId: Float!
  customerId: String!
  slot: Slot!
  customer: Customer!
  bookingTimeline: [BookingTimeline!]!
  valetAssignment: ValetAssignment
}

enum BookingStatus {
  BOOKED
  VALET_ASSIGNED_FOR_CHECK_IN
  VALET_PICKED_UP
  CHECKED_IN
  VALET_ASSIGNED_FOR_CHECK_OUT
  CHECKED_OUT
  VALET_RETURNED
}

type Company {
  displayName: String
  description: String
  id: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  garages: [Garage!]!
  managers: [Manager!]!
}

type Garage {
  displayName: String
  description: String
  id: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  images: [String!]!
  companyId: Float!
  slotCounts: [SlotTypeCount!]!
  availableSlots(slotsFilter: SlotWhereInput, dateFilter: DateFilterInput!): [MinimalSlotGroupBy!]!
  verification: Verification
  company: Company!
  address: Address
  slots: [Slot!]!
}

input SlotWhereInput {
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  pricePerHour: FloatFilter
  length: IntFilter
  width: IntFilter
  height: IntFilter
  type: EnumSlotTypeFilter
  garageId: IntFilter
  Garage: GarageRelationFilter
  Bookings: BookingListRelationFilter
  AND: [SlotWhereInput!]
  OR: [SlotWhereInput!]
  NOT: [SlotWhereInput!]
}

input IntFilter {
  equals: Float
  lt: Float
  lte: Float
  gt: Float
  gte: Float
}

input DateTimeFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
}

input StringFilter {
  mode: QueryMode
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: String
}

enum QueryMode {
  default
  insensitive
}

input FloatFilter {
  equals: Float
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: Float
}

input EnumSlotTypeFilter {
  equals: SlotType
  in: [SlotType!]
  notIn: [SlotType!]
  not: SlotType
}

enum SlotType {
  CAR
  HEAVY
  BIKE
  BICYCLE
}

input GarageRelationFilter {
  is: GarageWhereInput
  isNot: GarageWhereInput
}

input GarageWhereInput {
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  description: StringFilter
  images: StringListFilter
  companyId: IntFilter
  Company: CompanyRelationFilter
  Address: AddressRelationFilter
  Verification: VerificationRelationFilter
  Reviews: ReviewListRelationFilter
  Slots: SlotListRelationFilter
  AND: [GarageWhereInput!]
  OR: [GarageWhereInput!]
  NOT: [GarageWhereInput!]
}

input StringListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input CompanyRelationFilter {
  is: CompanyWhereInput
  isNot: CompanyWhereInput
}

input CompanyWhereInput {
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  description: StringFilter
  Garages: GarageListRelationFilter
  Managers: ManagerListRelationFilter
  Valets: ValetListRelationFilter
  AND: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
}

input GarageListRelationFilter {
  every: GarageWhereInput
  some: GarageWhereInput
  none: GarageWhereInput
}

input ManagerListRelationFilter {
  every: ManagerWhereInput
  some: ManagerWhereInput
  none: ManagerWhereInput
}

input ManagerWhereInput {
  User: UserRelationFilter
  uid: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  companyId: IntFilter
  Company: CompanyRelationFilter
  BookingTimeline: BookingTimelineListRelationFilter
  AND: [ManagerWhereInput!]
  OR: [ManagerWhereInput!]
  NOT: [ManagerWhereInput!]
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  Customer: CustomerRelationFilter
  Manager: ManagerRelationFilter
  Valet: ValetRelationFilter
  uid: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  name: StringFilter
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input CustomerRelationFilter {
  is: CustomerWhereInput
  isNot: CustomerWhereInput
}

input CustomerWhereInput {
  User: UserRelationFilter
  uid: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  Bookings: BookingListRelationFilter
  Reviews: ReviewListRelationFilter
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input BookingListRelationFilter {
  every: BookingWhereInput
  some: BookingWhereInput
  none: BookingWhereInput
}

input BookingWhereInput {
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  pricePerHour: FloatFilter
  totalPrice: FloatFilter
  startTime: DateTimeFilter
  endTime: DateTimeFilter
  vehicleNumber: StringFilter
  phoneNumber: StringFilter
  passcode: StringFilter
  status: EnumBookingStatusFilter
  slotId: IntFilter
  customerId: StringFilter
  ValetAssignment: ValetAssignmentRelationFilter
  Customer: CustomerRelationFilter
  Slot: SlotRelationFilter
  BookingTimeline: BookingTimelineListRelationFilter
  AND: [BookingWhereInput!]
  OR: [BookingWhereInput!]
  NOT: [BookingWhereInput!]
}

input EnumBookingStatusFilter {
  equals: BookingStatus
  in: [BookingStatus!]
  notIn: [BookingStatus!]
  not: BookingStatus
}

input ValetAssignmentRelationFilter {
  is: ValetAssignmentWhereInput
  isNot: ValetAssignmentWhereInput
}

input ValetAssignmentWhereInput {
  bookingId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  pickupLat: FloatFilter
  pickupLng: FloatFilter
  returnLat: FloatFilter
  returnLng: FloatFilter
  pickupValetId: StringFilter
  returnValetId: StringFilter
  PickupValet: ValetRelationFilter
  ReturnValet: ValetRelationFilter
  Booking: BookingRelationFilter
  AND: [ValetAssignmentWhereInput!]
  OR: [ValetAssignmentWhereInput!]
  NOT: [ValetAssignmentWhereInput!]
}

input ValetRelationFilter {
  is: ValetWhereInput
  isNot: ValetWhereInput
}

input ValetWhereInput {
  User: UserRelationFilter
  uid: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  displayName: StringFilter
  image: StringFilter
  licenceID: StringFilter
  companyId: IntFilter
  Company: CompanyRelationFilter
  BookingTimeline: BookingTimelineListRelationFilter
  PickupAssignments: ValetAssignmentListRelationFilter
  ReturnAssignments: ValetAssignmentListRelationFilter
  AND: [ValetWhereInput!]
  OR: [ValetWhereInput!]
  NOT: [ValetWhereInput!]
}

input BookingTimelineListRelationFilter {
  every: BookingTimelineWhereInput
  some: BookingTimelineWhereInput
  none: BookingTimelineWhereInput
}

input BookingTimelineWhereInput {
  status: BookingStatus
  id: IntFilter
  timestamp: DateTimeFilter
  bookingId: IntFilter
  valetId: StringFilter
  managerId: StringFilter
  Booking: BookingRelationFilter
  Valet: ValetRelationFilter
  Manager: ManagerRelationFilter
  AND: [BookingTimelineWhereInput!]
  OR: [BookingTimelineWhereInput!]
  NOT: [BookingTimelineWhereInput!]
}

input BookingRelationFilter {
  is: BookingWhereInput
  isNot: BookingWhereInput
}

input ManagerRelationFilter {
  is: ManagerWhereInput
  isNot: ManagerWhereInput
}

input ValetAssignmentListRelationFilter {
  every: ValetAssignmentWhereInput
  some: ValetAssignmentWhereInput
  none: ValetAssignmentWhereInput
}

input SlotRelationFilter {
  is: SlotWhereInput
  isNot: SlotWhereInput
}

input ReviewListRelationFilter {
  every: ReviewWhereInput
  some: ReviewWhereInput
  none: ReviewWhereInput
}

input ReviewWhereInput {
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  rating: IntFilter
  comment: StringFilter
  customerId: StringFilter
  garageId: IntFilter
  Customer: CustomerRelationFilter
  Garage: GarageRelationFilter
  AND: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
}

input ValetListRelationFilter {
  every: ValetWhereInput
  some: ValetWhereInput
  none: ValetWhereInput
}

input AddressRelationFilter {
  is: AddressWhereInput
  isNot: AddressWhereInput
}

input AddressWhereInput {
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  address: StringFilter
  lat: FloatFilter
  lng: FloatFilter
  garageId: IntFilter
  Garage: GarageRelationFilter
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
}

input VerificationRelationFilter {
  is: VerificationWhereInput
  isNot: VerificationWhereInput
}

input VerificationWhereInput {
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  verified: BoolFilter
  adminId: StringFilter
  garageId: IntFilter
  Admin: AdminRelationFilter
  Garage: GarageRelationFilter
  AND: [VerificationWhereInput!]
  OR: [VerificationWhereInput!]
  NOT: [VerificationWhereInput!]
}

input BoolFilter {
  equals: Boolean
  not: Boolean
}

input AdminRelationFilter {
  is: AdminWhereInput
  isNot: AdminWhereInput
}

input AdminWhereInput {
  Verifications: VerificationListRelationFilter
  uid: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  User: UserRelationFilter
  AND: [AdminWhereInput!]
  OR: [AdminWhereInput!]
  NOT: [AdminWhereInput!]
}

input VerificationListRelationFilter {
  every: VerificationWhereInput
  some: VerificationWhereInput
  none: VerificationWhereInput
}

input SlotListRelationFilter {
  every: SlotWhereInput
  some: SlotWhereInput
  none: SlotWhereInput
}

input DateFilterInput {
  start: String!
  end: String!
}

type SlotTypeCount {
  type: SlotType!
  count: Float
}

type Address {
  garageId: Float
  id: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  address: String!
  lat: Float!
  lng: Float!
  garage: Garage
}

type Slot {
  displayName: String
  length: Float
  width: Float
  height: Float
  type: SlotType!
  id: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  pricePerHour: Float!
  garageId: Float!
  garage: Garage!
  bookings: [Booking!]!
}

type ReturnCount {
  count: Float!
}

type MinimalSlotGroupBy {
  type: SlotType!
  pricePerHour: Float!
  count: Float!
}

type ValetAssignment {
  returnLat: Float
  returnLng: Float
  pickupValetId: String
  returnValetId: String
  bookingId: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  pickupLat: Float!
  pickupLng: Float!
  pickupValet: Valet
  returnValet: Valet
}

type BookingTimeline {
  status: BookingStatus!
  valetId: String
  managerId: String
  id: Float!
  timestamp: DateTime!
  bookingId: Float!
}

type Review {
  comment: String
  id: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  rating: Float!
  customerId: String!
  garageId: Float!
}

type Query {
  whoami: User!
  users(distinct: [UserScalarFieldEnum!], where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Float, skip: Float): [User!]!
  user(where: UserWhereUniqueInput!): User!
  getAuthProvider(uid: String!): AuthProvider
  admins(distinct: [AdminScalarFieldEnum!], where: AdminWhereInput, orderBy: [AdminOrderByWithRelationInput!], cursor: AdminWhereUniqueInput, take: Float, skip: Float): [Admin!]!
  admin(where: AdminWhereUniqueInput!): Admin!
  adminMe: Admin!
  adminsCount(where: AdminWhereInput): Float!
  customers(distinct: [CustomerScalarFieldEnum!], where: CustomerWhereInput, orderBy: [CustomerOrderByWithRelationInput!], cursor: CustomerWhereUniqueInput, take: Float, skip: Float): [Customer!]!
  customer(where: CustomerWhereUniqueInput!): Customer!
  managers(distinct: [ManagerScalarFieldEnum!], where: ManagerWhereInput, orderBy: [ManagerOrderByWithRelationInput!], cursor: ManagerWhereUniqueInput, take: Float, skip: Float): [Manager!]!
  manager(where: ManagerWhereUniqueInput!): Manager!
  valets(distinct: [ValetScalarFieldEnum!], where: ValetWhereInput, orderBy: [ValetOrderByWithRelationInput!], cursor: ValetWhereUniqueInput, take: Float, skip: Float): [Valet!]!
  companyValets(distinct: [ValetScalarFieldEnum!], where: ValetWhereInput, orderBy: [ValetOrderByWithRelationInput!], cursor: ValetWhereUniqueInput, take: Float, skip: Float): [Valet!]!
  companyValetsTotal(where: ValetWhereInput): Float!
  valet(where: ValetWhereUniqueInput!): Valet!
  valetMe: Valet
  valetPickups(take: Float, skip: Float): [Booking!]!
  valetPickupsTotal: Float!
  valetDrops(take: Float, skip: Float): [Booking!]!
  valetDropsTotal: Float!
  companies(distinct: [CompanyScalarFieldEnum!], where: CompanyWhereInput, orderBy: [CompanyOrderByWithRelationInput!], cursor: CompanyWhereUniqueInput, take: Float, skip: Float): [Company!]!
  myCompany: Company!
  company(where: CompanyWhereUniqueInput!): Company!
  garages(distinct: [GarageScalarFieldEnum!], where: GarageWhereInput, orderBy: [GarageOrderByWithRelationInput!], cursor: GarageWhereUniqueInput, take: Float, skip: Float): [Garage!]!
  garage(where: GarageWhereUniqueInput!): Garage!
  searchGarages(dateFilter: DateFilterInput!, locationFilter: LocationFilterInput!, slotsFilter: SlotWhereInput, garageFilter: GarageFilter): [Garage!]!
  garagesCount(where: GarageWhereInput): AggregateCountOutput!
  addresses(distinct: [AddressScalarFieldEnum!], where: AddressWhereInput, orderBy: [AddressOrderByWithRelationInput!], cursor: AddressWhereUniqueInput, take: Float, skip: Float): [Address!]!
  address(where: AddressWhereUniqueInput!): Address!
  slots(distinct: [SlotScalarFieldEnum!], where: SlotWhereInput, orderBy: [SlotOrderByWithRelationInput!], cursor: SlotWhereUniqueInput, take: Float, skip: Float): [Slot!]!
  slot(where: SlotWhereUniqueInput!): Slot!
  bookings(distinct: [BookingScalarFieldEnum!], where: BookingWhereInput, orderBy: [BookingOrderByWithRelationInput!], cursor: BookingWhereUniqueInput, take: Float, skip: Float): [Booking!]!
  bookingsForValet(distinct: [BookingScalarFieldEnum!], where: BookingWhereInput, orderBy: [BookingOrderByWithRelationInput!], cursor: BookingWhereUniqueInput, take: Float, skip: Float): [Booking!]!
  bookingsForCustomer(distinct: [BookingScalarFieldEnum!], where: BookingWhereInput, orderBy: [BookingOrderByWithRelationInput!], cursor: BookingWhereUniqueInput, take: Float, skip: Float): [Booking!]!
  bookingsForGarage(distinct: [BookingScalarFieldEnum!], where: BookingWhereInput, orderBy: [BookingOrderByWithRelationInput!], cursor: BookingWhereUniqueInput, take: Float, skip: Float): [Booking!]!
  bookingsCount(where: BookingWhereInput): AggregateCountOutput!
  booking(where: BookingWhereUniqueInput!): Booking!
  valetAssignments(distinct: [ValetAssignmentScalarFieldEnum!], where: ValetAssignmentWhereInput, orderBy: [ValetAssignmentOrderByWithRelationInput!], cursor: ValetAssignmentWhereUniqueInput, take: Float, skip: Float): [ValetAssignment!]!
  valetAssignment(where: ValetAssignmentWhereUniqueInput!): ValetAssignment!
  bookingTimelines(distinct: [BookingTimelineScalarFieldEnum!], where: BookingTimelineWhereInput, orderBy: [BookingTimelineOrderByWithRelationInput!], cursor: BookingTimelineWhereUniqueInput, take: Float, skip: Float): [BookingTimeline!]!
  bookingTimeline(where: BookingTimelineWhereUniqueInput!): BookingTimeline!
  reviews(distinct: [ReviewScalarFieldEnum!], where: ReviewWhereInput, orderBy: [ReviewOrderByWithRelationInput!], cursor: ReviewWhereUniqueInput, take: Float, skip: Float): [Review!]!
  review(where: ReviewWhereUniqueInput!): Review!
  verifications(distinct: [VerificationScalarFieldEnum!], where: VerificationWhereInput, orderBy: [VerificationOrderByWithRelationInput!], cursor: VerificationWhereUniqueInput, take: Float, skip: Float): [Verification!]!
  verification(where: VerificationWhereUniqueInput!): Verification!
}

enum UserScalarFieldEnum {
  uid
  createdAt
  updatedAt
  name
  image
}

input UserOrderByWithRelationInput {
  uid: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  name: SortOrder
  Customer: CustomerOrderByWithRelationInput
  Manager: ManagerOrderByWithRelationInput
  Valet: ValetOrderByWithRelationInput
}

enum SortOrder {
  asc
  desc
}

input CustomerOrderByWithRelationInput {
  uid: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  displayName: SortOrder
  User: UserOrderByWithRelationInput
  Bookings: BookingOrderByRelationAggregateInput
  Reviews: ReviewOrderByRelationAggregateInput
}

input BookingOrderByRelationAggregateInput {
  _count: SortOrder
}

input ReviewOrderByRelationAggregateInput {
  _count: SortOrder
}

input ManagerOrderByWithRelationInput {
  uid: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  displayName: SortOrder
  companyId: SortOrder
  User: UserOrderByWithRelationInput
  Company: CompanyOrderByWithRelationInput
  BookingTimeline: BookingTimelineOrderByRelationAggregateInput
}

input CompanyOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  displayName: SortOrder
  description: SortOrder
  Garages: GarageOrderByRelationAggregateInput
  Managers: ManagerOrderByRelationAggregateInput
  Valets: ValetOrderByRelationAggregateInput
}

input GarageOrderByRelationAggregateInput {
  _count: SortOrder
}

input ManagerOrderByRelationAggregateInput {
  _count: SortOrder
}

input ValetOrderByRelationAggregateInput {
  _count: SortOrder
}

input BookingTimelineOrderByRelationAggregateInput {
  _count: SortOrder
}

input ValetOrderByWithRelationInput {
  uid: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  displayName: SortOrder
  image: SortOrder
  licenceID: SortOrder
  companyId: SortOrder
  User: UserOrderByWithRelationInput
  Company: CompanyOrderByWithRelationInput
  BookingTimeline: BookingTimelineOrderByRelationAggregateInput
  PickupAssignments: ValetAssignmentOrderByRelationAggregateInput
  ReturnAssignments: ValetAssignmentOrderByRelationAggregateInput
}

input ValetAssignmentOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserWhereUniqueInput {
  uid: String!
}

enum AdminScalarFieldEnum {
  uid
  createdAt
  updatedAt
}

input AdminOrderByWithRelationInput {
  uid: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  Verifications: VerificationOrderByRelationAggregateInput
  User: UserOrderByWithRelationInput
}

input VerificationOrderByRelationAggregateInput {
  _count: SortOrder
}

input AdminWhereUniqueInput {
  uid: String!
}

enum CustomerScalarFieldEnum {
  uid
  createdAt
  updatedAt
  displayName
}

input CustomerWhereUniqueInput {
  uid: String!
}

enum ManagerScalarFieldEnum {
  uid
  createdAt
  updatedAt
  displayName
  companyId
}

input ManagerWhereUniqueInput {
  uid: String!
}

enum ValetScalarFieldEnum {
  uid
  createdAt
  updatedAt
  displayName
  image
  licenceID
  companyId
}

input ValetWhereUniqueInput {
  uid: String!
}

enum CompanyScalarFieldEnum {
  id
  createdAt
  updatedAt
  displayName
  description
}

input CompanyWhereUniqueInput {
  id: Float!
}

enum GarageScalarFieldEnum {
  id
  createdAt
  updatedAt
  displayName
  description
  images
  companyId
}

input GarageOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  displayName: SortOrder
  description: SortOrder
  images: SortOrder
  companyId: SortOrder
  Company: CompanyOrderByWithRelationInput
  Address: AddressOrderByWithRelationInput
  Verification: VerificationOrderByWithRelationInput
  Reviews: ReviewOrderByRelationAggregateInput
  Slots: SlotOrderByRelationAggregateInput
}

input AddressOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  address: SortOrder
  lat: SortOrder
  lng: SortOrder
  garageId: SortOrder
  Garage: GarageOrderByWithRelationInput
}

input VerificationOrderByWithRelationInput {
  createdAt: SortOrder
  updatedAt: SortOrder
  verified: SortOrder
  adminId: SortOrder
  garageId: SortOrder
  Admin: AdminOrderByWithRelationInput
  Garage: GarageOrderByWithRelationInput
}

input SlotOrderByRelationAggregateInput {
  _count: SortOrder
}

input GarageWhereUniqueInput {
  id: Float!
}

input LocationFilterInput {
  ne_lat: Float!
  ne_lng: Float!
  sw_lat: Float!
  sw_lng: Float!
}

input GarageFilter {
  where: GarageWhereInput
  orderBy: [GarageOrderByWithRelationInput!]
  take: Float
  skip: Float
}

enum AddressScalarFieldEnum {
  id
  createdAt
  updatedAt
  address
  lat
  lng
  garageId
}

input AddressWhereUniqueInput {
  id: Float!
}

enum SlotScalarFieldEnum {
  id
  createdAt
  updatedAt
  displayName
  pricePerHour
  length
  width
  height
  type
  garageId
}

input SlotOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  displayName: SortOrder
  pricePerHour: SortOrder
  length: SortOrder
  width: SortOrder
  height: SortOrder
  type: SortOrder
  garageId: SortOrder
  Garage: GarageOrderByWithRelationInput
  Bookings: BookingOrderByRelationAggregateInput
}

input SlotWhereUniqueInput {
  id: Float!
}

enum BookingScalarFieldEnum {
  id
  createdAt
  updatedAt
  pricePerHour
  totalPrice
  startTime
  endTime
  vehicleNumber
  phoneNumber
  passcode
  status
  slotId
  customerId
}

input BookingOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  pricePerHour: SortOrder
  totalPrice: SortOrder
  startTime: SortOrder
  endTime: SortOrder
  vehicleNumber: SortOrder
  phoneNumber: SortOrder
  passcode: SortOrder
  status: SortOrder
  slotId: SortOrder
  customerId: SortOrder
  ValetAssignment: ValetAssignmentOrderByWithRelationInput
  Customer: CustomerOrderByWithRelationInput
  Slot: SlotOrderByWithRelationInput
  BookingTimeline: BookingTimelineOrderByRelationAggregateInput
}

input ValetAssignmentOrderByWithRelationInput {
  bookingId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  pickupLat: SortOrder
  pickupLng: SortOrder
  returnLat: SortOrder
  returnLng: SortOrder
  pickupValetId: SortOrder
  returnValetId: SortOrder
  PickupValet: ValetOrderByWithRelationInput
  ReturnValet: ValetOrderByWithRelationInput
  Booking: BookingOrderByWithRelationInput
}

input BookingWhereUniqueInput {
  id: Float!
}

enum ValetAssignmentScalarFieldEnum {
  bookingId
  createdAt
  updatedAt
  pickupLat
  pickupLng
  returnLat
  returnLng
  pickupValetId
  returnValetId
}

input ValetAssignmentWhereUniqueInput {
  bookingId: Float!
}

enum BookingTimelineScalarFieldEnum {
  id
  timestamp
  status
  bookingId
  valetId
  managerId
}

input BookingTimelineOrderByWithRelationInput {
  id: SortOrder
  timestamp: SortOrder
  status: SortOrder
  bookingId: SortOrder
  valetId: SortOrder
  managerId: SortOrder
  Booking: BookingOrderByWithRelationInput
  Valet: ValetOrderByWithRelationInput
  Manager: ManagerOrderByWithRelationInput
}

input BookingTimelineWhereUniqueInput {
  id: Float!
}

enum ReviewScalarFieldEnum {
  id
  createdAt
  updatedAt
  rating
  comment
  customerId
  garageId
}

input ReviewOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  rating: SortOrder
  comment: SortOrder
  customerId: SortOrder
  garageId: SortOrder
  Customer: CustomerOrderByWithRelationInput
  Garage: GarageOrderByWithRelationInput
}

input ReviewWhereUniqueInput {
  id: Float!
}

enum VerificationScalarFieldEnum {
  createdAt
  updatedAt
  verified
  adminId
  garageId
}

input VerificationWhereUniqueInput {
  garageId: Float!
}

type Mutation {
  registerWithCredentials(registerWithCredentialsInput: RegisterWithCredentialsInput!): User!
  registerWithProvider(registerWithProviderInput: RegisterWithProviderInput!): User!
  login(loginInput: LoginInput!): LoginOutput!
  updateUser(updateUserInput: UpdateUserInput!): User!
  removeUser(where: UserWhereUniqueInput!): User!
  createAdmin(createAdminInput: CreateAdminInput!): Admin!
  updateAdmin(updateAdminInput: UpdateAdminInput!): Admin!
  removeAdmin(where: AdminWhereUniqueInput!): Admin!
  createCustomer(createCustomerInput: CreateCustomerInput!): Customer!
  updateCustomer(updateCustomerInput: UpdateCustomerInput!): Customer!
  removeCustomer(where: CustomerWhereUniqueInput!): Customer!
  createManager(createManagerInput: CreateManagerInput!): Manager!
  updateManager(updateManagerInput: UpdateManagerInput!): Manager!
  removeManager(where: ManagerWhereUniqueInput!): Manager!
  createValet(createValetInput: CreateValetInput!): Valet!
  assignValet(bookingId: Float!, status: String!): Booking!
  updateValet(updateValetInput: UpdateValetInput!): Valet!
  removeValet(where: ValetWhereUniqueInput!): Valet!
  createCompany(createCompanyInput: CreateCompanyInput!): Company!
  updateCompany(updateCompanyInput: UpdateCompanyInput!): Company!
  removeCompany(where: CompanyWhereUniqueInput!): Company!
  createGarage(createGarageInput: CreateGarageInput!): Garage!
  updateGarage(updateGarageInput: UpdateGarageInput!): Garage!
  removeGarage(where: GarageWhereUniqueInput!): Garage!
  createAddress(createAddressInput: CreateAddressInput!): Address!
  updateAddress(updateAddressInput: UpdateAddressInput!): Address!
  removeAddress(where: AddressWhereUniqueInput!): Address!
  createSlot(createSlotInput: CreateSlotInput!): Slot!
  createManySlots(createSlotInput: CreateSlotInput!, count: Float!): ReturnCount!
  updateSlot(updateSlotInput: UpdateSlotInput!): Slot!
  removeSlot(where: SlotWhereUniqueInput!): Slot!
  createBooking(createBookingInput: CreateBookingInput!): Booking!
  updateBooking(updateBookingInput: UpdateBookingInput!): Booking!
  removeBooking(where: BookingWhereUniqueInput!): Booking!
  createValetAssignment(createValetAssignmentInput: CreateValetAssignmentInput!): ValetAssignment!
  updateValetAssignment(updateValetAssignmentInput: UpdateValetAssignmentInput!): ValetAssignment!
  removeValetAssignment(where: ValetAssignmentWhereUniqueInput!): ValetAssignment!
  createBookingTimeline(createBookingTimelineInput: CreateBookingTimelineInput!): BookingTimeline!
  updateBookingTimeline(updateBookingTimelineInput: UpdateBookingTimelineInput!): BookingTimeline!
  removeBookingTimeline(where: BookingTimelineWhereUniqueInput!): BookingTimeline!
  createReview(createReviewInput: CreateReviewInput!): Review!
  updateReview(updateReviewInput: UpdateReviewInput!): Review!
  removeReview(where: ReviewWhereUniqueInput!): Review!
  createVerification(createVerificationInput: CreateVerificationInput!): Verification!
  updateVerification(updateVerificationInput: UpdateVerificationInput!): Verification!
  removeVerification(where: VerificationWhereUniqueInput!): Verification!
}

input RegisterWithCredentialsInput {
  image: String
  name: String
  email: String!
  password: String!
}

input RegisterWithProviderInput {
  image: String
  name: String
  uid: String!
  type: AuthProviderType!
}

input LoginInput {
  email: String!
  password: String!
}

input UpdateUserInput {
  uid: String!
}

input CreateAdminInput {
  uid: String!
}

input UpdateAdminInput {
  uid: String!
}

input CreateCustomerInput {
  displayName: String
  uid: String!
}

input UpdateCustomerInput {
  displayName: String
  uid: String!
}

input CreateManagerInput {
  displayName: String
  uid: String!
}

input UpdateManagerInput {
  displayName: String
  uid: String!
}

input CreateValetInput {
  image: String
  companyId: Float
  uid: String!
  displayName: String!
  licenceID: String!
}

input UpdateValetInput {
  image: String
  companyId: Float
  uid: String!
  displayName: String
  licenceID: String
}

input CreateCompanyInput {
  displayName: String
  description: String
  managerId: String!
  managerName: String
}

input UpdateCompanyInput {
  displayName: String
  description: String
  managerId: String
  managerName: String
  id: Float!
}

input CreateGarageInput {
  displayName: String
  description: String
  images: [String!]!
  Address: CreateAddressInputWithoutGarageId!
  Slots: [CreateSlotInputWithoutGarageId!]!
}

input CreateAddressInputWithoutGarageId {
  address: String!
  lat: Float!
  lng: Float!
}

input CreateSlotInputWithoutGarageId {
  displayName: String
  length: Float
  width: Float
  height: Float
  type: SlotType!
  pricePerHour: Float!
  count: Float!
}

input UpdateGarageInput {
  displayName: String
  description: String
  images: [String!]
  Address: CreateAddressInputWithoutGarageId
  Slots: [CreateSlotInputWithoutGarageId!]
  id: Float!
}

input CreateAddressInput {
  garageId: Float
  address: String!
  lat: Float!
  lng: Float!
}

input UpdateAddressInput {
  garageId: Float
  address: String
  lat: Float
  lng: Float
  id: Float!
}

input CreateSlotInput {
  displayName: String
  length: Float
  width: Float
  height: Float
  type: SlotType!
  pricePerHour: Float!
  garageId: Float!
}

input UpdateSlotInput {
  displayName: String
  length: Float
  width: Float
  height: Float
  type: SlotType
  pricePerHour: Float
  garageId: Float
  id: Float!
}

input CreateBookingInput {
  phoneNumber: String
  startTime: DateTime!
  endTime: DateTime!
  vehicleNumber: String!
  customerId: String!
  type: SlotType!
  pricePerHour: Float
  totalPrice: Float
  garageId: Float!
  valetAssignment: CreateValetAssignmentInputWithoutBookingId
}

input CreateValetAssignmentInputWithoutBookingId {
  pickupLat: Float!
  pickupLng: Float!
  returnLat: Float
  returnLng: Float
}

input UpdateBookingInput {
  phoneNumber: String
  startTime: DateTime
  endTime: DateTime
  vehicleNumber: String
  customerId: String
  type: SlotType
  pricePerHour: Float
  totalPrice: Float
  garageId: Float
  valetAssignment: CreateValetAssignmentInputWithoutBookingId
  id: Float!
}

input CreateValetAssignmentInput {
  returnLat: Float
  returnLng: Float
  pickupValetId: String
  returnValetId: String
  bookingId: Float!
  pickupLat: Float!
  pickupLng: Float!
}

input UpdateValetAssignmentInput {
  returnLat: Float
  returnLng: Float
  pickupValetId: String
  returnValetId: String
  bookingId: Float!
  pickupLat: Float
  pickupLng: Float
}

input CreateBookingTimelineInput {
  status: BookingStatus!
  bookingId: Float!
}

input UpdateBookingTimelineInput {
  status: BookingStatus
  bookingId: Float
  id: Float!
}

input CreateReviewInput {
  comment: String
  rating: Float!
  customerId: String!
  garageId: Float!
}

input UpdateReviewInput {
  comment: String
  rating: Float
  customerId: String
  garageId: Float
  id: Float!
}

input CreateVerificationInput {
  garageId: Float!
  verified: Boolean!
}

input UpdateVerificationInput {
  garageId: Float!
  verified: Boolean
}
</file>

<file path="apps/api/test/app.e2e-spec.ts">
import { Test, TestingModule } from '@nestjs/testing'
import { INestApplication } from '@nestjs/common'
import * as request from 'supertest'
import { AppModule } from './../src/app.module'

describe('AppController (e2e)', () => {
  let app: INestApplication

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile()

    app = moduleFixture.createNestApplication()
    await app.init()
  })

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!')
  })
})
</file>

<file path="apps/api/test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
</file>

<file path="apps/api/.env.example">
DATABASE_URL="postgresql://postgres:password@localhost:2010/postgres?schema=public"

JWT_SECRET=

STRIPE_PUBLISHABLE_KEY=
STRIPE_SECRET_KEY=

STRIPE_SUCCESS_URL=http://localhost:3000/stripe/success?session_id={CHECKOUT_SESSION_ID}
STRIPE_CANCEL_URL=http://localhost:3001/booking-failed

BOOKINGS_REDIRECT_URL=http://localhost:3001/bookings
</file>

<file path="apps/api/.eslintrc.js">
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prettier/prettier': ['error', { semi: false }],
  },
}
</file>

<file path="apps/api/.gitignore">
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
</file>

<file path="apps/api/docker-compose.yml">
version: '3.8'

services:
  db:
    container_name: autospace_db
    image: postgres
    restart: always
    ports:
      - 2010:5432
    environment:
      POSTGRES_USER: postgres
      POSTGRES_DB: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - db_data_autospace:/var/lib/postgresql/data
volumes:
  db_data_autospace:
</file>

<file path="apps/api/nest-cli.json">
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true,
    "plugins": [{ "name": "@nestjs/graphql" }, { "name": "@nestjs/swagger" }]
  }
}
</file>

<file path="apps/api/package.json">
{
  "name": "@autospace/api",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/src/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "tsc": "tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "entity:gql": "npx nestjs-prisma-codegen --graphql",
    "entity:rest": "npx nestjs-prisma-codegen --rest",
    "entity:complete": "npx nestjs-prisma-codegen --complete"
  },
  "prisma": {
    "seed": "ts-node prisma/seed/index.ts"
  },
  "dependencies": {
    "@apollo/server": "^4.10.2",
    "@nestjs/apollo": "^12.1.0",
    "@nestjs/common": "^9.0.0",
    "@nestjs/config": "^3.2.1",
    "@nestjs/core": "^9.0.0",
    "@nestjs/graphql": "^12.1.1",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/platform-express": "^9.0.0",
    "@nestjs/swagger": "^7.3.1",
    "@prisma/client": "5.11.0",
    "bcryptjs": "^2.4.3",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "graphql": "^16.8.1",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.2.0",
    "stripe": "^15.6.0",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@nestjs/cli": "^9.0.0",
    "@nestjs/schematics": "^9.0.0",
    "@nestjs/testing": "^9.0.0",
    "@types/express": "^4.17.13",
    "@types/jest": "29.5.0",
    "@types/node": "18.15.11",
    "@types/supertest": "^2.0.11",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.0.1",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "29.5.0",
    "prettier": "^2.3.2",
    "prisma": "^5.11.0",
    "source-map-support": "^0.5.20",
    "supertest": "^6.1.3",
    "ts-jest": "29.0.5",
    "ts-loader": "^9.2.3",
    "ts-node": "^10.0.0",
    "tsconfig-paths": "4.2.0",
    "typescript": "^4.7.4"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
</file>

<file path="apps/api/README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="200" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ pnpm install
```

## Running the app

```bash
# development
$ pnpm run start

# watch mode
$ pnpm run start:dev

# production mode
$ pnpm run start:prod
```

## Test

```bash
# unit tests
$ pnpm run test

# e2e tests
$ pnpm run test:e2e

# test coverage
$ pnpm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).
</file>

<file path="apps/api/tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="apps/api/tsconfig.json">
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2017",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}
</file>

<file path="apps/web/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="apps/web/public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="apps/web/src/app/api/auth/[...nextauth]/route.ts">
import { authOptions } from '@autospace/network/src/config/authOptions'
import NextAuth from 'next-auth'

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }
</file>

<file path="apps/web/src/app/api/auth/token/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function GET(req: NextRequest, res: NextResponse) {
  const getCookies = cookies()
  const isDevelopment = process.env.NODE_ENV === 'development'

  // Use the appropriate cookie name based on the environment
  const cookieName = isDevelopment
    ? 'next-auth.session-token'
    : '__Secure-next-auth.session-token'

  const nextAuthSession = getCookies.get(cookieName)?.value || ''

  return NextResponse.json(nextAuthSession)
}
</file>

<file path="apps/web/src/app/booking-failed/page.tsx">
export default function Page() {
  return <div>Booking failed.</div>
}
</file>

<file path="apps/web/src/app/bookings/page.tsx">
import { ListCustomerBookings } from '@autospace/ui/src/components/templates/ListCustomerBookings'
import { IsLoggedIn } from '@autospace/ui/src/components/organisms/IsLoggedIn'

export default function Page() {
  return (
    <IsLoggedIn>
      <ListCustomerBookings />
    </IsLoggedIn>
  )
}
</file>

<file path="apps/web/src/app/login/page.tsx">
import { LoginForm } from '@autospace/ui/src/components/templates/LoginForm'
import { AuthLayout } from '@autospace/ui/src/components/molecules/AuthLayout'

export default function Page() {
  return (
    <AuthLayout title={'Login'}>
      <LoginForm />
    </AuthLayout>
  )
}
</file>

<file path="apps/web/src/app/register/page.tsx">
import { RegisterForm } from '@autospace/ui/src/components/templates/RegisterForm'
import { AuthLayout } from '@autospace/ui/src/components/molecules/AuthLayout'

export default function Page() {
  return (
    <AuthLayout title={'Register'}>
      <RegisterForm />
    </AuthLayout>
  )
}
</file>

<file path="apps/web/src/app/search/page.tsx">
'use client'
import { SearchPage } from '@autospace/ui/src/components/templates/SearchPage'
import { FormProviderSearchGarage } from '@autospace/forms/src/searchGarages'

export default function Page() {
  return (
    <FormProviderSearchGarage>
      <SearchPage />
    </FormProviderSearchGarage>
  )
}
</file>

<file path="apps/web/src/app/layout.tsx">
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import '@autospace/ui/src/app/globals.css'
import { ApolloProvider } from '@autospace/network/src/config/apollo'
import { SessionProvider } from '@autospace/ui/src/components/molecules/SessionProvider'
import { Header } from '@autospace/ui/src/components/organisms/Header'
import { ToastContainer } from '@autospace/ui/src/components/molecules/Toast'
import { MenuItem } from '@autospace/util/types'
import { Container } from '@autospace/ui/src/components/atoms/Container'
const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Autospace',
  description: 'Generated by create next app',
}

const MENUITEMS: MenuItem[] = [
  { label: 'Search', href: '/search' },
  { label: 'Bookings', href: '/bookings' },
]

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <SessionProvider>
        <ApolloProvider>
          <body className={`${inter.className} bg-gray-25`}>
            <Header menuItems={MENUITEMS} />
            <Container>{children}</Container>
            <ToastContainer />
          </body>
        </ApolloProvider>
      </SessionProvider>
    </html>
  )
}
</file>

<file path="apps/web/src/app/page.tsx">
'use client'
import { CarScene } from '@autospace/3d/src/scenes/CarScene'
import { IconSearch } from '@tabler/icons-react'
import Link from 'next/link'

export default function Home() {
  return (
    <main className="h-[calc(100vh-4rem)] ">
      <div className="absolute top-16 bottom-0 left-0 right-0">
        <CarScene />
      </div>
      <div className="flex flex-col items-start space-y-2 font-black text-8xl">
        <div className="z-10 inline-block px-3 bg-primary mt-2">Need</div>{' '}
        <div className="z-10 inline-block w-full max-w-md px-3 bg-primary ">
          parking?
        </div>
        <Link
          href="/search"
          className="z-10 flex items-center gap-2 px-3 py-2 text-xl font-medium text-black underline underline-offset-4 bg-primary"
        >
          <IconSearch /> Search now
        </Link>
      </div>
    </main>
  )
}
</file>

<file path="apps/web/.env.example">
NEXT_PUBLIC_API_URL=http://localhost:3000

NEXTAUTH_URL=http://localhost:3001
NEXTAUTH_SECRET=
NEXT_PUBLIC_MAPBOX_TOKEN=

NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=

GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
</file>

<file path="apps/web/.eslintrc.json">
{
  "extends": "next/core-web-vitals"
}
</file>

<file path="apps/web/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="apps/web/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      { hostname: 'api.mapbox.com' },
      { hostname: 'res.cloudinary.com' },
      { hostname: 'lh3.googleusercontent.com' },
    ],
  },
}

export default nextConfig
</file>

<file path="apps/web/package.json">
{
  "name": "@autospace/web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3001",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "tsc": "tsc --noEmit"
  },
  "dependencies": {
    "@autospace/network": "*",
    "@autospace/sample-lib": "*",
    "@autospace/ui": "*",
    "@tabler/icons-react": "^3.3.0",
    "next": "14.1.4",
    "next-auth": "^4.24.7",
    "react": "^18",
    "react-dom": "^18"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.0.1",
    "eslint": "^8",
    "eslint-config-next": "14.1.4",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}
</file>

<file path="apps/web/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="apps/web/README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="apps/web/tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  presets: [require('../../libs/ui/tailwind.config')],
  content: ['./src/**/*.{ts,tsx}', '../../libs/ui/**/*.{ts,tsx}'],
}
export default config
</file>

<file path="apps/web/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="apps/web/types.d.ts">
import '@autospace/network/next-auth'
</file>

<file path="apps/web-admin/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="apps/web-admin/public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="apps/web-admin/src/app/api/auth/[...nextauth]/route.ts">
import { authOptions } from '@autospace/network/src/config/authOptions'
import NextAuth from 'next-auth'

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }
</file>

<file path="apps/web-admin/src/app/api/auth/token/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function GET(req: NextRequest, res: NextResponse) {
  const getCookies = cookies()
  const isDevelopment = process.env.NODE_ENV === 'development'

  // Use the appropriate cookie name based on the environment
  const cookieName = isDevelopment
    ? 'next-auth.session-token'
    : '__Secure-next-auth.session-token'

  const nextAuthSession = getCookies.get(cookieName)?.value || ''

  return NextResponse.json(nextAuthSession)
}
</file>

<file path="apps/web-admin/src/app/login/page.tsx">
import { LoginForm } from '@autospace/ui/src/components/templates/LoginForm'
import { AuthLayout } from '@autospace/ui/src/components/molecules/AuthLayout'

export default function Page() {
  return (
    <AuthLayout title={'Login'}>
      <LoginForm />
    </AuthLayout>
  )
}
</file>

<file path="apps/web-admin/src/app/manageAdmins/page.tsx">
import { ManageAdmins } from '@autospace/ui/src/components/templates/ManageAdmins'

export default function Page() {
  return <ManageAdmins />
}
</file>

<file path="apps/web-admin/src/app/register/page.tsx">
import { RegisterForm } from '@autospace/ui/src/components/templates/RegisterForm'
import { AuthLayout } from '@autospace/ui/src/components/molecules/AuthLayout'

export default function Page() {
  return (
    <AuthLayout title={'Register'}>
      <RegisterForm />
    </AuthLayout>
  )
}
</file>

<file path="apps/web-admin/src/app/layout.tsx">
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import '@autospace/ui/src/app/globals.css'
import { MenuItem } from '@autospace/util/types'
import { ApolloProvider } from '@autospace/network/src/config/apollo'
import { SessionProvider } from '@autospace/ui/src/components/molecules/SessionProvider'
import { ToastContainer } from '@autospace/ui/src/components/molecules/Toast'
import { Container } from '@autospace/ui/src/components/atoms/Container'
import { Header } from '@autospace/ui/src/components/organisms/Header'
import { IsAdmin } from '@autospace/ui/src/components/organisms/IsAdmin'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Autospace | Admin',
  description: 'Generated by create next app',
}

const MENUITEMS: MenuItem[] = [
  { label: 'Garages', href: '/' },
  { label: 'Admins', href: '/manageAdmins' },
]

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body className={`${inter.className} bg-gray-25`}>
        <SessionProvider>
          <ApolloProvider>
            <Header type="admin" menuItems={MENUITEMS} />
            <Container>{children}</Container>
          </ApolloProvider>
        </SessionProvider>
        <ToastContainer />
      </body>
    </html>
  )
}
</file>

<file path="apps/web-admin/src/app/page.tsx">
import { IsAdmin } from '@autospace/ui/src/components/organisms/IsAdmin'
import { AdminHome } from '@autospace/ui/src/components/templates/AdminHome'

export default function Home() {
  return (
    <main>
      <IsAdmin>
        <AdminHome />
      </IsAdmin>
    </main>
  )
}
</file>

<file path="apps/web-admin/.env.example">
NEXT_PUBLIC_API_URL=http://localhost:3000

NEXTAUTH_URL=http://localhost:3004
NEXTAUTH_SECRET=

GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
</file>

<file path="apps/web-admin/.eslintrc.json">
{
  "extends": "next/core-web-vitals"
}
</file>

<file path="apps/web-admin/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="apps/web-admin/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      { hostname: 'api.mapbox.com' },
      { hostname: 'res.cloudinary.com' },
      { hostname: 'lh3.googleusercontent.com' },
    ],
  },
}

export default nextConfig
</file>

<file path="apps/web-admin/package.json">
{
  "name": "@autospace/web-admin",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3004",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18",
    "react-dom": "^18",
    "next": "14.2.3"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "eslint": "^8",
    "eslint-config-next": "14.2.3"
  }
}
</file>

<file path="apps/web-admin/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="apps/web-admin/README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="apps/web-admin/tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  presets: [require('../../libs/ui/tailwind.config')],
  content: ['./src/**/*.{ts,tsx}', '../../libs/ui/**/*.{ts,tsx}'],
}
export default config
</file>

<file path="apps/web-admin/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="apps/web-admin/types.d.ts">
import '@autospace/network/next-auth'
</file>

<file path="apps/web-manager/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="apps/web-manager/public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="apps/web-manager/src/app/api/auth/[...nextauth]/route.ts">
import { authOptions } from '@autospace/network/src/config/authOptions'
import NextAuth from 'next-auth'

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }
</file>

<file path="apps/web-manager/src/app/api/auth/token/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function GET(req: NextRequest, res: NextResponse) {
  const getCookies = cookies()
  const isDevelopment = process.env.NODE_ENV === 'development'

  // Use the appropriate cookie name based on the environment
  const cookieName = isDevelopment
    ? 'next-auth.session-token'
    : '__Secure-next-auth.session-token'

  const nextAuthSession = getCookies.get(cookieName)?.value || ''

  return NextResponse.json(nextAuthSession)
}
</file>

<file path="apps/web-manager/src/app/bookings/page.tsx">
import { IsLoggedIn } from '@autospace/ui/src/components/organisms/IsLoggedIn'
import { IsManager } from '@autospace/ui/src/components/organisms/IsManager'
import { ListGarageBookings } from '@autospace/ui/src/components/templates/ListGarageBookings'

export default function Page({
  searchParams,
}: {
  searchParams: { [key: string]: string | string[] | undefined }
}) {
  const garageId = Number(searchParams['garageId'])

  return (
    <main>
      <IsLoggedIn>
        <IsManager>
          <ListGarageBookings garageId={garageId} />
        </IsManager>
      </IsLoggedIn>
    </main>
  )
}
</file>

<file path="apps/web-manager/src/app/login/page.tsx">
import { LoginForm } from '@autospace/ui/src/components/templates/LoginForm'
import { AuthLayout } from '@autospace/ui/src/components/molecules/AuthLayout'

export default function Page() {
  return (
    <AuthLayout title={'Login'}>
      <LoginForm />
    </AuthLayout>
  )
}
</file>

<file path="apps/web-manager/src/app/new-garage/page.tsx">
import { CreateGarage } from '@autospace/ui/src/components/templates/CreateGarage'

export default function Page() {
  return <CreateGarage />
}
</file>

<file path="apps/web-manager/src/app/register/page.tsx">
import { RegisterForm } from '@autospace/ui/src/components/templates/RegisterForm'
import { AuthLayout } from '@autospace/ui/src/components/molecules/AuthLayout'

export default function Page() {
  return (
    <AuthLayout title={'Register'}>
      <RegisterForm />
    </AuthLayout>
  )
}
</file>

<file path="apps/web-manager/src/app/valets/page.tsx">
import { ManageValets } from '@autospace/ui/src/components/templates/ManageValets'
import { IsLoggedIn } from '@autospace/ui/src/components/organisms/IsLoggedIn'

export default function Page() {
  return (
    <IsLoggedIn>
      <ManageValets />
    </IsLoggedIn>
  )
}
</file>

<file path="apps/web-manager/src/app/layout.tsx">
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import '@autospace/ui/src/app/globals.css'
import { MenuItem } from '@autospace/util/types'
import { ApolloProvider } from '@autospace/network/src/config/apollo'
import { SessionProvider } from '@autospace/ui/src/components/molecules/SessionProvider'
import { ToastContainer } from '@autospace/ui/src/components/molecules/Toast'
import { Container } from '@autospace/ui/src/components/atoms/Container'
import { Header } from '@autospace/ui/src/components/organisms/Header'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Autospace | Manager',
  description: 'Generated by create next app',
}

const MENUITEMS: MenuItem[] = [
  { label: 'New Garage', href: '/new-garage' },
  { label: 'Valets', href: '/valets' },
]

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body className={`${inter.className} bg-gray-25`}>
        <SessionProvider>
          <ApolloProvider>
            <Header type="manager" menuItems={MENUITEMS} />
            <Container>{children}</Container>
          </ApolloProvider>
        </SessionProvider>
        <ToastContainer />
      </body>
    </html>
  )
}
</file>

<file path="apps/web-manager/src/app/page.tsx">
'use client'
import { IsLoggedIn } from '@autospace/ui/src/components/organisms/IsLoggedIn'
import { IsManager } from '@autospace/ui/src/components/organisms/IsManager'
import { ListGarages } from '@autospace/ui/src/components/organisms/ListGarages'

export default function Home() {
  return (
    <IsLoggedIn>
      <IsManager>
        {(companyId) => <ListGarages companyId={companyId} />}
      </IsManager>
    </IsLoggedIn>
  )
}
</file>

<file path="apps/web-manager/.env.example">
NEXT_PUBLIC_API_URL=http://localhost:3000


NEXTAUTH_URL=http://localhost:3002
NEXTAUTH_SECRET=

NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=
NEXT_PUBLIC_CLOUDINARY_UPLOAD_PRESET=

NEXT_PUBLIC_MAPBOX_TOKEN=

GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
</file>

<file path="apps/web-manager/.eslintrc.json">
{
  "extends": "next/core-web-vitals"
}
</file>

<file path="apps/web-manager/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="apps/web-manager/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      { hostname: 'api.mapbox.com' },
      { hostname: 'res.cloudinary.com' },
      { hostname: 'lh3.googleusercontent.com' },
    ],
  },
}

export default nextConfig
</file>

<file path="apps/web-manager/package.json">
{
  "name": "@autospace/web-manager",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3002",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18",
    "react-dom": "^18",
    "next": "14.2.3"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "eslint": "^8",
    "eslint-config-next": "14.2.3"
  }
}
</file>

<file path="apps/web-manager/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="apps/web-manager/README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="apps/web-manager/tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  presets: [require('../../libs/ui/tailwind.config')],
  content: ['./src/**/*.{ts,tsx}', '../../libs/ui/**/*.{ts,tsx}'],
}
export default config
</file>

<file path="apps/web-manager/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="apps/web-manager/types.d.ts">
import '@autospace/network/next-auth'
</file>

<file path="apps/web-valet/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="apps/web-valet/public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="apps/web-valet/src/app/api/auth/[...nextauth]/route.ts">
import { authOptions } from '@autospace/network/src/config/authOptions'
import NextAuth from 'next-auth'

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }
</file>

<file path="apps/web-valet/src/app/api/auth/token/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function GET(req: NextRequest, res: NextResponse) {
  const getCookies = cookies()
  const isDevelopment = process.env.NODE_ENV === 'development'

  // Use the appropriate cookie name based on the environment
  const cookieName = isDevelopment
    ? 'next-auth.session-token'
    : '__Secure-next-auth.session-token'

  const nextAuthSession = getCookies.get(cookieName)?.value || ''

  return NextResponse.json(nextAuthSession)
}
</file>

<file path="apps/web-valet/src/app/login/page.tsx">
import { LoginForm } from '@autospace/ui/src/components/templates/LoginForm'
import { AuthLayout } from '@autospace/ui/src/components/molecules/AuthLayout'

export default function Page() {
  return (
    <AuthLayout title={'Login'}>
      <LoginForm />
    </AuthLayout>
  )
}
</file>

<file path="apps/web-valet/src/app/my-trips/page.tsx">
'use client'
import { IsLoggedIn } from '@autospace/ui/src/components/organisms/IsLoggedIn'
import { IsValet } from '@autospace/ui/src/components/organisms/IsValet'
import { ValetTrips } from '@autospace/ui/src/components/templates/ValetTrips'

export default function Page() {
  return (
    <main>
      <IsLoggedIn>
        {(uid) => (
          <IsValet uid={uid}>
            <ValetTrips uid={uid} />
          </IsValet>
        )}
      </IsLoggedIn>
    </main>
  )
}
</file>

<file path="apps/web-valet/src/app/register/page.tsx">
import { RegisterForm } from '@autospace/ui/src/components/templates/RegisterForm'
import { AuthLayout } from '@autospace/ui/src/components/molecules/AuthLayout'

export default function Page() {
  return (
    <AuthLayout title={'Register'}>
      <RegisterForm />
    </AuthLayout>
  )
}
</file>

<file path="apps/web-valet/src/app/layout.tsx">
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import '@autospace/ui/src/app/globals.css'
import { MenuItem } from '@autospace/util/types'
import { ApolloProvider } from '@autospace/network/src/config/apollo'
import { SessionProvider } from '@autospace/ui/src/components/molecules/SessionProvider'
import { ToastContainer } from '@autospace/ui/src/components/molecules/Toast'
import { Container } from '@autospace/ui/src/components/atoms/Container'
import { Header } from '@autospace/ui/src/components/organisms/Header'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Autospace | Valet',
  description: 'Generated by create next app',
}

const MENUITEMS: MenuItem[] = [{ label: 'My Trips', href: '/my-trips' }]

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body className={`${inter.className} bg-gray-25`}>
        <SessionProvider>
          <ApolloProvider>
            <Header type="valet" menuItems={MENUITEMS} />
            <Container>{children}</Container>
          </ApolloProvider>
        </SessionProvider>
        <ToastContainer />
      </body>
    </html>
  )
}
</file>

<file path="apps/web-valet/src/app/page.tsx">
'use client'
import { IsLoggedIn } from '@autospace/ui/src/components/organisms/IsLoggedIn'
import { IsValet } from '@autospace/ui/src/components/organisms/IsValet'
import { ValetHome } from '@autospace/ui/src/components/templates/ValetHome'

export default function Home() {
  return (
    <main>
      <IsLoggedIn>
        {(uid) => (
          <IsValet uid={uid}>
            <ValetHome />
          </IsValet>
        )}
      </IsLoggedIn>
    </main>
  )
}
</file>

<file path="apps/web-valet/.env.example">
NEXT_PUBLIC_API_URL=http://localhost:3000

NEXTAUTH_URL=http://localhost:3003
NEXTAUTH_SECRET=

NEXT_PUBLIC_MAPBOX_TOKEN=

GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
</file>

<file path="apps/web-valet/.eslintrc.json">
{
  "extends": "next/core-web-vitals"
}
</file>

<file path="apps/web-valet/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="apps/web-valet/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      { hostname: 'api.mapbox.com' },
      { hostname: 'res.cloudinary.com' },
      { hostname: 'lh3.googleusercontent.com' },
    ],
  },
}

export default nextConfig
</file>

<file path="apps/web-valet/package.json">
{
  "name": "@autospace/web-valet",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3003",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^18",
    "react-dom": "^18",
    "next": "14.2.3"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "eslint": "^8",
    "eslint-config-next": "14.2.3"
  }
}
</file>

<file path="apps/web-valet/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="apps/web-valet/README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="apps/web-valet/tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  presets: [require('../../libs/ui/tailwind.config')],
  content: ['./src/**/*.{ts,tsx}', '../../libs/ui/**/*.{ts,tsx}'],
}
export default config
</file>

<file path="apps/web-valet/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="apps/web-valet/types.d.ts">
import '@autospace/network/next-auth'
</file>

<file path="libs/3d/src/components/camera/Rotating.tsx">
import { useRef, useState } from 'react'
import * as THREE from 'three'
import { PerspectiveCamera } from '@react-three/drei'

import { useFrame } from '@react-three/fiber'
import { MathUtils } from 'three'

export const RotatingCamera = ({
  speed = 0.003,
  minFov = 30,
  maxFov = 60,
  radius = 80,
}) => {
  const [angle, setAngle] = useState(() => MathUtils.randInt(0, radius))
  const [fov, setFov] = useState(() => MathUtils.randInt(minFov, maxFov))

  const cameraRef = useRef<THREE.PerspectiveCamera>(null)

  useFrame((state, delta) => {
    if (cameraRef.current) {
      setAngle((prevAngle) => (prevAngle + speed) % (2 * Math.PI))

      cameraRef.current.position.x = radius * Math.sin(angle)
      cameraRef.current.position.z = radius * Math.cos(angle)
      cameraRef.current.position.y = 200
      cameraRef.current.lookAt(1, 0, 1)

      const amplitude = (maxFov - minFov) / 2
      const oscillationSpeed = 0.05
      setFov(
        minFov +
          amplitude +
          Math.sin(state.clock.elapsedTime * oscillationSpeed) * amplitude,
      )
    }
  })

  return (
    <>
      <PerspectiveCamera
        ref={cameraRef}
        makeDefault
        fov={fov}
        near={0.1}
        far={1000}
        position={[0, 100, 0]}
      />
    </>
  )
}
</file>

<file path="libs/3d/src/components/BlinkingParkingSlot.tsx">
import { yellowColor } from '../util/constants'
import { Square, SquareProps } from './Square'
import { useEffect, useState } from 'react'

interface BlinkingParkingSlotProps extends SquareProps {
  blinkDuration?: number
}

export const BlinkingParkingSlot = ({
  borderColor = yellowColor,
  blinkDuration = 1000,
  ...props
}: BlinkingParkingSlotProps) => {
  const [isBlinking, setIsBlinking] = useState(true)

  useEffect(() => {
    const interval = setInterval(() => {
      setIsBlinking((prevState) => !prevState)
    }, blinkDuration)

    return () => {
      clearInterval(interval)
    }
  }, [blinkDuration])

  if (isBlinking) return null

  return <Square {...props} borderColor={borderColor} />
}
</file>

<file path="libs/3d/src/components/Building.tsx">
import { FLOOR_HEIGHT } from '../util/constants'
import { Square, SquareProps } from './Square'

interface BuildingProps extends SquareProps {
  floors?: number
}

export const Building = ({ position, size, floors = 3 }: BuildingProps) => {
  return (
    <>
      {Array.from({ length: floors }, (_, index) => (
        <Square
          key={index}
          position={[
            position[0],
            position[1] + index * FLOOR_HEIGHT,
            position[2],
          ]}
          size={size}
          borderColor="white"
        />
      ))}
    </>
  )
}
</file>

<file path="libs/3d/src/components/BuildingSet.tsx">
import { useEffect, useState } from 'react'
import { MathUtils } from 'three'
import { BUILDING_SETS } from '../util/buildingSets'
import { radians, randExp } from '../util'
import { Building } from './Building'
import { FLOOR_HEIGHT } from '../util/constants'

export const BuildingSet = ({
  minHeight = 2,
  maxHeight = 20,
}: {
  minHeight?: number
  maxHeight?: number
}) => {
  const [buildingSetIndex, setBuildingSetIndex] = useState<number>(0)
  const [floors, setFloors] = useState<number[]>([])

  useEffect(() => {
    setBuildingSetIndex(MathUtils.randInt(0, BUILDING_SETS.length - 1))

    setFloors(
      BUILDING_SETS[buildingSetIndex].map(() => {
        const randHeight = randExp(minHeight, maxHeight, 7)
        return Math.floor(randHeight)
      }),
    )
  }, [])

  return (
    <group>
      {BUILDING_SETS[buildingSetIndex].map(({ length, position, width }, i) => (
        <>
          <Building
            position={
              position.map((pos) => pos * 2) as [number, number, number]
            }
            size={[width * 2, length * 2]}
            floors={floors[i]}
          />
          {/* Add a translucent black plane that is the same size as the parking lot */}

          <mesh
            position={[
              position[0] * 2,
              FLOOR_HEIGHT * (floors[i] - 1), // Adjust the y-position to the top of the building
              position[2] * 2,
            ]}
            rotation={[radians(-90), 0, 0]} // Rotate the plane to align with the ground
          >
            <planeGeometry args={[width * 2, length * 2]} />
            <meshBasicMaterial color={'black'} transparent opacity={0.6} />
          </mesh>
        </>
      ))}
    </group>
  )
}
</file>

<file path="libs/3d/src/components/Car.tsx">
import { Color } from '@react-three/fiber'
import { Euler, MathUtils, Vector3 } from 'three'
import { useEffect, useState } from 'react'
import { getRamdomComment } from '../util/comments'
import { Box, Html } from '@react-three/drei'
import { radians } from '../util'
import { BlinkingParkingSlot } from './BlinkingParkingSlot'
import { GradientPlane } from './GradientPlane'

interface CarProps {
  color?: Color
  position?: Vector3
  size?: [number, number, number]
  searching?: boolean
  comment?: boolean
  trail?: boolean
  forward?: boolean
}

export const Car: React.FC<CarProps> = ({
  color = '#fff',
  position = new Vector3(0, 0, 0),
  forward = true,
  trail = true,
  searching = false,
  comment = false,
  size,
}) => {
  const [vehicleSize, setVehicleSize] = useState<[number, number, number]>([
    0, 0, 0,
  ])

  useEffect(() => {
    const newSize = size || [
      MathUtils.randFloat(1.9, 2.3),
      0.1,
      MathUtils.randFloat(4, 5.6),
    ]
    setVehicleSize(newSize)
  }, [size])

  const [randomComment, setRandomComment] = useState(() => getRamdomComment())

  useEffect(() => {
    const interval = setInterval(() => {
      setRandomComment(getRamdomComment())
    }, 16000)
    return () => {
      clearInterval(interval)
    }
  }, [])

  return (
    <>
      <Box
        position={position}
        rotation={[radians(0), radians(90), 0]}
        args={vehicleSize}
      >
        <meshBasicMaterial color={color} />
      </Box>
      {searching ? (
        <>
          <BlinkingParkingSlot position={[0, 2, 0]} />
        </>
      ) : null}

      {comment ? (
        <Html
          position={[0, 10, 0]}
          center
          style={{ maxWidth: '30rem', width: '100%' }}
          transform={false}
        >
          <div
            style={{
              color: '#aaa',
              fontSize: '.75rem',
              outline: 1,
              outlineColor: 'black',
              maxWidth: '30rem',
              width: '100%',
              whiteSpace: 'pre',
              userSelect: 'none',
            }}
          >
            {randomComment}
          </div>
        </Html>
      ) : null}
      {trail ? (
        forward ? (
          <GradientPlane
            position={new Vector3(vehicleSize[2] / 1.3, -0.02, position.z)}
            size={[3, 2]}
          />
        ) : (
          <GradientPlane
            rotation={new Euler(radians(-90), radians(0), radians(180))}
            position={new Vector3(-(vehicleSize[2] / 1.3), -0.02, position.z)}
            size={[3, vehicleSize[0]]}
          />
        )
      ) : null}
    </>
  )
}
</file>

<file path="libs/3d/src/components/GradientPlane.tsx">
import { CanvasTexture, Euler, Vector3 } from 'three'
import { radians } from '../util'
import { useMemo } from 'react'
import { roadColor } from '../util/constants'

export const GradientPlane = ({
  position,
  rotation = new Euler(radians(-90), 0, 0),
  size,
}: {
  position: Vector3
  size: [number, number]
  rotation?: Euler
}) => {
  const texture = useMemo(() => {
    const canvas = document.createElement('canvas')
    canvas.width = 256
    canvas.height = 256
    const ctx = canvas.getContext('2d')

    if (!ctx) {
      throw new Error('Failed to get canvas 2D context')
    }

    const gradient = ctx.createLinearGradient(0, 0, 256, 0)
    gradient.addColorStop(0, 'gray')
    gradient.addColorStop(1, roadColor)
    ctx.fillStyle = gradient
    ctx.fillRect(0, 0, 256, 256)
    return new CanvasTexture(canvas)
  }, [])

  return (
    <mesh position={position} rotation={rotation}>
      <planeGeometry args={size} />
      <meshBasicMaterial map={texture} />
    </mesh>
  )
}
</file>

<file path="libs/3d/src/components/Spawner.tsx">
import * as THREE from 'three'
import { ReactNode, useState, useRef } from 'react'
import { WORLD_DURATION } from '../util/constants'
import { SpawnedElement } from '../util/types'
import { useFrame } from '@react-three/fiber'

interface SpawnerProps {
  startPosition: THREE.Vector3
  endPosition: THREE.Vector3
  duration?: number
  spawnInterval: number
  children: ReactNode
}

export const Spawner = ({
  spawnInterval,
  startPosition,
  endPosition,
  children,
  duration = WORLD_DURATION,
}: SpawnerProps) => {
  const [elements, setElements] = useState<Array<SpawnedElement>>([])
  const lastSpawnTime = useRef<number>(Date.now())

  useFrame((_, delta) => {
    if (Date.now() - lastSpawnTime.current >= spawnInterval * 1000) {
      const id = Date.now()
      lastSpawnTime.current = id
      setElements((prevElements) => [...prevElements, { id, progress: 0 }])
    }

    setElements((prevElements) =>
      prevElements
        .map((elem) => ({
          ...elem,
          progress: elem.progress + delta / duration,
        }))
        .filter((elem) => elem.progress < 1),
    )
  })

  return (
    <>
      {elements.map((elem) => {
        const position = new THREE.Vector3().lerpVectors(
          startPosition,
          endPosition,
          elem.progress,
        )
        return (
          <group key={elem.id} position={position}>
            {children}
          </group>
        )
      })}
    </>
  )
}
</file>

<file path="libs/3d/src/components/Square.tsx">
import { MeshProps } from '@react-three/fiber'
import { yellowColor } from '../util/constants'

export interface SquareProps extends MeshProps {
  position: [number, number, number]
  size?: [number, number]
  borderColor?: string
}

export const Square: React.FC<SquareProps> = ({
  position,
  size = [5, 3],
  borderColor = yellowColor,
  ...props
}) => {
  const halfWidth = size[0] / 2
  const halfLength = size[1] / 2
  const borderThickness = 0.2

  return (
    <>
      {/* Top border */}
      <mesh
        position={[
          position[0],
          position[1],
          position[2] + halfLength - borderThickness / 2,
        ]}
        {...props}
      >
        <boxGeometry args={[size[0], borderThickness, borderThickness]} />
        <meshBasicMaterial color={borderColor} />
      </mesh>
      {/* Bottom border */}
      <mesh
        position={[
          position[0],
          position[1],
          position[2] - halfLength + borderThickness / 2,
        ]}
        {...props}
      >
        <boxGeometry args={[size[0], borderThickness, borderThickness]} />
        <meshBasicMaterial color={borderColor} />
      </mesh>
      {/* Left border */}
      <mesh
        position={[
          position[0] - halfWidth + borderThickness / 2,
          position[1],
          position[2],
        ]}
        {...props}
      >
        <boxGeometry
          args={[
            borderThickness,
            borderThickness,
            size[1] - 2 * borderThickness,
          ]}
        />
        <meshBasicMaterial color={borderColor} />
      </mesh>
      {/* Right border */}
      <mesh
        position={[
          position[0] + halfWidth - borderThickness / 2,
          position[1],
          position[2],
        ]}
        {...props}
      >
        <boxGeometry
          args={[
            borderThickness,
            borderThickness,
            size[1] - 2 * borderThickness,
          ]}
        />
        <meshBasicMaterial color={borderColor} />
      </mesh>
    </>
  )
}
</file>

<file path="libs/3d/src/scenes/CarScene.tsx">
import { Canvas } from '@react-three/fiber'
import { OrbitControls, PerspectiveCamera, Plane } from '@react-three/drei'
import { radians } from '../util'
import { Spawner } from '../components/Spawner'
import {
  WORLD_DURATION,
  WORLD_END,
  WORLD_START,
  roadColor,
} from '../util/constants'
import * as THREE from 'three'
import { Square } from '../components/Square'
import { Car } from '../components/Car'
import { Building } from '../components/Building'
import { BuildingSet } from '../components/BuildingSet'

export const CarScene = ({
  children,
  camera,
  className = 'h-[calc(100vh-2rem)]',
  orbitControls = true,
  hideAllComments = false,
}: {
  camera?: React.ReactNode
  children?: React.ReactNode
  className?: string
  orbitControls?: boolean
  hideAllComments?: boolean
}) => {
  return (
    <Canvas
      style={{
        background:
          'linear-gradient(to top right, hsl(0, 0%, 8%), hsl(52, 0%, 18%))',
      }}
    >
      {camera || (
        <PerspectiveCamera
          makeDefault
          fov={45}
          near={0.1}
          far={1000}
          position={[40, 200, 40]}
          rotation={[radians(60), 0, 0]}
        />
      )}
      {children}

      {orbitControls ? (
        <OrbitControls
          minPolarAngle={radians(0)}
          maxPolarAngle={radians(30)}
          //   minAzimuthAngle={radians(0)}
          //   maxAzimuthAngle={radians(270)}
          minDistance={30}
          maxDistance={180}
        />
      ) : null}

      {/* Road */}

      <Plane
        args={[1000, 24]}
        position={[0, -0.2, 0]}
        rotation={[radians(-90), 0, 0]}
      >
        <meshBasicMaterial color={roadColor} />
      </Plane>

      {/* Cars */}

      <Spawner
        spawnInterval={8.2}
        duration={WORLD_DURATION - 6}
        startPosition={new THREE.Vector3(WORLD_START, 0, -10)}
        endPosition={new THREE.Vector3(WORLD_END, 0, -10)}
      >
        <Car forward={false} searching comment={!hideAllComments && true} />
      </Spawner>
      <Spawner
        spawnInterval={4.3}
        duration={WORLD_DURATION - 12}
        startPosition={new THREE.Vector3(WORLD_START, 0, -6)}
        endPosition={new THREE.Vector3(WORLD_END, 0, -6)}
      >
        <Car forward={false} />
      </Spawner>
      <Spawner
        spawnInterval={7.4}
        duration={WORLD_DURATION - 18}
        startPosition={new THREE.Vector3(WORLD_START, 0, -2)}
        endPosition={new THREE.Vector3(WORLD_END, 0, -2)}
      >
        <Car forward={false} />
      </Spawner>

      <Spawner
        spawnInterval={9.8}
        duration={WORLD_DURATION - 18}
        endPosition={new THREE.Vector3(WORLD_START, 0, 2)}
        startPosition={new THREE.Vector3(WORLD_END, 0, 2)}
      >
        <Car />
      </Spawner>
      <Spawner
        spawnInterval={7}
        duration={WORLD_DURATION - 12}
        endPosition={new THREE.Vector3(WORLD_START, 0, 6)}
        startPosition={new THREE.Vector3(WORLD_END, 0, 6)}
      >
        <Car />
      </Spawner>
      {/* My Car */}
      <group position={new THREE.Vector3(0, 0, 10)}>
        <Car searching comment={!hideAllComments && true} />
      </group>

      {/* Buildings Left */}
      <Spawner
        spawnInterval={3.6}
        duration={WORLD_DURATION}
        startPosition={new THREE.Vector3(WORLD_START, 0, 76)}
        endPosition={new THREE.Vector3(WORLD_END, 0, 76)}
      >
        <BuildingSet />
      </Spawner>
      {/* Buildings Right */}
      <Spawner
        spawnInterval={3.6}
        duration={WORLD_DURATION}
        startPosition={new THREE.Vector3(WORLD_START, 0, -76)}
        endPosition={new THREE.Vector3(WORLD_END, 0, -76)}
      >
        <BuildingSet />
      </Spawner>
    </Canvas>
  )
}
</file>

<file path="libs/3d/src/util/buildingSets.ts">
const SIDE_SMALL = 18
const SIDE_MEDIUM = 38
const SIDE_LARGE = 58

export type BuildingSet = {
  position: [number, number, number]
  width: number
  length: number
}

const buildingSet1 = [
  { position: [20, 0, 20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [0, 0, 20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [-20, 0, 20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [20, 0, 0], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [0, 0, 0], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [-20, 0, 0], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [20, 0, -20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [0, 0, -20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [-20, 0, -20], width: SIDE_SMALL, length: SIDE_SMALL },
]

const buildingSet2x2_1x1 = [
  { position: [10, 0, 10], width: SIDE_MEDIUM, length: SIDE_MEDIUM },
  { position: [-20, 0, 20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [-20, 0, 0], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [-20, 0, -20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [0, 0, -20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [20, 0, -20], width: SIDE_SMALL, length: SIDE_SMALL },
]

const buildingSetLShape = [
  { position: [20, 0, 20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [0, 0, 20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [-20, 0, 20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [20, 0, 0], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [0, 0, 0], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [20, 0, -20], width: SIDE_SMALL, length: SIDE_SMALL },
]

const buildingSetWhole = [
  { position: [0, 0, 0], width: SIDE_LARGE, length: SIDE_LARGE },
]

const buildingSetWhole2 = [
  { position: [0, 0, -10], width: SIDE_LARGE, length: SIDE_MEDIUM },
]

const buildingSetWhole3 = [
  { position: [0, 0, -20], width: SIDE_LARGE, length: SIDE_SMALL },
]

const buildingSet4 = [
  { position: [0, 0, 20], width: SIDE_LARGE, length: SIDE_SMALL },

  { position: [20, 0, 0], width: SIDE_SMALL, length: SIDE_SMALL },

  { position: [-20, 0, 0], width: SIDE_SMALL, length: SIDE_SMALL },

  { position: [0, 0, -20], width: SIDE_SMALL, length: SIDE_SMALL },
  { position: [-20, 0, -20], width: SIDE_SMALL, length: SIDE_SMALL },
]

export const BUILDING_SETS = [
  buildingSet1,
  buildingSet2x2_1x1,
  buildingSet4,
  buildingSetLShape,
  buildingSetWhole,
  buildingSetWhole2,
  buildingSetWhole3,
]
</file>

<file path="libs/3d/src/util/comments.ts">
export const frustratedComments = [
  "Need parking space or I'm starting \na carpool on the roof.",
  "Why do all roads lead to 'no parking'?",
  'In search of my happy place... \nAKA a parking spot.',
  "Should've bought a helicopter instead.",
  //   'Went for a drive, ended up on a parking safari.',
  //   'Is this the real life, \nor is this just a parking fantasy?',
  "If I had a dime for every spot taken, \nI'd own the parking lot.",
  //   'Did everyone else get the memo \nto park here today too?',
  'Brb, circling the lot for the 100th time.',
  //   'I swear my car shrinks every time \nI look for a parking spot.',
  'Finding a soulmate seems easier \nthan finding a parking spot.',
  //   'Car for sale, comes with free parking spot.',
  'I came, I saw... I circled the lot.',
  "In a relationship with the 'P' sign.",
  'Growing old waiting for a parking spot.',
  'The quest for the holy grail was probably easier.',
  "If parking was an Olympic sport, \nI'd still be in last place.",
  //   "Why don't they make parking spots like they used to?",
  'Looking for a parking spot, \nsend help.',
  'Starting to miss my old tricycle.',

  "Next time, I'm buying a car \nthat comes with its own parking spot.",
  //   'At this point, I might as well park in Narnia.',
  'Fancy a game of Parking Spot Hunt?',
  'Car for sale: spends more time \nlooking for parking than driving.',
  //   'Maybe if I play musical chairs with my car, \na spot will open up.',
  'Is there a cheat code for instant parking?',
  'Meeting? Haha. I havent even found a parking.',
  "I didn't sign up for this episode of \n'Parking Spot Wars'.",
  "Honey, I'll be late. \nI'm stuck in a parking saga.",
  "I'm sure my car is enjoying this \ntour of the parking lot.",
  'One does not simply park in a \nbustling city.',
  //   "If parking were an Olympic sport, \nI'd have a gold medal by now.",
  "Who needs a gym when you've got \na parking lot workout?",
  //   "Dear parking lot, why can't \nwe just find a space?",
  //   'The real Bermuda Triangle is this parking lot.',
  //   "My car's favorite pastime? \nHide and seek.",
  //   "I feel like a knight, but instead of a dragon, \nI'm hunting for a parking spot.",
  "This isn't parking, \nit's car hide-and-seek!",
  "I didn't choose the parking life. \nThe parking life chose me.",
  //   'Is it just me, or are parking spaces \ngetting slimmer these days?',
  'Pardon me while I park my car in another timezone.',
  //   "Where's a parking fairy when you need one?",
  'Parking: The ultimate test of patience.',
  'One small step for man, \none giant leap to find a parking spot.',
  //   'Did anyone tell the parking spaces \nthat hide and seek time is over?',
  'Time for my daily game of \nSpot the Parking Spot.',
  //   "I remember the days when \nthe hardest maze was in a children's menu.",
  "Accepting bets on whether \nI'll find a spot first, or retire.",
  "If I had a penny for every minute \nI've spent looking for parking, \nI'd be a millionaire.",
  "My GPS says 'you have reached your destination', \nbut where's the parking?!",
  "I've circled so much, \nI'm getting dizzy. \nWhere's that parking spot?",

  'I wonder if my car gets as tired as \nI do searching for a spot.',
  "Looking for parking is my car's \nfavorite cardio workout.",
  "One day, I'll tell my grandkids about \nthe great parking lot odyssey.",
  'I think I just saw a tumbleweed roll by…',
  'Siri, find me the nearest parking spot, \nplease!',
  //   "Maybe I should have listened when they said 'don't forget where you parked'.",
  'Time to play my least favorite game: \nparking lot roulette.',
  //   'Anyone got a magic wand? I need to conjure a parking spot.',
  "I've got 99 problems, \nand parking is all of them.",
  'I swear, the parking spots are playing \nmusical chairs without me.',
  "If I spend any longer searching, \nI'm going to need to refuel.",
  'Thinking about adopting a homing pigeon \nto find parking spots for me.',
  //   'Parking lots: the adult version of a maze.',
  //   'Does anyone have the number for the parking spot hotline?',
  //   "When they said 'park it like it's hot', I didn't think they meant 'in the sun because you couldn't find a spot'.",
  //   "They see me rollin', they hatin', patrolling, and I'm still trying to find parking.",
  "There's no 'I' in 'park', \nbut there is an 'I' in 'circle \nthe parking lot for the fifth time'.",
  //   'Did I miss the memo about national occupy a parking space day?',
  'I bet even Columbus found America faster \nthan I can find a parking spot.',
  //   "Should've left breadcrumbs from the last parking spot I found.",
  "If I park any further away, \nI'll be in the next town over.",
  "Guess it's time for my daily game of \nparking spot bingo.",
  'Wanted: a magic carpet, \nbecause Aladdin never had parking issues.',
  //   "If finding parking was a video game, I'd be on the hardest level.",
  //   "My car is on a diet - it's been circling the parking lot for hours.",
  "Guess who's going on an \nunexpected parking safari!",
  //   'Is there a parking space whisperer in the house?',
  'Parking lots are just adult versions \nof musical chairs.',
  'Did all the parking spaces go on \nvacation or something?',
  "There are two types of people: \nthose who find parking, \nand those who don't. \nGuess which one I am.",

  "Park anywhere, they said. \nIt'll be easy, they said.",

  "I've seen unicorns, \nthe Loch Ness monster, \nbut a free parking spot? Never.",

  `"Siri, find me the nearest parking spot, please!" \nSiri: "Hmm, there's a spot 200 miles away. Ready for a road trip?"`,
]

export const getRamdomComment = () =>
  frustratedComments[Math.floor(Math.random() * frustratedComments.length)]
</file>

<file path="libs/3d/src/util/constants.ts">
export const WORLD_DURATION = 27

export const WORLD_START = -500
export const WORLD_END = 400

export const yellowColor = 'hsl(52, 100%, 50%)'
export const roadColor = '#222'

export const FLOOR_HEIGHT = 6
</file>

<file path="libs/3d/src/util/index.ts">
export const radians = (degrees: number) => degrees * (Math.PI / 180)

export const randExp = (min = 0, max = 10, exponent = 4): number => {
  const randomValue = Math.random()
  const expValue = Math.pow(randomValue, exponent)
  const range = max - min

  return min + range * expValue
}
</file>

<file path="libs/3d/src/util/types.ts">
export type SpawnedElement = {
  id: number
  progress: number
}
</file>

<file path="libs/3d/package.json">
{
  "name": "@autospace/3d",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "dependencies": {
    "@react-three/drei": "^9.105.6",
    "@react-three/fiber": "^8.16.6",
    "three": "^0.164.1"
  },
  "devDependencies": {
    "@types/three": "^0.164.0"
  }
}
</file>

<file path="libs/3d/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": ".",
    "jsx": "react-jsx"
  }
}
</file>

<file path="libs/forms/src/adapters/searchFormAdapter.ts">
import { SearchGaragesQueryVariables } from '@autospace/network/src/gql/generated'
import { FormTypeSearchGarage } from '../searchGarages'
import { useState, useEffect } from 'react'
import {
  FieldNamesMarkedBoolean,
  useFormContext,
  useWatch,
} from 'react-hook-form'
import { useDebounce } from '@autospace/util/hooks/async'
import { intFilter } from './util'

type FormData = Partial<
  Pick<
    FormTypeSearchGarage,
    | 'endTime'
    | 'startTime'
    | 'height'
    | 'length'
    | 'width'
    | 'pricePerHour'
    | 'types'
    | 'locationFilter'
    | 'skip'
    | 'take'
  >
>

export const useConvertSearchFormToVariables = () => {
  const [variables, setVariables] =
    useState<SearchGaragesQueryVariables | null>(null)

  const {
    formState: { dirtyFields, errors },
  } = useFormContext<FormTypeSearchGarage>()

  const formData = useWatch<FormTypeSearchGarage>()

  const [debouncedFormData, { debouncing }] = useDebounce(formData, 300)

  const hasErrors = Object.keys(errors).length !== 0

  useEffect(() => {
    const {
      endTime = '',
      startTime = '',
      locationFilter,
      length,
      width,
      height,
      pricePerHour,
      types,
      skip,
      take,
    } = debouncedFormData

    if (!startTime || !endTime || !locationFilter) {
      return
    }

    const dateFilter: SearchGaragesQueryVariables['dateFilter'] = {
      start: startTime,
      end: endTime,
    }

    const { ne_lat = 0, ne_lng = 0, sw_lat = 0, sw_lng = 0 } = locationFilter

    const slotsFilter = createSlotsFilter(dirtyFields, {
      length,
      width,
      height,
      pricePerHour,
      types,
    })

    const garagesFilter = createGaragesFilter(dirtyFields, { skip, take })

    setVariables({
      dateFilter,
      locationFilter: { ne_lat, ne_lng, sw_lat, sw_lng },
      ...(Object.keys(slotsFilter).length && { slotsFilter }),
      ...(Object.keys(garagesFilter).length && { garagesFilter }),
    })
  }, [debouncedFormData])

  return { variables: hasErrors ? null : variables, debouncing }
}

export const createSlotsFilter = (
  dirtyFields: FieldNamesMarkedBoolean<FormTypeSearchGarage>,
  formData: FormData,
) => {
  const length = dirtyFields.length && intFilter(formData.length)
  const width = dirtyFields.width && intFilter(formData.width)
  const height = dirtyFields.height && intFilter(formData.height)
  const pricePerHour =
    dirtyFields.pricePerHour && intFilter(formData.pricePerHour)
  const type = dirtyFields.types && { in: formData.types }

  return {
    ...(length && { length }),
    ...(width && { width }),
    ...(height && { height }),
    ...(pricePerHour && { pricePerHour }),
    ...(type && { type }),
  }
}

export const createGaragesFilter = (
  dirtyFields: FieldNamesMarkedBoolean<FormTypeSearchGarage>,
  formData: FormData,
) => {
  const skip = (dirtyFields.skip && formData.skip) || 0
  const take = (dirtyFields.take && formData.take) || 10

  return {
    ...(skip && { skip }),
    ...(take && { take }),
  }
}
</file>

<file path="libs/forms/src/adapters/util.ts">
export const intFilter = (data?: [number, number]) => {
  if (!data) return {}
  const filterObj: { gte?: number; lte?: number } = {}
  if (data[0] !== 0) filterObj['gte'] = data[0]
  if (data[1] !== 0) filterObj['lte'] = data[1]
  return filterObj
}
</file>

<file path="libs/forms/src/util/index.ts">
export const isStartTimeValid = (startTime: string) => {
  const startDate = new Date(startTime)
  const currentDate = new Date()
  return startDate > currentDate
}

export const isEndTimeValid = ({
  endTime,
  startTime,
}: {
  startTime: string
  endTime: string
}) => {
  const startDate = new Date(startTime)
  const endDate = new Date(endTime)
  return endDate > startDate
}
</file>

<file path="libs/forms/src/bookSlot.tsx">
import { SlotType } from '@autospace/network/src/gql/generated'
import { z } from 'zod'
import { isEndTimeValid, isStartTimeValid } from './util'
import { DefaultValues, FormProvider, useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { ReactNode } from 'react'

export const locationInfo = z.object({
  lat: z.number(),
  lng: z.number(),
  distance: z.number().optional(),
  notes: z.string().optional(),
})

export const formSchemaValet = z.object({
  pickupInfo: locationInfo,
  dropoffInfo: locationInfo,
  differentLocations: z.boolean().optional(),
})

export const formSchemaBookSlot = z
  .object({
    startTime: z.string(),
    endTime: z.string(),
    vehicleNumber: z.string().min(1, { message: 'Vehicle number is required' }),
    phoneNumber: z.string().min(1, { message: 'Phone number is required' }),
    type: z.nativeEnum(SlotType, {
      required_error: 'Slot type is required',
    }),
    valet: formSchemaValet.optional(),
  })
  .refine(({ startTime }) => isStartTimeValid(startTime), {
    message: 'Start time should be greater than current time',
    path: ['startTime'],
  })
  .refine(({ endTime, startTime }) => isEndTimeValid({ endTime, startTime }), {
    message: 'End time should be greater than start time',
    path: ['endTime'],
  })

export type FormTypeBookSlot = z.infer<typeof formSchemaBookSlot>

export const userFormBookSlot = ({
  defaultValues,
}: {
  defaultValues: DefaultValues<FormTypeBookSlot>
}) =>
  useForm<FormTypeBookSlot>({
    resolver: zodResolver(formSchemaBookSlot),
    defaultValues,
    mode: 'onChange',
  })

export const FormProviderBookSlot = ({
  children,
  defaultValues,
}: {
  children: ReactNode
  defaultValues: DefaultValues<FormTypeBookSlot>
}) => {
  const methods = userFormBookSlot({ defaultValues })

  return <FormProvider {...methods}>{children}</FormProvider>
}
</file>

<file path="libs/forms/src/createCompany.ts">
import { z } from 'zod'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'

export const formSchemaCreateCompany = z.object({
  displayName: z.string().min(1, { message: 'Company name is required' }),
  description: z.string(),
  managerId: z.string().min(1, { message: 'Manager ID is required' }),
  managerName: z.string().optional().nullable(),
})

export type FormTypeCreateCompany = z.infer<typeof formSchemaCreateCompany>

export const useFormCreateCompany = () =>
  useForm<FormTypeCreateCompany>({
    resolver: zodResolver(formSchemaCreateCompany),
  })
</file>

<file path="libs/forms/src/createGarage.tsx">
import { SlotType } from '@autospace/network/src/gql/generated'
import { zodResolver } from '@hookform/resolvers/zod'
import { useForm, FormProvider } from 'react-hook-form'
import { z } from 'zod'
import { ReactNode } from 'react'

export const formSchemaAddress = z.object({
  lat: z.number(),
  lng: z.number(),
  address: z.string().min(1),
})

export const formSchemaCreateSlot = z.object({
  height: z.number(),
  width: z.number(),
  length: z.number(),
  pricePerHour: z.number(),
  count: z.number().min(1).max(10, { message: 'Maximum 10.' }),
  type: z.nativeEnum(SlotType),
})

export const formSchemaCreateGarage = z.object({
  displayName: z.string().min(1),
  description: z.string().min(1),
  images: z.any(),
  location: formSchemaAddress,
  slotTypes: z.array(formSchemaCreateSlot),
})

export type FormTypeCreateGarage = z.infer<typeof formSchemaCreateGarage>

export const useFormCreateGarage = () =>
  useForm<FormTypeCreateGarage>({
    resolver: zodResolver(formSchemaCreateGarage),
    defaultValues: { slotTypes: [] },
  })

export const FormProviderCreateGarage = ({
  children,
}: {
  children: ReactNode
}) => {
  const methods = useFormCreateGarage()
  return <FormProvider {...methods}>{children}</FormProvider>
}
</file>

<file path="libs/forms/src/createSlots.ts">
import { formSchemaCreateSlot } from './createGarage'
import { z } from 'zod'
import { zodResolver } from '@hookform/resolvers/zod'
import { useForm } from 'react-hook-form'

export type FormTypeCreateManySlots = z.infer<typeof formSchemaCreateSlot>

export const useFormCreateManySlots = () =>
  useForm<FormTypeCreateManySlots>({
    resolver: zodResolver(formSchemaCreateSlot),
  })
</file>

<file path="libs/forms/src/createUid.ts">
import { zodResolver } from '@hookform/resolvers/zod'
import { useForm } from 'react-hook-form'
import { z } from 'zod'

export const formSchemaUid = z.object({
  uid: z.string(),
})

export type FormTypeUid = z.infer<typeof formSchemaUid>

export const useFormUid = () =>
  useForm<FormTypeUid>({
    resolver: zodResolver(formSchemaUid),
  })
</file>

<file path="libs/forms/src/createValet.ts">
import { zodResolver } from '@hookform/resolvers/zod'
import { useForm } from 'react-hook-form'
import { z } from 'zod'

export const schemaCreateValet = z.object({
  uid: z.string().min(1, { message: 'Valet uid is required' }),
  displayName: z.string().min(1, { message: 'Valet name is required' }),
  licenceID: z.string().min(1, { message: 'Valet licence is required' }),
  image: z.any().optional(),
})

export type FormTypeCreateValet = z.infer<typeof schemaCreateValet>

export const useFormCreateValet = () =>
  useForm<FormTypeCreateValet>({
    resolver: zodResolver(schemaCreateValet),
  })
</file>

<file path="libs/forms/src/login.tsx">
import { useForm } from 'react-hook-form'
import { z } from 'zod'
import { formSchemaLogin } from './schemas'
import { zodResolver } from '@hookform/resolvers/zod'

export type FormTypeLogin = z.infer<typeof formSchemaLogin>

export const useFormLogin = () =>
  useForm<FormTypeLogin>({
    resolver: zodResolver(formSchemaLogin),
  })
</file>

<file path="libs/forms/src/register.tsx">
import { zodResolver } from '@hookform/resolvers/zod'
import { useForm } from 'react-hook-form'
import { z } from 'zod'
import { formSchemaRegister } from './schemas'

export type FormTypeRegister = z.infer<typeof formSchemaRegister>

export const useFormRegister = () =>
  useForm<FormTypeRegister>({
    resolver: zodResolver(formSchemaRegister),
  })
</file>

<file path="libs/forms/src/schemas.ts">
import { z } from 'zod'

export const formSchemaRegister = z.object({
  name: z.string().optional(),
  image: z.string().optional(),
  email: z.string().email(),
  password: z.string().min(6),
})

export const formSchemaLogin = formSchemaRegister.pick({
  email: true,
  password: true,
})
</file>

<file path="libs/forms/src/searchGarages.tsx">
import { SlotType } from '@autospace/network/src/gql/generated'
import { z } from 'zod'
import { toLocalISOString } from '@autospace/util/date'
import { ReactNode } from 'react'
import { DefaultValues, useForm, FormProvider, Form } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { isEndTimeValid, isStartTimeValid } from './util'

const minMaxTuple = z.tuple([z.number(), z.number()])

export const formSchemaSearchGarage = z
  .object({
    startTime: z.string(),
    endTime: z.string(),

    locationFilter: z.object({
      ne_lat: z.number(),
      ne_lng: z.number(),
      sw_lat: z.number(),
      sw_lng: z.number(),
    }),

    types: z.nativeEnum(SlotType).array(),

    pricePerHour: minMaxTuple.optional(),
    height: minMaxTuple.optional(),
    width: minMaxTuple.optional(),
    length: minMaxTuple.optional(),

    skip: z.number().optional(),
    take: z.number().optional(),
  })
  .refine(({ startTime }) => isStartTimeValid(startTime), {
    message: 'Start time should be greater than current time',
    path: ['startTime'],
  })
  .refine(({ endTime, startTime }) => isEndTimeValid({ endTime, startTime }), {
    message: 'End time should be greater than start time',
    path: ['endTime'],
  })

export type FormTypeSearchGarage = z.infer<typeof formSchemaSearchGarage>

export const getCurrentTimeAndOneHourLater = () => {
  const startTime = new Date()
  startTime.setMinutes(startTime.getMinutes() + 5)

  const endTime = new Date(startTime)
  endTime.setHours(endTime.getHours() + 1)

  return {
    startTime: toLocalISOString(startTime).slice(0, 16),
    endTime: toLocalISOString(endTime).slice(0, 16),
  }
}

export const AllSlotTypes = [
  SlotType.Bicycle,
  SlotType.Bike,
  SlotType.Car,
  SlotType.Heavy,
]

export const formDefaultValuesSearchGarages: DefaultValues<FormTypeSearchGarage> =
  {
    pricePerHour: [0, 200],
    width: [0, 20],
    height: [0, 100],
    length: [0, 100],
    types: AllSlotTypes.sort(),
  }

export const FormProviderSearchGarage = ({
  children,
}: {
  children: ReactNode
}) => {
  const { startTime, endTime } = getCurrentTimeAndOneHourLater()
  const methods = useForm<FormTypeSearchGarage>({
    resolver: zodResolver(formSchemaSearchGarage),
    defaultValues: {
      ...formDefaultValuesSearchGarages,
      startTime,
      endTime,
    },
  })

  return <FormProvider {...methods}>{children}</FormProvider>
}
</file>

<file path="libs/forms/package.json">
{
  "name": "@autospace/forms",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "dependencies": {
    "@hookform/resolvers": "^3.3.4",
    "react-hook-form": "^7.51.4",
    "zod": "^3.23.6"
  }
}
</file>

<file path="libs/forms/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": ".",
    "jsx": "react-jsx"
  }
}
</file>

<file path="libs/network/src/config/apollo.tsx">
'use client'
import {
  ApolloClient,
  HttpLink,
  InMemoryCache,
  ApolloProvider as Provider,
} from '@apollo/client'
import { ReactNode } from 'react'
import { setContext } from '@apollo/client/link/context'

export interface IApolloProviderProps {
  children: ReactNode
}

export const ApolloProvider = ({ children }: IApolloProviderProps) => {
  const httpLink = new HttpLink({
    uri: process.env.NEXT_PUBLIC_API_URL + '/graphql',
  })

  const authLink = setContext(async (_, { headers }) => {
    const token = await fetch('/api/auth/token').then((res) => res.json())

    return {
      headers: {
        ...headers,
        authorization: token ? `Bearer ${token}` : '',
      },
    }
  })

  const apolloClient = new ApolloClient({
    link: authLink.concat(httpLink),
    cache: new InMemoryCache(),
  })
  return <Provider client={apolloClient}>{children}</Provider>
}
</file>

<file path="libs/network/src/config/authOptions.ts">
import { NextAuthOptions, getServerSession } from 'next-auth'
import GoogleProvider from 'next-auth/providers/google'
import CredentialsProvider from 'next-auth/providers/credentials'
import {
  AuthProviderType,
  GetAuthProviderDocument,
  LoginDocument,
  RegisterWithProviderDocument,
} from '@autospace/network/src/gql/generated'
import { fetchGraphQL } from '../fetch'
import * as jwt from 'jsonwebtoken'
import { JWT } from 'next-auth/jwt'

const MAX_AGE = 1 * 24 * 60 * 60

const secureCookies = process.env.NEXTAUTH_URL?.startsWith('https://')
const hostName = new URL(process.env.NEXTAUTH_URL || '').hostname
const rootDomain = 'karthicktech.com'

export const authOptions: NextAuthOptions = {
  // Configure authentication providers
  providers: [
    // Google OAuth provider configuration
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          scope: 'openid profile',
        },
      },
    }),
    // Credentials provider configuration for email/password authentication
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      // Authorize function to validate user credentials
      async authorize(credentials) {
        // Implement credential validation logic
        if (!credentials) {
          throw new Error('Email and password are required')
        }
        const { email, password } = credentials

        try {
          const { data, error } = await fetchGraphQL({
            document: LoginDocument,
            variables: { loginInput: { email, password } },
          })

          if (!data?.login.token || error) {
            throw new Error(
              'Authentication failed: Invalid credentials or user not found',
            )
          }
          const uid = data.login.user.uid
          const image = data.login.user.image
          const name = data.login.user.name

          return { id: uid, name, image, email }
        } catch (error) {}
        return null
      },
    }),
  ],

  // Enable debug mode for development
  debug: true,

  // Configure session settings
  session: {
    strategy: 'jwt',
    maxAge: MAX_AGE,
  },

  // Configure JWT settings
  jwt: {
    maxAge: MAX_AGE,
    // Custom JWT encoding function
    async encode({ token, secret }): Promise<string> {
      // Implement custom JWT encoding logic
      if (!token) {
        throw new Error('Token is undefined')
      }
      const { sub, ...tokenProps } = token
      // Get the current date in seconds since the epoch
      const nowInSeconds = Math.floor(Date.now() / 1000)
      // Calculate the expiration timestamp
      const expirationTimestamp = nowInSeconds + MAX_AGE
      return jwt.sign(
        { uid: sub, ...tokenProps, exp: expirationTimestamp },
        secret,
        {
          algorithm: 'HS256',
        },
      )
    },
    // Custom JWT decoding function
    async decode({ token, secret }): Promise<JWT | null> {
      // Implement custom JWT decoding logic
      if (!token) {
        throw new Error('Token is undefined')
      }

      try {
        const decodedToken = jwt.verify(token, secret, {
          algorithms: ['HS256'],
        })
        return decodedToken as JWT
      } catch (error) {
        return null
      }
      // ...
    },
  },
  cookies: {
    sessionToken: {
      name: `${secureCookies ? '__Secure-' : ''}next-auth.session-token`,
      options: {
        httpOnly: true,
        sameSite: 'lax',
        path: '/',
        secure: secureCookies,
        domain: hostName == 'localhost' ? hostName : '.' + rootDomain, // add a . in front so that subdomains are included
      },
    },
  },

  // Configure callback functions
  callbacks: {
    // Sign-in callback
    async signIn({ user, account }) {
      // Implement sign-in logic, e.g., create user in database
      if (account?.provider === 'google') {
        const { id, name, image } = user

        const existingUser = await fetchGraphQL({
          document: GetAuthProviderDocument,
          variables: {
            uid: id,
          },
        })

        if (!existingUser.data?.getAuthProvider?.uid) {
          const newUser = await fetchGraphQL({
            document: RegisterWithProviderDocument,
            variables: {
              registerWithProviderInput: {
                uid: id,
                type: AuthProviderType.Google,
                image,
                name: name || '',
              },
            },
          })
        }
      }

      return true
    },
    // Session callback
    async session({ token, session }) {
      // Customize session object based on token data
      if (token) {
        session.user = {
          image: token.picture,
          uid: (token.uid as string) || '',
          email: token.email,
          name: token.name,
        }
      }
      return session
      // ...
    },
  },

  // Configure custom pages
  pages: {
    signIn: '/signIn',
  },
}

export const getAuth = () => getServerSession(authOptions)
</file>

<file path="libs/network/src/fetch/index.ts">
import { TypedDocumentNode } from '@apollo/client/core/types'
import { print } from 'graphql'

export interface FetchResult<TData> {
  data?: TData
  error?: string
}

export interface GraphqlRequestOptions<TData, V> {
  document: TypedDocumentNode<TData, V>
  variables?: V
  config?: RequestInit
  token?: string
}

/**
 * Sends a GraphQL request and returns the response data.
 *
 * @param {TypedDocumentNode<TData, V>} document - The GraphQL query/mutation document.
 * @param {V} [variables] - The variables for the GraphQL query/mutation.
 * @param {RequestInit} [config] - Optional configuration for the fetch request.
 *
 * @returns {Promise<FetchResult<TData>>} The result of the GraphQL request.
 */
export async function fetchGraphQL<TData, V>({
  document,
  variables,
  config,
  token,
}: GraphqlRequestOptions<TData, V>): Promise<FetchResult<TData>> {
  const query = print(document)

  return await fetch(process.env.NEXT_PUBLIC_API_URL + '/graphql', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : null),
    },
    body: JSON.stringify({ query, variables }),
    ...config,
  }).then(async (res) => {
    const { data, errors } = await res.json()
    if (errors) {
      console.log('Error', JSON.stringify(errors))
      return { error: JSON.stringify(errors[0].message) }
    }
    return { data }
  })
}
</file>

<file path="libs/network/src/gql/generated.tsx">
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T,
> = { [_ in K]?: never }
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never
    }
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string }
  String: { input: string; output: string }
  Boolean: { input: boolean; output: boolean }
  Int: { input: number; output: number }
  Float: { input: number; output: number }
  /** A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format. */
  DateTime: { input: any; output: any }
}

export type Address = {
  __typename?: 'Address'
  address: Scalars['String']['output']
  createdAt: Scalars['DateTime']['output']
  garage?: Maybe<Garage>
  garageId?: Maybe<Scalars['Float']['output']>
  id: Scalars['Float']['output']
  lat: Scalars['Float']['output']
  lng: Scalars['Float']['output']
  updatedAt: Scalars['DateTime']['output']
}

export type AddressOrderByWithRelationInput = {
  Garage?: InputMaybe<GarageOrderByWithRelationInput>
  address?: InputMaybe<SortOrder>
  createdAt?: InputMaybe<SortOrder>
  garageId?: InputMaybe<SortOrder>
  id?: InputMaybe<SortOrder>
  lat?: InputMaybe<SortOrder>
  lng?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
}

export type AddressRelationFilter = {
  is?: InputMaybe<AddressWhereInput>
  isNot?: InputMaybe<AddressWhereInput>
}

export enum AddressScalarFieldEnum {
  Address = 'address',
  CreatedAt = 'createdAt',
  GarageId = 'garageId',
  Id = 'id',
  Lat = 'lat',
  Lng = 'lng',
  UpdatedAt = 'updatedAt',
}

export type AddressWhereInput = {
  AND?: InputMaybe<Array<AddressWhereInput>>
  Garage?: InputMaybe<GarageRelationFilter>
  NOT?: InputMaybe<Array<AddressWhereInput>>
  OR?: InputMaybe<Array<AddressWhereInput>>
  address?: InputMaybe<StringFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  garageId?: InputMaybe<IntFilter>
  id?: InputMaybe<IntFilter>
  lat?: InputMaybe<FloatFilter>
  lng?: InputMaybe<FloatFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
}

export type AddressWhereUniqueInput = {
  id: Scalars['Float']['input']
}

export type Admin = {
  __typename?: 'Admin'
  createdAt: Scalars['DateTime']['output']
  uid: Scalars['String']['output']
  updatedAt: Scalars['DateTime']['output']
  user?: Maybe<User>
  verifications: Array<Verification>
  verificationsCount: Scalars['Float']['output']
}

export type AdminOrderByWithRelationInput = {
  User?: InputMaybe<UserOrderByWithRelationInput>
  Verifications?: InputMaybe<VerificationOrderByRelationAggregateInput>
  createdAt?: InputMaybe<SortOrder>
  uid?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
}

export type AdminRelationFilter = {
  is?: InputMaybe<AdminWhereInput>
  isNot?: InputMaybe<AdminWhereInput>
}

export enum AdminScalarFieldEnum {
  CreatedAt = 'createdAt',
  Uid = 'uid',
  UpdatedAt = 'updatedAt',
}

export type AdminWhereInput = {
  AND?: InputMaybe<Array<AdminWhereInput>>
  NOT?: InputMaybe<Array<AdminWhereInput>>
  OR?: InputMaybe<Array<AdminWhereInput>>
  User?: InputMaybe<UserRelationFilter>
  Verifications?: InputMaybe<VerificationListRelationFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  uid?: InputMaybe<StringFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
}

export type AdminWhereUniqueInput = {
  uid: Scalars['String']['input']
}

export type AggregateCountOutput = {
  __typename?: 'AggregateCountOutput'
  count: Scalars['Float']['output']
}

export type AuthProvider = {
  __typename?: 'AuthProvider'
  type: AuthProviderType
  uid: Scalars['String']['output']
}

export enum AuthProviderType {
  Credentials = 'CREDENTIALS',
  Google = 'GOOGLE',
}

export type Booking = {
  __typename?: 'Booking'
  bookingTimeline: Array<BookingTimeline>
  createdAt: Scalars['DateTime']['output']
  customer: Customer
  customerId: Scalars['String']['output']
  endTime: Scalars['DateTime']['output']
  id: Scalars['Float']['output']
  passcode?: Maybe<Scalars['String']['output']>
  phoneNumber?: Maybe<Scalars['String']['output']>
  pricePerHour?: Maybe<Scalars['Float']['output']>
  slot: Slot
  slotId: Scalars['Float']['output']
  startTime: Scalars['DateTime']['output']
  status: BookingStatus
  totalPrice?: Maybe<Scalars['Float']['output']>
  updatedAt: Scalars['DateTime']['output']
  valetAssignment?: Maybe<ValetAssignment>
  vehicleNumber: Scalars['String']['output']
}

export type BookingListRelationFilter = {
  every?: InputMaybe<BookingWhereInput>
  none?: InputMaybe<BookingWhereInput>
  some?: InputMaybe<BookingWhereInput>
}

export type BookingOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>
}

export type BookingOrderByWithRelationInput = {
  BookingTimeline?: InputMaybe<BookingTimelineOrderByRelationAggregateInput>
  Customer?: InputMaybe<CustomerOrderByWithRelationInput>
  Slot?: InputMaybe<SlotOrderByWithRelationInput>
  ValetAssignment?: InputMaybe<ValetAssignmentOrderByWithRelationInput>
  createdAt?: InputMaybe<SortOrder>
  customerId?: InputMaybe<SortOrder>
  endTime?: InputMaybe<SortOrder>
  id?: InputMaybe<SortOrder>
  passcode?: InputMaybe<SortOrder>
  phoneNumber?: InputMaybe<SortOrder>
  pricePerHour?: InputMaybe<SortOrder>
  slotId?: InputMaybe<SortOrder>
  startTime?: InputMaybe<SortOrder>
  status?: InputMaybe<SortOrder>
  totalPrice?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
  vehicleNumber?: InputMaybe<SortOrder>
}

export type BookingRelationFilter = {
  is?: InputMaybe<BookingWhereInput>
  isNot?: InputMaybe<BookingWhereInput>
}

export enum BookingScalarFieldEnum {
  CreatedAt = 'createdAt',
  CustomerId = 'customerId',
  EndTime = 'endTime',
  Id = 'id',
  Passcode = 'passcode',
  PhoneNumber = 'phoneNumber',
  PricePerHour = 'pricePerHour',
  SlotId = 'slotId',
  StartTime = 'startTime',
  Status = 'status',
  TotalPrice = 'totalPrice',
  UpdatedAt = 'updatedAt',
  VehicleNumber = 'vehicleNumber',
}

export enum BookingStatus {
  Booked = 'BOOKED',
  CheckedIn = 'CHECKED_IN',
  CheckedOut = 'CHECKED_OUT',
  ValetAssignedForCheckIn = 'VALET_ASSIGNED_FOR_CHECK_IN',
  ValetAssignedForCheckOut = 'VALET_ASSIGNED_FOR_CHECK_OUT',
  ValetPickedUp = 'VALET_PICKED_UP',
  ValetReturned = 'VALET_RETURNED',
}

export type BookingTimeline = {
  __typename?: 'BookingTimeline'
  bookingId: Scalars['Float']['output']
  id: Scalars['Float']['output']
  managerId?: Maybe<Scalars['String']['output']>
  status: BookingStatus
  timestamp: Scalars['DateTime']['output']
  valetId?: Maybe<Scalars['String']['output']>
}

export type BookingTimelineListRelationFilter = {
  every?: InputMaybe<BookingTimelineWhereInput>
  none?: InputMaybe<BookingTimelineWhereInput>
  some?: InputMaybe<BookingTimelineWhereInput>
}

export type BookingTimelineOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>
}

export type BookingTimelineOrderByWithRelationInput = {
  Booking?: InputMaybe<BookingOrderByWithRelationInput>
  Manager?: InputMaybe<ManagerOrderByWithRelationInput>
  Valet?: InputMaybe<ValetOrderByWithRelationInput>
  bookingId?: InputMaybe<SortOrder>
  id?: InputMaybe<SortOrder>
  managerId?: InputMaybe<SortOrder>
  status?: InputMaybe<SortOrder>
  timestamp?: InputMaybe<SortOrder>
  valetId?: InputMaybe<SortOrder>
}

export enum BookingTimelineScalarFieldEnum {
  BookingId = 'bookingId',
  Id = 'id',
  ManagerId = 'managerId',
  Status = 'status',
  Timestamp = 'timestamp',
  ValetId = 'valetId',
}

export type BookingTimelineWhereInput = {
  AND?: InputMaybe<Array<BookingTimelineWhereInput>>
  Booking?: InputMaybe<BookingRelationFilter>
  Manager?: InputMaybe<ManagerRelationFilter>
  NOT?: InputMaybe<Array<BookingTimelineWhereInput>>
  OR?: InputMaybe<Array<BookingTimelineWhereInput>>
  Valet?: InputMaybe<ValetRelationFilter>
  bookingId?: InputMaybe<IntFilter>
  id?: InputMaybe<IntFilter>
  managerId?: InputMaybe<StringFilter>
  status?: InputMaybe<BookingStatus>
  timestamp?: InputMaybe<DateTimeFilter>
  valetId?: InputMaybe<StringFilter>
}

export type BookingTimelineWhereUniqueInput = {
  id: Scalars['Float']['input']
}

export type BookingWhereInput = {
  AND?: InputMaybe<Array<BookingWhereInput>>
  BookingTimeline?: InputMaybe<BookingTimelineListRelationFilter>
  Customer?: InputMaybe<CustomerRelationFilter>
  NOT?: InputMaybe<Array<BookingWhereInput>>
  OR?: InputMaybe<Array<BookingWhereInput>>
  Slot?: InputMaybe<SlotRelationFilter>
  ValetAssignment?: InputMaybe<ValetAssignmentRelationFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  customerId?: InputMaybe<StringFilter>
  endTime?: InputMaybe<DateTimeFilter>
  id?: InputMaybe<IntFilter>
  passcode?: InputMaybe<StringFilter>
  phoneNumber?: InputMaybe<StringFilter>
  pricePerHour?: InputMaybe<FloatFilter>
  slotId?: InputMaybe<IntFilter>
  startTime?: InputMaybe<DateTimeFilter>
  status?: InputMaybe<EnumBookingStatusFilter>
  totalPrice?: InputMaybe<FloatFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
  vehicleNumber?: InputMaybe<StringFilter>
}

export type BookingWhereUniqueInput = {
  id: Scalars['Float']['input']
}

export type BoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']['input']>
  not?: InputMaybe<Scalars['Boolean']['input']>
}

export type Company = {
  __typename?: 'Company'
  createdAt: Scalars['DateTime']['output']
  description?: Maybe<Scalars['String']['output']>
  displayName?: Maybe<Scalars['String']['output']>
  garages: Array<Garage>
  id: Scalars['Float']['output']
  managers: Array<Manager>
  updatedAt: Scalars['DateTime']['output']
}

export type CompanyOrderByWithRelationInput = {
  Garages?: InputMaybe<GarageOrderByRelationAggregateInput>
  Managers?: InputMaybe<ManagerOrderByRelationAggregateInput>
  Valets?: InputMaybe<ValetOrderByRelationAggregateInput>
  createdAt?: InputMaybe<SortOrder>
  description?: InputMaybe<SortOrder>
  displayName?: InputMaybe<SortOrder>
  id?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
}

export type CompanyRelationFilter = {
  is?: InputMaybe<CompanyWhereInput>
  isNot?: InputMaybe<CompanyWhereInput>
}

export enum CompanyScalarFieldEnum {
  CreatedAt = 'createdAt',
  Description = 'description',
  DisplayName = 'displayName',
  Id = 'id',
  UpdatedAt = 'updatedAt',
}

export type CompanyWhereInput = {
  AND?: InputMaybe<Array<CompanyWhereInput>>
  Garages?: InputMaybe<GarageListRelationFilter>
  Managers?: InputMaybe<ManagerListRelationFilter>
  NOT?: InputMaybe<Array<CompanyWhereInput>>
  OR?: InputMaybe<Array<CompanyWhereInput>>
  Valets?: InputMaybe<ValetListRelationFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  description?: InputMaybe<StringFilter>
  displayName?: InputMaybe<StringFilter>
  id?: InputMaybe<IntFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
}

export type CompanyWhereUniqueInput = {
  id: Scalars['Float']['input']
}

export type CreateAddressInput = {
  address: Scalars['String']['input']
  garageId?: InputMaybe<Scalars['Float']['input']>
  lat: Scalars['Float']['input']
  lng: Scalars['Float']['input']
}

export type CreateAddressInputWithoutGarageId = {
  address: Scalars['String']['input']
  lat: Scalars['Float']['input']
  lng: Scalars['Float']['input']
}

export type CreateAdminInput = {
  uid: Scalars['String']['input']
}

export type CreateBookingInput = {
  customerId: Scalars['String']['input']
  endTime: Scalars['DateTime']['input']
  garageId: Scalars['Float']['input']
  phoneNumber?: InputMaybe<Scalars['String']['input']>
  pricePerHour?: InputMaybe<Scalars['Float']['input']>
  startTime: Scalars['DateTime']['input']
  totalPrice?: InputMaybe<Scalars['Float']['input']>
  type: SlotType
  valetAssignment?: InputMaybe<CreateValetAssignmentInputWithoutBookingId>
  vehicleNumber: Scalars['String']['input']
}

export type CreateBookingTimelineInput = {
  bookingId: Scalars['Float']['input']
  status: BookingStatus
}

export type CreateCompanyInput = {
  description?: InputMaybe<Scalars['String']['input']>
  displayName?: InputMaybe<Scalars['String']['input']>
  managerId: Scalars['String']['input']
  managerName?: InputMaybe<Scalars['String']['input']>
}

export type CreateCustomerInput = {
  displayName?: InputMaybe<Scalars['String']['input']>
  uid: Scalars['String']['input']
}

export type CreateGarageInput = {
  Address: CreateAddressInputWithoutGarageId
  Slots: Array<CreateSlotInputWithoutGarageId>
  description?: InputMaybe<Scalars['String']['input']>
  displayName?: InputMaybe<Scalars['String']['input']>
  images: Array<Scalars['String']['input']>
}

export type CreateManagerInput = {
  displayName?: InputMaybe<Scalars['String']['input']>
  uid: Scalars['String']['input']
}

export type CreateReviewInput = {
  comment?: InputMaybe<Scalars['String']['input']>
  customerId: Scalars['String']['input']
  garageId: Scalars['Float']['input']
  rating: Scalars['Float']['input']
}

export type CreateSlotInput = {
  displayName?: InputMaybe<Scalars['String']['input']>
  garageId: Scalars['Float']['input']
  height?: InputMaybe<Scalars['Float']['input']>
  length?: InputMaybe<Scalars['Float']['input']>
  pricePerHour: Scalars['Float']['input']
  type: SlotType
  width?: InputMaybe<Scalars['Float']['input']>
}

export type CreateSlotInputWithoutGarageId = {
  count: Scalars['Float']['input']
  displayName?: InputMaybe<Scalars['String']['input']>
  height?: InputMaybe<Scalars['Float']['input']>
  length?: InputMaybe<Scalars['Float']['input']>
  pricePerHour: Scalars['Float']['input']
  type: SlotType
  width?: InputMaybe<Scalars['Float']['input']>
}

export type CreateValetAssignmentInput = {
  bookingId: Scalars['Float']['input']
  pickupLat: Scalars['Float']['input']
  pickupLng: Scalars['Float']['input']
  pickupValetId?: InputMaybe<Scalars['String']['input']>
  returnLat?: InputMaybe<Scalars['Float']['input']>
  returnLng?: InputMaybe<Scalars['Float']['input']>
  returnValetId?: InputMaybe<Scalars['String']['input']>
}

export type CreateValetAssignmentInputWithoutBookingId = {
  pickupLat: Scalars['Float']['input']
  pickupLng: Scalars['Float']['input']
  returnLat?: InputMaybe<Scalars['Float']['input']>
  returnLng?: InputMaybe<Scalars['Float']['input']>
}

export type CreateValetInput = {
  companyId?: InputMaybe<Scalars['Float']['input']>
  displayName: Scalars['String']['input']
  image?: InputMaybe<Scalars['String']['input']>
  licenceID: Scalars['String']['input']
  uid: Scalars['String']['input']
}

export type CreateVerificationInput = {
  garageId: Scalars['Float']['input']
  verified: Scalars['Boolean']['input']
}

export type Customer = {
  __typename?: 'Customer'
  bookings: Array<Booking>
  createdAt: Scalars['DateTime']['output']
  displayName?: Maybe<Scalars['String']['output']>
  uid: Scalars['String']['output']
  updatedAt: Scalars['DateTime']['output']
  user?: Maybe<User>
}

export type CustomerOrderByWithRelationInput = {
  Bookings?: InputMaybe<BookingOrderByRelationAggregateInput>
  Reviews?: InputMaybe<ReviewOrderByRelationAggregateInput>
  User?: InputMaybe<UserOrderByWithRelationInput>
  createdAt?: InputMaybe<SortOrder>
  displayName?: InputMaybe<SortOrder>
  uid?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
}

export type CustomerRelationFilter = {
  is?: InputMaybe<CustomerWhereInput>
  isNot?: InputMaybe<CustomerWhereInput>
}

export enum CustomerScalarFieldEnum {
  CreatedAt = 'createdAt',
  DisplayName = 'displayName',
  Uid = 'uid',
  UpdatedAt = 'updatedAt',
}

export type CustomerWhereInput = {
  AND?: InputMaybe<Array<CustomerWhereInput>>
  Bookings?: InputMaybe<BookingListRelationFilter>
  NOT?: InputMaybe<Array<CustomerWhereInput>>
  OR?: InputMaybe<Array<CustomerWhereInput>>
  Reviews?: InputMaybe<ReviewListRelationFilter>
  User?: InputMaybe<UserRelationFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  displayName?: InputMaybe<StringFilter>
  uid?: InputMaybe<StringFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
}

export type CustomerWhereUniqueInput = {
  uid: Scalars['String']['input']
}

export type DateFilterInput = {
  end: Scalars['String']['input']
  start: Scalars['String']['input']
}

export type DateTimeFilter = {
  equals?: InputMaybe<Scalars['String']['input']>
  gt?: InputMaybe<Scalars['String']['input']>
  gte?: InputMaybe<Scalars['String']['input']>
  in?: InputMaybe<Array<Scalars['String']['input']>>
  lt?: InputMaybe<Scalars['String']['input']>
  lte?: InputMaybe<Scalars['String']['input']>
  notIn?: InputMaybe<Array<Scalars['String']['input']>>
}

export type EnumBookingStatusFilter = {
  equals?: InputMaybe<BookingStatus>
  in?: InputMaybe<Array<BookingStatus>>
  not?: InputMaybe<BookingStatus>
  notIn?: InputMaybe<Array<BookingStatus>>
}

export type EnumSlotTypeFilter = {
  equals?: InputMaybe<SlotType>
  in?: InputMaybe<Array<SlotType>>
  not?: InputMaybe<SlotType>
  notIn?: InputMaybe<Array<SlotType>>
}

export type FloatFilter = {
  equals?: InputMaybe<Scalars['Float']['input']>
  gt?: InputMaybe<Scalars['Float']['input']>
  gte?: InputMaybe<Scalars['Float']['input']>
  lt?: InputMaybe<Scalars['Float']['input']>
  lte?: InputMaybe<Scalars['Float']['input']>
  not?: InputMaybe<Scalars['Float']['input']>
}

export type Garage = {
  __typename?: 'Garage'
  address?: Maybe<Address>
  availableSlots: Array<MinimalSlotGroupBy>
  company: Company
  companyId: Scalars['Float']['output']
  createdAt: Scalars['DateTime']['output']
  description?: Maybe<Scalars['String']['output']>
  displayName?: Maybe<Scalars['String']['output']>
  id: Scalars['Float']['output']
  images: Array<Scalars['String']['output']>
  slotCounts: Array<SlotTypeCount>
  slots: Array<Slot>
  updatedAt: Scalars['DateTime']['output']
  verification?: Maybe<Verification>
}

export type GarageAvailableSlotsArgs = {
  dateFilter: DateFilterInput
  slotsFilter?: InputMaybe<SlotWhereInput>
}

export type GarageFilter = {
  orderBy?: InputMaybe<Array<GarageOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<GarageWhereInput>
}

export type GarageListRelationFilter = {
  every?: InputMaybe<GarageWhereInput>
  none?: InputMaybe<GarageWhereInput>
  some?: InputMaybe<GarageWhereInput>
}

export type GarageOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>
}

export type GarageOrderByWithRelationInput = {
  Address?: InputMaybe<AddressOrderByWithRelationInput>
  Company?: InputMaybe<CompanyOrderByWithRelationInput>
  Reviews?: InputMaybe<ReviewOrderByRelationAggregateInput>
  Slots?: InputMaybe<SlotOrderByRelationAggregateInput>
  Verification?: InputMaybe<VerificationOrderByWithRelationInput>
  companyId?: InputMaybe<SortOrder>
  createdAt?: InputMaybe<SortOrder>
  description?: InputMaybe<SortOrder>
  displayName?: InputMaybe<SortOrder>
  id?: InputMaybe<SortOrder>
  images?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
}

export type GarageRelationFilter = {
  is?: InputMaybe<GarageWhereInput>
  isNot?: InputMaybe<GarageWhereInput>
}

export enum GarageScalarFieldEnum {
  CompanyId = 'companyId',
  CreatedAt = 'createdAt',
  Description = 'description',
  DisplayName = 'displayName',
  Id = 'id',
  Images = 'images',
  UpdatedAt = 'updatedAt',
}

export type GarageWhereInput = {
  AND?: InputMaybe<Array<GarageWhereInput>>
  Address?: InputMaybe<AddressRelationFilter>
  Company?: InputMaybe<CompanyRelationFilter>
  NOT?: InputMaybe<Array<GarageWhereInput>>
  OR?: InputMaybe<Array<GarageWhereInput>>
  Reviews?: InputMaybe<ReviewListRelationFilter>
  Slots?: InputMaybe<SlotListRelationFilter>
  Verification?: InputMaybe<VerificationRelationFilter>
  companyId?: InputMaybe<IntFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  description?: InputMaybe<StringFilter>
  displayName?: InputMaybe<StringFilter>
  id?: InputMaybe<IntFilter>
  images?: InputMaybe<StringListFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
}

export type GarageWhereUniqueInput = {
  id: Scalars['Float']['input']
}

export type IntFilter = {
  equals?: InputMaybe<Scalars['Float']['input']>
  gt?: InputMaybe<Scalars['Float']['input']>
  gte?: InputMaybe<Scalars['Float']['input']>
  lt?: InputMaybe<Scalars['Float']['input']>
  lte?: InputMaybe<Scalars['Float']['input']>
}

export type LocationFilterInput = {
  ne_lat: Scalars['Float']['input']
  ne_lng: Scalars['Float']['input']
  sw_lat: Scalars['Float']['input']
  sw_lng: Scalars['Float']['input']
}

export type LoginInput = {
  email: Scalars['String']['input']
  password: Scalars['String']['input']
}

export type LoginOutput = {
  __typename?: 'LoginOutput'
  token: Scalars['String']['output']
  user: User
}

export type Manager = {
  __typename?: 'Manager'
  company?: Maybe<Company>
  companyId: Scalars['Float']['output']
  createdAt: Scalars['DateTime']['output']
  displayName?: Maybe<Scalars['String']['output']>
  uid: Scalars['String']['output']
  updatedAt: Scalars['DateTime']['output']
}

export type ManagerListRelationFilter = {
  every?: InputMaybe<ManagerWhereInput>
  none?: InputMaybe<ManagerWhereInput>
  some?: InputMaybe<ManagerWhereInput>
}

export type ManagerOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>
}

export type ManagerOrderByWithRelationInput = {
  BookingTimeline?: InputMaybe<BookingTimelineOrderByRelationAggregateInput>
  Company?: InputMaybe<CompanyOrderByWithRelationInput>
  User?: InputMaybe<UserOrderByWithRelationInput>
  companyId?: InputMaybe<SortOrder>
  createdAt?: InputMaybe<SortOrder>
  displayName?: InputMaybe<SortOrder>
  uid?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
}

export type ManagerRelationFilter = {
  is?: InputMaybe<ManagerWhereInput>
  isNot?: InputMaybe<ManagerWhereInput>
}

export enum ManagerScalarFieldEnum {
  CompanyId = 'companyId',
  CreatedAt = 'createdAt',
  DisplayName = 'displayName',
  Uid = 'uid',
  UpdatedAt = 'updatedAt',
}

export type ManagerWhereInput = {
  AND?: InputMaybe<Array<ManagerWhereInput>>
  BookingTimeline?: InputMaybe<BookingTimelineListRelationFilter>
  Company?: InputMaybe<CompanyRelationFilter>
  NOT?: InputMaybe<Array<ManagerWhereInput>>
  OR?: InputMaybe<Array<ManagerWhereInput>>
  User?: InputMaybe<UserRelationFilter>
  companyId?: InputMaybe<IntFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  displayName?: InputMaybe<StringFilter>
  uid?: InputMaybe<StringFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
}

export type ManagerWhereUniqueInput = {
  uid: Scalars['String']['input']
}

export type MinimalSlotGroupBy = {
  __typename?: 'MinimalSlotGroupBy'
  count: Scalars['Float']['output']
  pricePerHour: Scalars['Float']['output']
  type: SlotType
}

export type Mutation = {
  __typename?: 'Mutation'
  assignValet: Booking
  createAddress: Address
  createAdmin: Admin
  createBooking: Booking
  createBookingTimeline: BookingTimeline
  createCompany: Company
  createCustomer: Customer
  createGarage: Garage
  createManager: Manager
  createManySlots: ReturnCount
  createReview: Review
  createSlot: Slot
  createValet: Valet
  createValetAssignment: ValetAssignment
  createVerification: Verification
  login: LoginOutput
  registerWithCredentials: User
  registerWithProvider: User
  removeAddress: Address
  removeAdmin: Admin
  removeBooking: Booking
  removeBookingTimeline: BookingTimeline
  removeCompany: Company
  removeCustomer: Customer
  removeGarage: Garage
  removeManager: Manager
  removeReview: Review
  removeSlot: Slot
  removeUser: User
  removeValet: Valet
  removeValetAssignment: ValetAssignment
  removeVerification: Verification
  updateAddress: Address
  updateAdmin: Admin
  updateBooking: Booking
  updateBookingTimeline: BookingTimeline
  updateCompany: Company
  updateCustomer: Customer
  updateGarage: Garage
  updateManager: Manager
  updateReview: Review
  updateSlot: Slot
  updateUser: User
  updateValet: Valet
  updateValetAssignment: ValetAssignment
  updateVerification: Verification
}

export type MutationAssignValetArgs = {
  bookingId: Scalars['Float']['input']
  status: Scalars['String']['input']
}

export type MutationCreateAddressArgs = {
  createAddressInput: CreateAddressInput
}

export type MutationCreateAdminArgs = {
  createAdminInput: CreateAdminInput
}

export type MutationCreateBookingArgs = {
  createBookingInput: CreateBookingInput
}

export type MutationCreateBookingTimelineArgs = {
  createBookingTimelineInput: CreateBookingTimelineInput
}

export type MutationCreateCompanyArgs = {
  createCompanyInput: CreateCompanyInput
}

export type MutationCreateCustomerArgs = {
  createCustomerInput: CreateCustomerInput
}

export type MutationCreateGarageArgs = {
  createGarageInput: CreateGarageInput
}

export type MutationCreateManagerArgs = {
  createManagerInput: CreateManagerInput
}

export type MutationCreateManySlotsArgs = {
  count: Scalars['Float']['input']
  createSlotInput: CreateSlotInput
}

export type MutationCreateReviewArgs = {
  createReviewInput: CreateReviewInput
}

export type MutationCreateSlotArgs = {
  createSlotInput: CreateSlotInput
}

export type MutationCreateValetArgs = {
  createValetInput: CreateValetInput
}

export type MutationCreateValetAssignmentArgs = {
  createValetAssignmentInput: CreateValetAssignmentInput
}

export type MutationCreateVerificationArgs = {
  createVerificationInput: CreateVerificationInput
}

export type MutationLoginArgs = {
  loginInput: LoginInput
}

export type MutationRegisterWithCredentialsArgs = {
  registerWithCredentialsInput: RegisterWithCredentialsInput
}

export type MutationRegisterWithProviderArgs = {
  registerWithProviderInput: RegisterWithProviderInput
}

export type MutationRemoveAddressArgs = {
  where: AddressWhereUniqueInput
}

export type MutationRemoveAdminArgs = {
  where: AdminWhereUniqueInput
}

export type MutationRemoveBookingArgs = {
  where: BookingWhereUniqueInput
}

export type MutationRemoveBookingTimelineArgs = {
  where: BookingTimelineWhereUniqueInput
}

export type MutationRemoveCompanyArgs = {
  where: CompanyWhereUniqueInput
}

export type MutationRemoveCustomerArgs = {
  where: CustomerWhereUniqueInput
}

export type MutationRemoveGarageArgs = {
  where: GarageWhereUniqueInput
}

export type MutationRemoveManagerArgs = {
  where: ManagerWhereUniqueInput
}

export type MutationRemoveReviewArgs = {
  where: ReviewWhereUniqueInput
}

export type MutationRemoveSlotArgs = {
  where: SlotWhereUniqueInput
}

export type MutationRemoveUserArgs = {
  where: UserWhereUniqueInput
}

export type MutationRemoveValetArgs = {
  where: ValetWhereUniqueInput
}

export type MutationRemoveValetAssignmentArgs = {
  where: ValetAssignmentWhereUniqueInput
}

export type MutationRemoveVerificationArgs = {
  where: VerificationWhereUniqueInput
}

export type MutationUpdateAddressArgs = {
  updateAddressInput: UpdateAddressInput
}

export type MutationUpdateAdminArgs = {
  updateAdminInput: UpdateAdminInput
}

export type MutationUpdateBookingArgs = {
  updateBookingInput: UpdateBookingInput
}

export type MutationUpdateBookingTimelineArgs = {
  updateBookingTimelineInput: UpdateBookingTimelineInput
}

export type MutationUpdateCompanyArgs = {
  updateCompanyInput: UpdateCompanyInput
}

export type MutationUpdateCustomerArgs = {
  updateCustomerInput: UpdateCustomerInput
}

export type MutationUpdateGarageArgs = {
  updateGarageInput: UpdateGarageInput
}

export type MutationUpdateManagerArgs = {
  updateManagerInput: UpdateManagerInput
}

export type MutationUpdateReviewArgs = {
  updateReviewInput: UpdateReviewInput
}

export type MutationUpdateSlotArgs = {
  updateSlotInput: UpdateSlotInput
}

export type MutationUpdateUserArgs = {
  updateUserInput: UpdateUserInput
}

export type MutationUpdateValetArgs = {
  updateValetInput: UpdateValetInput
}

export type MutationUpdateValetAssignmentArgs = {
  updateValetAssignmentInput: UpdateValetAssignmentInput
}

export type MutationUpdateVerificationArgs = {
  updateVerificationInput: UpdateVerificationInput
}

export type Query = {
  __typename?: 'Query'
  address: Address
  addresses: Array<Address>
  admin: Admin
  adminMe: Admin
  admins: Array<Admin>
  adminsCount: Scalars['Float']['output']
  booking: Booking
  bookingTimeline: BookingTimeline
  bookingTimelines: Array<BookingTimeline>
  bookings: Array<Booking>
  bookingsCount: AggregateCountOutput
  bookingsForCustomer: Array<Booking>
  bookingsForGarage: Array<Booking>
  bookingsForValet: Array<Booking>
  companies: Array<Company>
  company: Company
  companyValets: Array<Valet>
  companyValetsTotal: Scalars['Float']['output']
  customer: Customer
  customers: Array<Customer>
  garage: Garage
  garages: Array<Garage>
  garagesCount: AggregateCountOutput
  getAuthProvider?: Maybe<AuthProvider>
  manager: Manager
  managers: Array<Manager>
  myCompany: Company
  review: Review
  reviews: Array<Review>
  searchGarages: Array<Garage>
  slot: Slot
  slots: Array<Slot>
  user: User
  users: Array<User>
  valet: Valet
  valetAssignment: ValetAssignment
  valetAssignments: Array<ValetAssignment>
  valetDrops: Array<Booking>
  valetDropsTotal: Scalars['Float']['output']
  valetMe?: Maybe<Valet>
  valetPickups: Array<Booking>
  valetPickupsTotal: Scalars['Float']['output']
  valets: Array<Valet>
  verification: Verification
  verifications: Array<Verification>
  whoami: User
}

export type QueryAddressArgs = {
  where: AddressWhereUniqueInput
}

export type QueryAddressesArgs = {
  cursor?: InputMaybe<AddressWhereUniqueInput>
  distinct?: InputMaybe<Array<AddressScalarFieldEnum>>
  orderBy?: InputMaybe<Array<AddressOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<AddressWhereInput>
}

export type QueryAdminArgs = {
  where: AdminWhereUniqueInput
}

export type QueryAdminsArgs = {
  cursor?: InputMaybe<AdminWhereUniqueInput>
  distinct?: InputMaybe<Array<AdminScalarFieldEnum>>
  orderBy?: InputMaybe<Array<AdminOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<AdminWhereInput>
}

export type QueryAdminsCountArgs = {
  where?: InputMaybe<AdminWhereInput>
}

export type QueryBookingArgs = {
  where: BookingWhereUniqueInput
}

export type QueryBookingTimelineArgs = {
  where: BookingTimelineWhereUniqueInput
}

export type QueryBookingTimelinesArgs = {
  cursor?: InputMaybe<BookingTimelineWhereUniqueInput>
  distinct?: InputMaybe<Array<BookingTimelineScalarFieldEnum>>
  orderBy?: InputMaybe<Array<BookingTimelineOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<BookingTimelineWhereInput>
}

export type QueryBookingsArgs = {
  cursor?: InputMaybe<BookingWhereUniqueInput>
  distinct?: InputMaybe<Array<BookingScalarFieldEnum>>
  orderBy?: InputMaybe<Array<BookingOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<BookingWhereInput>
}

export type QueryBookingsCountArgs = {
  where?: InputMaybe<BookingWhereInput>
}

export type QueryBookingsForCustomerArgs = {
  cursor?: InputMaybe<BookingWhereUniqueInput>
  distinct?: InputMaybe<Array<BookingScalarFieldEnum>>
  orderBy?: InputMaybe<Array<BookingOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<BookingWhereInput>
}

export type QueryBookingsForGarageArgs = {
  cursor?: InputMaybe<BookingWhereUniqueInput>
  distinct?: InputMaybe<Array<BookingScalarFieldEnum>>
  orderBy?: InputMaybe<Array<BookingOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<BookingWhereInput>
}

export type QueryBookingsForValetArgs = {
  cursor?: InputMaybe<BookingWhereUniqueInput>
  distinct?: InputMaybe<Array<BookingScalarFieldEnum>>
  orderBy?: InputMaybe<Array<BookingOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<BookingWhereInput>
}

export type QueryCompaniesArgs = {
  cursor?: InputMaybe<CompanyWhereUniqueInput>
  distinct?: InputMaybe<Array<CompanyScalarFieldEnum>>
  orderBy?: InputMaybe<Array<CompanyOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<CompanyWhereInput>
}

export type QueryCompanyArgs = {
  where: CompanyWhereUniqueInput
}

export type QueryCompanyValetsArgs = {
  cursor?: InputMaybe<ValetWhereUniqueInput>
  distinct?: InputMaybe<Array<ValetScalarFieldEnum>>
  orderBy?: InputMaybe<Array<ValetOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<ValetWhereInput>
}

export type QueryCompanyValetsTotalArgs = {
  where?: InputMaybe<ValetWhereInput>
}

export type QueryCustomerArgs = {
  where: CustomerWhereUniqueInput
}

export type QueryCustomersArgs = {
  cursor?: InputMaybe<CustomerWhereUniqueInput>
  distinct?: InputMaybe<Array<CustomerScalarFieldEnum>>
  orderBy?: InputMaybe<Array<CustomerOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<CustomerWhereInput>
}

export type QueryGarageArgs = {
  where: GarageWhereUniqueInput
}

export type QueryGaragesArgs = {
  cursor?: InputMaybe<GarageWhereUniqueInput>
  distinct?: InputMaybe<Array<GarageScalarFieldEnum>>
  orderBy?: InputMaybe<Array<GarageOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<GarageWhereInput>
}

export type QueryGaragesCountArgs = {
  where?: InputMaybe<GarageWhereInput>
}

export type QueryGetAuthProviderArgs = {
  uid: Scalars['String']['input']
}

export type QueryManagerArgs = {
  where: ManagerWhereUniqueInput
}

export type QueryManagersArgs = {
  cursor?: InputMaybe<ManagerWhereUniqueInput>
  distinct?: InputMaybe<Array<ManagerScalarFieldEnum>>
  orderBy?: InputMaybe<Array<ManagerOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<ManagerWhereInput>
}

export type QueryReviewArgs = {
  where: ReviewWhereUniqueInput
}

export type QueryReviewsArgs = {
  cursor?: InputMaybe<ReviewWhereUniqueInput>
  distinct?: InputMaybe<Array<ReviewScalarFieldEnum>>
  orderBy?: InputMaybe<Array<ReviewOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<ReviewWhereInput>
}

export type QuerySearchGaragesArgs = {
  dateFilter: DateFilterInput
  garageFilter?: InputMaybe<GarageFilter>
  locationFilter: LocationFilterInput
  slotsFilter?: InputMaybe<SlotWhereInput>
}

export type QuerySlotArgs = {
  where: SlotWhereUniqueInput
}

export type QuerySlotsArgs = {
  cursor?: InputMaybe<SlotWhereUniqueInput>
  distinct?: InputMaybe<Array<SlotScalarFieldEnum>>
  orderBy?: InputMaybe<Array<SlotOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<SlotWhereInput>
}

export type QueryUserArgs = {
  where: UserWhereUniqueInput
}

export type QueryUsersArgs = {
  cursor?: InputMaybe<UserWhereUniqueInput>
  distinct?: InputMaybe<Array<UserScalarFieldEnum>>
  orderBy?: InputMaybe<Array<UserOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<UserWhereInput>
}

export type QueryValetArgs = {
  where: ValetWhereUniqueInput
}

export type QueryValetAssignmentArgs = {
  where: ValetAssignmentWhereUniqueInput
}

export type QueryValetAssignmentsArgs = {
  cursor?: InputMaybe<ValetAssignmentWhereUniqueInput>
  distinct?: InputMaybe<Array<ValetAssignmentScalarFieldEnum>>
  orderBy?: InputMaybe<Array<ValetAssignmentOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<ValetAssignmentWhereInput>
}

export type QueryValetDropsArgs = {
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
}

export type QueryValetPickupsArgs = {
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
}

export type QueryValetsArgs = {
  cursor?: InputMaybe<ValetWhereUniqueInput>
  distinct?: InputMaybe<Array<ValetScalarFieldEnum>>
  orderBy?: InputMaybe<Array<ValetOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<ValetWhereInput>
}

export type QueryVerificationArgs = {
  where: VerificationWhereUniqueInput
}

export type QueryVerificationsArgs = {
  cursor?: InputMaybe<VerificationWhereUniqueInput>
  distinct?: InputMaybe<Array<VerificationScalarFieldEnum>>
  orderBy?: InputMaybe<Array<VerificationOrderByWithRelationInput>>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  where?: InputMaybe<VerificationWhereInput>
}

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive',
}

export type RegisterWithCredentialsInput = {
  email: Scalars['String']['input']
  image?: InputMaybe<Scalars['String']['input']>
  name?: InputMaybe<Scalars['String']['input']>
  password: Scalars['String']['input']
}

export type RegisterWithProviderInput = {
  image?: InputMaybe<Scalars['String']['input']>
  name?: InputMaybe<Scalars['String']['input']>
  type: AuthProviderType
  uid: Scalars['String']['input']
}

export type ReturnCount = {
  __typename?: 'ReturnCount'
  count: Scalars['Float']['output']
}

export type Review = {
  __typename?: 'Review'
  comment?: Maybe<Scalars['String']['output']>
  createdAt: Scalars['DateTime']['output']
  customerId: Scalars['String']['output']
  garageId: Scalars['Float']['output']
  id: Scalars['Float']['output']
  rating: Scalars['Float']['output']
  updatedAt: Scalars['DateTime']['output']
}

export type ReviewListRelationFilter = {
  every?: InputMaybe<ReviewWhereInput>
  none?: InputMaybe<ReviewWhereInput>
  some?: InputMaybe<ReviewWhereInput>
}

export type ReviewOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>
}

export type ReviewOrderByWithRelationInput = {
  Customer?: InputMaybe<CustomerOrderByWithRelationInput>
  Garage?: InputMaybe<GarageOrderByWithRelationInput>
  comment?: InputMaybe<SortOrder>
  createdAt?: InputMaybe<SortOrder>
  customerId?: InputMaybe<SortOrder>
  garageId?: InputMaybe<SortOrder>
  id?: InputMaybe<SortOrder>
  rating?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
}

export enum ReviewScalarFieldEnum {
  Comment = 'comment',
  CreatedAt = 'createdAt',
  CustomerId = 'customerId',
  GarageId = 'garageId',
  Id = 'id',
  Rating = 'rating',
  UpdatedAt = 'updatedAt',
}

export type ReviewWhereInput = {
  AND?: InputMaybe<Array<ReviewWhereInput>>
  Customer?: InputMaybe<CustomerRelationFilter>
  Garage?: InputMaybe<GarageRelationFilter>
  NOT?: InputMaybe<Array<ReviewWhereInput>>
  OR?: InputMaybe<Array<ReviewWhereInput>>
  comment?: InputMaybe<StringFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  customerId?: InputMaybe<StringFilter>
  garageId?: InputMaybe<IntFilter>
  id?: InputMaybe<IntFilter>
  rating?: InputMaybe<IntFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
}

export type ReviewWhereUniqueInput = {
  id: Scalars['Float']['input']
}

export type Slot = {
  __typename?: 'Slot'
  bookings: Array<Booking>
  createdAt: Scalars['DateTime']['output']
  displayName?: Maybe<Scalars['String']['output']>
  garage: Garage
  garageId: Scalars['Float']['output']
  height?: Maybe<Scalars['Float']['output']>
  id: Scalars['Float']['output']
  length?: Maybe<Scalars['Float']['output']>
  pricePerHour: Scalars['Float']['output']
  type: SlotType
  updatedAt: Scalars['DateTime']['output']
  width?: Maybe<Scalars['Float']['output']>
}

export type SlotListRelationFilter = {
  every?: InputMaybe<SlotWhereInput>
  none?: InputMaybe<SlotWhereInput>
  some?: InputMaybe<SlotWhereInput>
}

export type SlotOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>
}

export type SlotOrderByWithRelationInput = {
  Bookings?: InputMaybe<BookingOrderByRelationAggregateInput>
  Garage?: InputMaybe<GarageOrderByWithRelationInput>
  createdAt?: InputMaybe<SortOrder>
  displayName?: InputMaybe<SortOrder>
  garageId?: InputMaybe<SortOrder>
  height?: InputMaybe<SortOrder>
  id?: InputMaybe<SortOrder>
  length?: InputMaybe<SortOrder>
  pricePerHour?: InputMaybe<SortOrder>
  type?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
  width?: InputMaybe<SortOrder>
}

export type SlotRelationFilter = {
  is?: InputMaybe<SlotWhereInput>
  isNot?: InputMaybe<SlotWhereInput>
}

export enum SlotScalarFieldEnum {
  CreatedAt = 'createdAt',
  DisplayName = 'displayName',
  GarageId = 'garageId',
  Height = 'height',
  Id = 'id',
  Length = 'length',
  PricePerHour = 'pricePerHour',
  Type = 'type',
  UpdatedAt = 'updatedAt',
  Width = 'width',
}

export enum SlotType {
  Bicycle = 'BICYCLE',
  Bike = 'BIKE',
  Car = 'CAR',
  Heavy = 'HEAVY',
}

export type SlotTypeCount = {
  __typename?: 'SlotTypeCount'
  count?: Maybe<Scalars['Float']['output']>
  type: SlotType
}

export type SlotWhereInput = {
  AND?: InputMaybe<Array<SlotWhereInput>>
  Bookings?: InputMaybe<BookingListRelationFilter>
  Garage?: InputMaybe<GarageRelationFilter>
  NOT?: InputMaybe<Array<SlotWhereInput>>
  OR?: InputMaybe<Array<SlotWhereInput>>
  createdAt?: InputMaybe<DateTimeFilter>
  displayName?: InputMaybe<StringFilter>
  garageId?: InputMaybe<IntFilter>
  height?: InputMaybe<IntFilter>
  id?: InputMaybe<IntFilter>
  length?: InputMaybe<IntFilter>
  pricePerHour?: InputMaybe<FloatFilter>
  type?: InputMaybe<EnumSlotTypeFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
  width?: InputMaybe<IntFilter>
}

export type SlotWhereUniqueInput = {
  id: Scalars['Float']['input']
}

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc',
}

export type StringFilter = {
  contains?: InputMaybe<Scalars['String']['input']>
  endsWith?: InputMaybe<Scalars['String']['input']>
  equals?: InputMaybe<Scalars['String']['input']>
  gt?: InputMaybe<Scalars['String']['input']>
  gte?: InputMaybe<Scalars['String']['input']>
  in?: InputMaybe<Array<Scalars['String']['input']>>
  lt?: InputMaybe<Scalars['String']['input']>
  lte?: InputMaybe<Scalars['String']['input']>
  mode?: InputMaybe<QueryMode>
  not?: InputMaybe<Scalars['String']['input']>
  notIn?: InputMaybe<Array<Scalars['String']['input']>>
  startsWith?: InputMaybe<Scalars['String']['input']>
}

export type StringListFilter = {
  equals?: InputMaybe<Array<Scalars['String']['input']>>
  has?: InputMaybe<Scalars['String']['input']>
  hasEvery?: InputMaybe<Array<Scalars['String']['input']>>
  hasSome?: InputMaybe<Array<Scalars['String']['input']>>
  isEmpty?: InputMaybe<Scalars['Boolean']['input']>
}

export type UpdateAddressInput = {
  address?: InputMaybe<Scalars['String']['input']>
  garageId?: InputMaybe<Scalars['Float']['input']>
  id: Scalars['Float']['input']
  lat?: InputMaybe<Scalars['Float']['input']>
  lng?: InputMaybe<Scalars['Float']['input']>
}

export type UpdateAdminInput = {
  uid: Scalars['String']['input']
}

export type UpdateBookingInput = {
  customerId?: InputMaybe<Scalars['String']['input']>
  endTime?: InputMaybe<Scalars['DateTime']['input']>
  garageId?: InputMaybe<Scalars['Float']['input']>
  id: Scalars['Float']['input']
  phoneNumber?: InputMaybe<Scalars['String']['input']>
  pricePerHour?: InputMaybe<Scalars['Float']['input']>
  startTime?: InputMaybe<Scalars['DateTime']['input']>
  totalPrice?: InputMaybe<Scalars['Float']['input']>
  type?: InputMaybe<SlotType>
  valetAssignment?: InputMaybe<CreateValetAssignmentInputWithoutBookingId>
  vehicleNumber?: InputMaybe<Scalars['String']['input']>
}

export type UpdateBookingTimelineInput = {
  bookingId?: InputMaybe<Scalars['Float']['input']>
  id: Scalars['Float']['input']
  status?: InputMaybe<BookingStatus>
}

export type UpdateCompanyInput = {
  description?: InputMaybe<Scalars['String']['input']>
  displayName?: InputMaybe<Scalars['String']['input']>
  id: Scalars['Float']['input']
  managerId?: InputMaybe<Scalars['String']['input']>
  managerName?: InputMaybe<Scalars['String']['input']>
}

export type UpdateCustomerInput = {
  displayName?: InputMaybe<Scalars['String']['input']>
  uid: Scalars['String']['input']
}

export type UpdateGarageInput = {
  Address?: InputMaybe<CreateAddressInputWithoutGarageId>
  Slots?: InputMaybe<Array<CreateSlotInputWithoutGarageId>>
  description?: InputMaybe<Scalars['String']['input']>
  displayName?: InputMaybe<Scalars['String']['input']>
  id: Scalars['Float']['input']
  images?: InputMaybe<Array<Scalars['String']['input']>>
}

export type UpdateManagerInput = {
  displayName?: InputMaybe<Scalars['String']['input']>
  uid: Scalars['String']['input']
}

export type UpdateReviewInput = {
  comment?: InputMaybe<Scalars['String']['input']>
  customerId?: InputMaybe<Scalars['String']['input']>
  garageId?: InputMaybe<Scalars['Float']['input']>
  id: Scalars['Float']['input']
  rating?: InputMaybe<Scalars['Float']['input']>
}

export type UpdateSlotInput = {
  displayName?: InputMaybe<Scalars['String']['input']>
  garageId?: InputMaybe<Scalars['Float']['input']>
  height?: InputMaybe<Scalars['Float']['input']>
  id: Scalars['Float']['input']
  length?: InputMaybe<Scalars['Float']['input']>
  pricePerHour?: InputMaybe<Scalars['Float']['input']>
  type?: InputMaybe<SlotType>
  width?: InputMaybe<Scalars['Float']['input']>
}

export type UpdateUserInput = {
  uid: Scalars['String']['input']
}

export type UpdateValetAssignmentInput = {
  bookingId: Scalars['Float']['input']
  pickupLat?: InputMaybe<Scalars['Float']['input']>
  pickupLng?: InputMaybe<Scalars['Float']['input']>
  pickupValetId?: InputMaybe<Scalars['String']['input']>
  returnLat?: InputMaybe<Scalars['Float']['input']>
  returnLng?: InputMaybe<Scalars['Float']['input']>
  returnValetId?: InputMaybe<Scalars['String']['input']>
}

export type UpdateValetInput = {
  companyId?: InputMaybe<Scalars['Float']['input']>
  displayName?: InputMaybe<Scalars['String']['input']>
  image?: InputMaybe<Scalars['String']['input']>
  licenceID?: InputMaybe<Scalars['String']['input']>
  uid: Scalars['String']['input']
}

export type UpdateVerificationInput = {
  garageId: Scalars['Float']['input']
  verified?: InputMaybe<Scalars['Boolean']['input']>
}

export type User = {
  __typename?: 'User'
  admin?: Maybe<Admin>
  createdAt: Scalars['DateTime']['output']
  customer?: Maybe<Customer>
  image?: Maybe<Scalars['String']['output']>
  manager?: Maybe<Manager>
  name?: Maybe<Scalars['String']['output']>
  uid: Scalars['String']['output']
  updatedAt: Scalars['DateTime']['output']
  valet?: Maybe<Valet>
}

export type UserOrderByWithRelationInput = {
  Customer?: InputMaybe<CustomerOrderByWithRelationInput>
  Manager?: InputMaybe<ManagerOrderByWithRelationInput>
  Valet?: InputMaybe<ValetOrderByWithRelationInput>
  createdAt?: InputMaybe<SortOrder>
  name?: InputMaybe<SortOrder>
  uid?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
}

export type UserRelationFilter = {
  is?: InputMaybe<UserWhereInput>
  isNot?: InputMaybe<UserWhereInput>
}

export enum UserScalarFieldEnum {
  CreatedAt = 'createdAt',
  Image = 'image',
  Name = 'name',
  Uid = 'uid',
  UpdatedAt = 'updatedAt',
}

export type UserWhereInput = {
  AND?: InputMaybe<Array<UserWhereInput>>
  Customer?: InputMaybe<CustomerRelationFilter>
  Manager?: InputMaybe<ManagerRelationFilter>
  NOT?: InputMaybe<Array<UserWhereInput>>
  OR?: InputMaybe<Array<UserWhereInput>>
  Valet?: InputMaybe<ValetRelationFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  name?: InputMaybe<StringFilter>
  uid?: InputMaybe<StringFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
}

export type UserWhereUniqueInput = {
  uid: Scalars['String']['input']
}

export type Valet = {
  __typename?: 'Valet'
  companyId?: Maybe<Scalars['Float']['output']>
  createdAt: Scalars['DateTime']['output']
  displayName: Scalars['String']['output']
  image?: Maybe<Scalars['String']['output']>
  licenceID: Scalars['String']['output']
  uid: Scalars['String']['output']
  updatedAt: Scalars['DateTime']['output']
}

export type ValetAssignment = {
  __typename?: 'ValetAssignment'
  bookingId: Scalars['Float']['output']
  createdAt: Scalars['DateTime']['output']
  pickupLat: Scalars['Float']['output']
  pickupLng: Scalars['Float']['output']
  pickupValet?: Maybe<Valet>
  pickupValetId?: Maybe<Scalars['String']['output']>
  returnLat?: Maybe<Scalars['Float']['output']>
  returnLng?: Maybe<Scalars['Float']['output']>
  returnValet?: Maybe<Valet>
  returnValetId?: Maybe<Scalars['String']['output']>
  updatedAt: Scalars['DateTime']['output']
}

export type ValetAssignmentListRelationFilter = {
  every?: InputMaybe<ValetAssignmentWhereInput>
  none?: InputMaybe<ValetAssignmentWhereInput>
  some?: InputMaybe<ValetAssignmentWhereInput>
}

export type ValetAssignmentOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>
}

export type ValetAssignmentOrderByWithRelationInput = {
  Booking?: InputMaybe<BookingOrderByWithRelationInput>
  PickupValet?: InputMaybe<ValetOrderByWithRelationInput>
  ReturnValet?: InputMaybe<ValetOrderByWithRelationInput>
  bookingId?: InputMaybe<SortOrder>
  createdAt?: InputMaybe<SortOrder>
  pickupLat?: InputMaybe<SortOrder>
  pickupLng?: InputMaybe<SortOrder>
  pickupValetId?: InputMaybe<SortOrder>
  returnLat?: InputMaybe<SortOrder>
  returnLng?: InputMaybe<SortOrder>
  returnValetId?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
}

export type ValetAssignmentRelationFilter = {
  is?: InputMaybe<ValetAssignmentWhereInput>
  isNot?: InputMaybe<ValetAssignmentWhereInput>
}

export enum ValetAssignmentScalarFieldEnum {
  BookingId = 'bookingId',
  CreatedAt = 'createdAt',
  PickupLat = 'pickupLat',
  PickupLng = 'pickupLng',
  PickupValetId = 'pickupValetId',
  ReturnLat = 'returnLat',
  ReturnLng = 'returnLng',
  ReturnValetId = 'returnValetId',
  UpdatedAt = 'updatedAt',
}

export type ValetAssignmentWhereInput = {
  AND?: InputMaybe<Array<ValetAssignmentWhereInput>>
  Booking?: InputMaybe<BookingRelationFilter>
  NOT?: InputMaybe<Array<ValetAssignmentWhereInput>>
  OR?: InputMaybe<Array<ValetAssignmentWhereInput>>
  PickupValet?: InputMaybe<ValetRelationFilter>
  ReturnValet?: InputMaybe<ValetRelationFilter>
  bookingId?: InputMaybe<IntFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  pickupLat?: InputMaybe<FloatFilter>
  pickupLng?: InputMaybe<FloatFilter>
  pickupValetId?: InputMaybe<StringFilter>
  returnLat?: InputMaybe<FloatFilter>
  returnLng?: InputMaybe<FloatFilter>
  returnValetId?: InputMaybe<StringFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
}

export type ValetAssignmentWhereUniqueInput = {
  bookingId: Scalars['Float']['input']
}

export type ValetListRelationFilter = {
  every?: InputMaybe<ValetWhereInput>
  none?: InputMaybe<ValetWhereInput>
  some?: InputMaybe<ValetWhereInput>
}

export type ValetOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>
}

export type ValetOrderByWithRelationInput = {
  BookingTimeline?: InputMaybe<BookingTimelineOrderByRelationAggregateInput>
  Company?: InputMaybe<CompanyOrderByWithRelationInput>
  PickupAssignments?: InputMaybe<ValetAssignmentOrderByRelationAggregateInput>
  ReturnAssignments?: InputMaybe<ValetAssignmentOrderByRelationAggregateInput>
  User?: InputMaybe<UserOrderByWithRelationInput>
  companyId?: InputMaybe<SortOrder>
  createdAt?: InputMaybe<SortOrder>
  displayName?: InputMaybe<SortOrder>
  image?: InputMaybe<SortOrder>
  licenceID?: InputMaybe<SortOrder>
  uid?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
}

export type ValetRelationFilter = {
  is?: InputMaybe<ValetWhereInput>
  isNot?: InputMaybe<ValetWhereInput>
}

export enum ValetScalarFieldEnum {
  CompanyId = 'companyId',
  CreatedAt = 'createdAt',
  DisplayName = 'displayName',
  Image = 'image',
  LicenceId = 'licenceID',
  Uid = 'uid',
  UpdatedAt = 'updatedAt',
}

export type ValetWhereInput = {
  AND?: InputMaybe<Array<ValetWhereInput>>
  BookingTimeline?: InputMaybe<BookingTimelineListRelationFilter>
  Company?: InputMaybe<CompanyRelationFilter>
  NOT?: InputMaybe<Array<ValetWhereInput>>
  OR?: InputMaybe<Array<ValetWhereInput>>
  PickupAssignments?: InputMaybe<ValetAssignmentListRelationFilter>
  ReturnAssignments?: InputMaybe<ValetAssignmentListRelationFilter>
  User?: InputMaybe<UserRelationFilter>
  companyId?: InputMaybe<IntFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  displayName?: InputMaybe<StringFilter>
  image?: InputMaybe<StringFilter>
  licenceID?: InputMaybe<StringFilter>
  uid?: InputMaybe<StringFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
}

export type ValetWhereUniqueInput = {
  uid: Scalars['String']['input']
}

export type Verification = {
  __typename?: 'Verification'
  adminId: Scalars['String']['output']
  createdAt: Scalars['DateTime']['output']
  garageId: Scalars['Float']['output']
  updatedAt: Scalars['DateTime']['output']
  verified: Scalars['Boolean']['output']
}

export type VerificationListRelationFilter = {
  every?: InputMaybe<VerificationWhereInput>
  none?: InputMaybe<VerificationWhereInput>
  some?: InputMaybe<VerificationWhereInput>
}

export type VerificationOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>
}

export type VerificationOrderByWithRelationInput = {
  Admin?: InputMaybe<AdminOrderByWithRelationInput>
  Garage?: InputMaybe<GarageOrderByWithRelationInput>
  adminId?: InputMaybe<SortOrder>
  createdAt?: InputMaybe<SortOrder>
  garageId?: InputMaybe<SortOrder>
  updatedAt?: InputMaybe<SortOrder>
  verified?: InputMaybe<SortOrder>
}

export type VerificationRelationFilter = {
  is?: InputMaybe<VerificationWhereInput>
  isNot?: InputMaybe<VerificationWhereInput>
}

export enum VerificationScalarFieldEnum {
  AdminId = 'adminId',
  CreatedAt = 'createdAt',
  GarageId = 'garageId',
  UpdatedAt = 'updatedAt',
  Verified = 'verified',
}

export type VerificationWhereInput = {
  AND?: InputMaybe<Array<VerificationWhereInput>>
  Admin?: InputMaybe<AdminRelationFilter>
  Garage?: InputMaybe<GarageRelationFilter>
  NOT?: InputMaybe<Array<VerificationWhereInput>>
  OR?: InputMaybe<Array<VerificationWhereInput>>
  adminId?: InputMaybe<StringFilter>
  createdAt?: InputMaybe<DateTimeFilter>
  garageId?: InputMaybe<IntFilter>
  updatedAt?: InputMaybe<DateTimeFilter>
  verified?: InputMaybe<BoolFilter>
}

export type VerificationWhereUniqueInput = {
  garageId: Scalars['Float']['input']
}

export type RegisterWithCredentialsMutationVariables = Exact<{
  registerWithCredentialsInput: RegisterWithCredentialsInput
}>

export type RegisterWithCredentialsMutation = {
  __typename?: 'Mutation'
  registerWithCredentials: {
    __typename?: 'User'
    updatedAt: any
    uid: string
    name?: string | null
    image?: string | null
    createdAt: any
  }
}

export type CompaniesQueryVariables = Exact<{
  distinct?: InputMaybe<Array<CompanyScalarFieldEnum> | CompanyScalarFieldEnum>
  orderBy?: InputMaybe<
    Array<CompanyOrderByWithRelationInput> | CompanyOrderByWithRelationInput
  >
  where?: InputMaybe<CompanyWhereInput>
  cursor?: InputMaybe<CompanyWhereUniqueInput>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
}>

export type CompaniesQuery = {
  __typename?: 'Query'
  companies: Array<{
    __typename?: 'Company'
    createdAt: any
    description?: string | null
    displayName?: string | null
    id: number
    updatedAt: any
    garages: Array<{ __typename?: 'Garage'; id: number }>
    managers: Array<{ __typename?: 'Manager'; uid: string }>
  }>
}

export type LoginMutationVariables = Exact<{
  loginInput: LoginInput
}>

export type LoginMutation = {
  __typename?: 'Mutation'
  login: {
    __typename?: 'LoginOutput'
    token: string
    user: {
      __typename?: 'User'
      uid: string
      name?: string | null
      image?: string | null
    }
  }
}

export type GetAuthProviderQueryVariables = Exact<{
  uid: Scalars['String']['input']
}>

export type GetAuthProviderQuery = {
  __typename?: 'Query'
  getAuthProvider?: {
    __typename?: 'AuthProvider'
    uid: string
    type: AuthProviderType
  } | null
}

export type RegisterWithProviderMutationVariables = Exact<{
  registerWithProviderInput: RegisterWithProviderInput
}>

export type RegisterWithProviderMutation = {
  __typename?: 'Mutation'
  registerWithProvider: { __typename?: 'User'; uid: string }
}

export type SearchGaragesQueryVariables = Exact<{
  dateFilter: DateFilterInput
  locationFilter: LocationFilterInput
  slotsFilter?: InputMaybe<SlotWhereInput>
  garageFilter?: InputMaybe<GarageFilter>
}>

export type SearchGaragesQuery = {
  __typename?: 'Query'
  searchGarages: Array<{
    __typename?: 'Garage'
    id: number
    images: Array<string>
    displayName?: string | null
    address?: {
      __typename?: 'Address'
      lat: number
      lng: number
      address: string
    } | null
    availableSlots: Array<{
      __typename?: 'MinimalSlotGroupBy'
      type: SlotType
      pricePerHour: number
      count: number
    }>
    verification?: { __typename?: 'Verification'; verified: boolean } | null
  }>
}

export type MyCompanyQueryVariables = Exact<{ [key: string]: never }>

export type MyCompanyQuery = {
  __typename?: 'Query'
  myCompany: {
    __typename?: 'Company'
    id: number
    createdAt: any
    displayName?: string | null
    garages: Array<{
      __typename?: 'Garage'
      displayName?: string | null
      id: number
      description?: string | null
      address?: {
        __typename?: 'Address'
        id: number
        address: string
        lat: number
        lng: number
      } | null
    }>
  }
}

export type CreateCompanyMutationVariables = Exact<{
  createCompanyInput: CreateCompanyInput
}>

export type CreateCompanyMutation = {
  __typename?: 'Mutation'
  createCompany: { __typename?: 'Company'; id: number }
}

export type GaragesQueryVariables = Exact<{
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  cursor?: InputMaybe<GarageWhereUniqueInput>
  orderBy?: InputMaybe<
    Array<GarageOrderByWithRelationInput> | GarageOrderByWithRelationInput
  >
  where?: InputMaybe<GarageWhereInput>
}>

export type GaragesQuery = {
  __typename?: 'Query'
  garages: Array<{
    __typename?: 'Garage'
    id: number
    displayName?: string | null
    description?: string | null
    images: Array<string>
    verification?: { __typename?: 'Verification'; verified: boolean } | null
    address?: {
      __typename?: 'Address'
      id: number
      lat: number
      lng: number
      address: string
    } | null
    slotCounts: Array<{
      __typename?: 'SlotTypeCount'
      type: SlotType
      count?: number | null
    }>
  }>
  garagesCount: { __typename?: 'AggregateCountOutput'; count: number }
}

export type CreateGarageMutationVariables = Exact<{
  createGarageInput: CreateGarageInput
}>

export type CreateGarageMutation = {
  __typename?: 'Mutation'
  createGarage: { __typename?: 'Garage'; id: number }
}

export type CreateManySlotsMutationVariables = Exact<{
  createSlotInput: CreateSlotInput
  count: Scalars['Float']['input']
}>

export type CreateManySlotsMutation = {
  __typename?: 'Mutation'
  createManySlots: { __typename?: 'ReturnCount'; count: number }
}

export type ValetFieldsFragment = {
  __typename?: 'Valet'
  image?: string | null
  uid: string
  displayName: string
}

export type BookingFieldsFragment = {
  __typename?: 'Booking'
  id: number
  pricePerHour?: number | null
  endTime: any
  startTime: any
  vehicleNumber: string
  passcode?: string | null
  status: BookingStatus
  bookingTimeline: Array<{
    __typename?: 'BookingTimeline'
    status: BookingStatus
    timestamp: any
  }>
  valetAssignment?: {
    __typename?: 'ValetAssignment'
    pickupValet?: {
      __typename?: 'Valet'
      image?: string | null
      uid: string
      displayName: string
    } | null
    returnValet?: {
      __typename?: 'Valet'
      image?: string | null
      uid: string
      displayName: string
    } | null
  } | null
  slot: {
    __typename?: 'Slot'
    displayName?: string | null
    garage: {
      __typename?: 'Garage'
      images: Array<string>
      address?: {
        __typename?: 'Address'
        address: string
        lat: number
        lng: number
      } | null
    }
  }
}

export type BookingsForCustomerQueryVariables = Exact<{
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  cursor?: InputMaybe<BookingWhereUniqueInput>
  orderBy?: InputMaybe<
    Array<BookingOrderByWithRelationInput> | BookingOrderByWithRelationInput
  >
  where?: InputMaybe<BookingWhereInput>
  distinct?: InputMaybe<Array<BookingScalarFieldEnum> | BookingScalarFieldEnum>
}>

export type BookingsForCustomerQuery = {
  __typename?: 'Query'
  bookingsForCustomer: Array<{
    __typename?: 'Booking'
    id: number
    pricePerHour?: number | null
    endTime: any
    startTime: any
    vehicleNumber: string
    passcode?: string | null
    status: BookingStatus
    bookingTimeline: Array<{
      __typename?: 'BookingTimeline'
      status: BookingStatus
      timestamp: any
    }>
    valetAssignment?: {
      __typename?: 'ValetAssignment'
      pickupValet?: {
        __typename?: 'Valet'
        image?: string | null
        uid: string
        displayName: string
      } | null
      returnValet?: {
        __typename?: 'Valet'
        image?: string | null
        uid: string
        displayName: string
      } | null
    } | null
    slot: {
      __typename?: 'Slot'
      displayName?: string | null
      garage: {
        __typename?: 'Garage'
        images: Array<string>
        address?: {
          __typename?: 'Address'
          address: string
          lat: number
          lng: number
        } | null
      }
    }
  }>
  bookingsCount: { __typename?: 'AggregateCountOutput'; count: number }
}

export type BookingsForGarageQueryVariables = Exact<{
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  cursor?: InputMaybe<BookingWhereUniqueInput>
  orderBy?: InputMaybe<
    Array<BookingOrderByWithRelationInput> | BookingOrderByWithRelationInput
  >
  where?: InputMaybe<BookingWhereInput>
  distinct?: InputMaybe<Array<BookingScalarFieldEnum> | BookingScalarFieldEnum>
}>

export type BookingsForGarageQuery = {
  __typename?: 'Query'
  bookingsForGarage: Array<{
    __typename?: 'Booking'
    id: number
    pricePerHour?: number | null
    endTime: any
    startTime: any
    vehicleNumber: string
    passcode?: string | null
    status: BookingStatus
    bookingTimeline: Array<{
      __typename?: 'BookingTimeline'
      status: BookingStatus
      timestamp: any
    }>
    valetAssignment?: {
      __typename?: 'ValetAssignment'
      pickupValet?: {
        __typename?: 'Valet'
        image?: string | null
        uid: string
        displayName: string
      } | null
      returnValet?: {
        __typename?: 'Valet'
        image?: string | null
        uid: string
        displayName: string
      } | null
    } | null
    slot: {
      __typename?: 'Slot'
      displayName?: string | null
      garage: {
        __typename?: 'Garage'
        images: Array<string>
        address?: {
          __typename?: 'Address'
          address: string
          lat: number
          lng: number
        } | null
      }
    }
  }>
  bookingsCount: { __typename?: 'AggregateCountOutput'; count: number }
}

export type CreateBookingTimelineMutationVariables = Exact<{
  createBookingTimelineInput: CreateBookingTimelineInput
}>

export type CreateBookingTimelineMutation = {
  __typename?: 'Mutation'
  createBookingTimeline: {
    __typename?: 'BookingTimeline'
    bookingId: number
    id: number
    managerId?: string | null
    status: BookingStatus
    timestamp: any
  }
}

export type ValetMeQueryVariables = Exact<{ [key: string]: never }>

export type ValetMeQuery = {
  __typename?: 'Query'
  valetMe?: {
    __typename?: 'Valet'
    uid: string
    companyId?: number | null
  } | null
}

export type AdminMeQueryVariables = Exact<{ [key: string]: never }>

export type AdminMeQuery = {
  __typename?: 'Query'
  adminMe: { __typename?: 'Admin'; uid: string }
}

export type CreateValetMutationVariables = Exact<{
  createValetInput: CreateValetInput
}>

export type CreateValetMutation = {
  __typename?: 'Mutation'
  createValet: { __typename?: 'Valet'; uid: string }
}

export type CompanyValetsQueryVariables = Exact<{
  distinct?: InputMaybe<Array<ValetScalarFieldEnum> | ValetScalarFieldEnum>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  cursor?: InputMaybe<ValetWhereUniqueInput>
  orderBy?: InputMaybe<
    Array<ValetOrderByWithRelationInput> | ValetOrderByWithRelationInput
  >
  where?: InputMaybe<ValetWhereInput>
}>

export type CompanyValetsQuery = {
  __typename?: 'Query'
  companyValetsTotal: number
  companyValets: Array<{
    __typename?: 'Valet'
    displayName: string
    uid: string
    createdAt: any
    updatedAt: any
    companyId?: number | null
    image?: string | null
    licenceID: string
  }>
}

export type ValetPickupsQueryVariables = Exact<{
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
}>

export type ValetPickupsQuery = {
  __typename?: 'Query'
  valetPickupsTotal: number
  valetPickups: Array<{
    __typename?: 'Booking'
    id: number
    vehicleNumber: string
    startTime: any
    endTime: any
    valetAssignment?: {
      __typename?: 'ValetAssignment'
      pickupLat: number
      pickupLng: number
      pickupValetId?: string | null
    } | null
    slot: {
      __typename?: 'Slot'
      garage: {
        __typename?: 'Garage'
        address?: { __typename?: 'Address'; lat: number; lng: number } | null
      }
    }
  }>
}

export type ValetDropsQueryVariables = Exact<{
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
}>

export type ValetDropsQuery = {
  __typename?: 'Query'
  valetDropsTotal: number
  valetDrops: Array<{
    __typename?: 'Booking'
    id: number
    vehicleNumber: string
    startTime: any
    endTime: any
    valetAssignment?: {
      __typename?: 'ValetAssignment'
      returnLat?: number | null
      returnLng?: number | null
      returnValetId?: string | null
    } | null
    slot: {
      __typename?: 'Slot'
      garage: {
        __typename?: 'Garage'
        address?: { __typename?: 'Address'; lat: number; lng: number } | null
      }
    }
  }>
}

export type AssignValetMutationVariables = Exact<{
  bookingId: Scalars['Float']['input']
  status: Scalars['String']['input']
}>

export type AssignValetMutation = {
  __typename?: 'Mutation'
  assignValet: { __typename?: 'Booking'; id: number }
}

export type ValetBookingFieldsFragment = {
  __typename?: 'Booking'
  id: number
  vehicleNumber: string
  passcode?: string | null
  status: BookingStatus
  startTime: any
  endTime: any
  slot: {
    __typename?: 'Slot'
    garage: {
      __typename?: 'Garage'
      address?: { __typename?: 'Address'; lat: number; lng: number } | null
    }
  }
}

export type MyPickupTripsQueryVariables = Exact<{
  distinct?: InputMaybe<Array<BookingScalarFieldEnum> | BookingScalarFieldEnum>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  orderBy?: InputMaybe<
    Array<BookingOrderByWithRelationInput> | BookingOrderByWithRelationInput
  >
  where?: InputMaybe<BookingWhereInput>
}>

export type MyPickupTripsQuery = {
  __typename?: 'Query'
  bookingsForValet: Array<{
    __typename?: 'Booking'
    id: number
    vehicleNumber: string
    passcode?: string | null
    status: BookingStatus
    startTime: any
    endTime: any
    valetAssignment?: {
      __typename?: 'ValetAssignment'
      pickupLat: number
      pickupLng: number
      pickupValetId?: string | null
    } | null
    slot: {
      __typename?: 'Slot'
      garage: {
        __typename?: 'Garage'
        address?: { __typename?: 'Address'; lat: number; lng: number } | null
      }
    }
  }>
  bookingsCount: { __typename?: 'AggregateCountOutput'; count: number }
}

export type MyDropTripsQueryVariables = Exact<{
  distinct?: InputMaybe<Array<BookingScalarFieldEnum> | BookingScalarFieldEnum>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  orderBy?: InputMaybe<
    Array<BookingOrderByWithRelationInput> | BookingOrderByWithRelationInput
  >
  where?: InputMaybe<BookingWhereInput>
}>

export type MyDropTripsQuery = {
  __typename?: 'Query'
  bookingsForValet: Array<{
    __typename?: 'Booking'
    id: number
    vehicleNumber: string
    passcode?: string | null
    status: BookingStatus
    startTime: any
    endTime: any
    valetAssignment?: {
      __typename?: 'ValetAssignment'
      returnLat?: number | null
      returnLng?: number | null
      returnValetId?: string | null
    } | null
    slot: {
      __typename?: 'Slot'
      garage: {
        __typename?: 'Garage'
        address?: { __typename?: 'Address'; lat: number; lng: number } | null
      }
    }
  }>
  bookingsCount: { __typename?: 'AggregateCountOutput'; count: number }
}

export type CreateVerificationMutationVariables = Exact<{
  createVerificationInput: CreateVerificationInput
}>

export type CreateVerificationMutation = {
  __typename?: 'Mutation'
  createVerification: {
    __typename?: 'Verification'
    adminId: string
    createdAt: any
    garageId: number
    updatedAt: any
    verified: boolean
  }
}

export type RemoveVerificationMutationVariables = Exact<{
  where: VerificationWhereUniqueInput
}>

export type RemoveVerificationMutation = {
  __typename?: 'Mutation'
  removeVerification: {
    __typename?: 'Verification'
    adminId: string
    createdAt: any
    garageId: number
    updatedAt: any
    verified: boolean
  }
}

export type AdminsQueryVariables = Exact<{
  distinct?: InputMaybe<Array<AdminScalarFieldEnum> | AdminScalarFieldEnum>
  skip?: InputMaybe<Scalars['Float']['input']>
  take?: InputMaybe<Scalars['Float']['input']>
  cursor?: InputMaybe<AdminWhereUniqueInput>
  orderBy?: InputMaybe<
    Array<AdminOrderByWithRelationInput> | AdminOrderByWithRelationInput
  >
  where?: InputMaybe<AdminWhereInput>
}>

export type AdminsQuery = {
  __typename?: 'Query'
  adminsCount: number
  admins: Array<{
    __typename?: 'Admin'
    uid: string
    updatedAt: any
    createdAt: any
    verificationsCount: number
    user?: { __typename?: 'User'; name?: string | null } | null
  }>
}

export type RemoveAdminMutationVariables = Exact<{
  where: AdminWhereUniqueInput
}>

export type RemoveAdminMutation = {
  __typename?: 'Mutation'
  removeAdmin: {
    __typename?: 'Admin'
    createdAt: any
    updatedAt: any
    uid: string
    user?: { __typename?: 'User'; name?: string | null } | null
  }
}

export type CreateAdminMutationVariables = Exact<{
  createAdminInput: CreateAdminInput
}>

export type CreateAdminMutation = {
  __typename?: 'Mutation'
  createAdmin: {
    __typename?: 'Admin'
    createdAt: any
    uid: string
    updatedAt: any
    user?: { __typename?: 'User'; name?: string | null } | null
  }
}

export const namedOperations = {
  Query: {
    Companies: 'Companies',
    GetAuthProvider: 'GetAuthProvider',
    SearchGarages: 'SearchGarages',
    myCompany: 'myCompany',
    Garages: 'Garages',
    BookingsForCustomer: 'BookingsForCustomer',
    BookingsForGarage: 'BookingsForGarage',
    ValetMe: 'ValetMe',
    AdminMe: 'AdminMe',
    companyValets: 'companyValets',
    valetPickups: 'valetPickups',
    valetDrops: 'valetDrops',
    myPickupTrips: 'myPickupTrips',
    myDropTrips: 'myDropTrips',
    admins: 'admins',
  },
  Mutation: {
    RegisterWithCredentials: 'RegisterWithCredentials',
    Login: 'Login',
    RegisterWithProvider: 'RegisterWithProvider',
    CreateCompany: 'CreateCompany',
    CreateGarage: 'CreateGarage',
    CreateManySlots: 'CreateManySlots',
    createBookingTimeline: 'createBookingTimeline',
    CreateValet: 'CreateValet',
    AssignValet: 'AssignValet',
    CreateVerification: 'CreateVerification',
    RemoveVerification: 'RemoveVerification',
    RemoveAdmin: 'RemoveAdmin',
    CreateAdmin: 'CreateAdmin',
  },
  Fragment: {
    ValetFields: 'ValetFields',
    BookingFields: 'BookingFields',
    ValetBookingFields: 'ValetBookingFields',
  },
}
export const ValetFieldsFragmentDoc = {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'ValetFields' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'Valet' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'image' } },
          { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
          { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
        ],
      },
    },
  ],
} as unknown as DocumentNode<ValetFieldsFragment, unknown>
export const BookingFieldsFragmentDoc = {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'BookingFields' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'Booking' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'pricePerHour' } },
          { kind: 'Field', name: { kind: 'Name', value: 'endTime' } },
          { kind: 'Field', name: { kind: 'Name', value: 'startTime' } },
          { kind: 'Field', name: { kind: 'Name', value: 'vehicleNumber' } },
          { kind: 'Field', name: { kind: 'Name', value: 'passcode' } },
          { kind: 'Field', name: { kind: 'Name', value: 'status' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingTimeline' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'status' } },
                { kind: 'Field', name: { kind: 'Name', value: 'timestamp' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'valetAssignment' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'pickupValet' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'FragmentSpread',
                        name: { kind: 'Name', value: 'ValetFields' },
                      },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'returnValet' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'FragmentSpread',
                        name: { kind: 'Name', value: 'ValetFields' },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'slot' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'garage' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'images' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'address' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'address' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lat' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lng' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'ValetFields' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'Valet' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'image' } },
          { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
          { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
        ],
      },
    },
  ],
} as unknown as DocumentNode<BookingFieldsFragment, unknown>
export const ValetBookingFieldsFragmentDoc = {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'ValetBookingFields' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'Booking' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'vehicleNumber' } },
          { kind: 'Field', name: { kind: 'Name', value: 'passcode' } },
          { kind: 'Field', name: { kind: 'Name', value: 'status' } },
          { kind: 'Field', name: { kind: 'Name', value: 'startTime' } },
          { kind: 'Field', name: { kind: 'Name', value: 'endTime' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'slot' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'garage' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'address' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lat' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lng' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<ValetBookingFieldsFragment, unknown>
export const RegisterWithCredentialsDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'RegisterWithCredentials' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'registerWithCredentialsInput' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'RegisterWithCredentialsInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'registerWithCredentials' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'registerWithCredentialsInput' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'registerWithCredentialsInput' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'updatedAt' } },
                { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
                { kind: 'Field', name: { kind: 'Name', value: 'name' } },
                { kind: 'Field', name: { kind: 'Name', value: 'image' } },
                { kind: 'Field', name: { kind: 'Name', value: 'createdAt' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  RegisterWithCredentialsMutation,
  RegisterWithCredentialsMutationVariables
>
export const CompaniesDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'Companies' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'distinct' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: { kind: 'Name', value: 'CompanyScalarFieldEnum' },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'orderBy' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: {
                  kind: 'Name',
                  value: 'CompanyOrderByWithRelationInput',
                },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'where' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'CompanyWhereInput' },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cursor' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'CompanyWhereUniqueInput' },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skip' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'take' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'companies' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'distinct' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'distinct' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'orderBy' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'orderBy' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'cursor' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'cursor' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'skip' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'skip' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'take' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'take' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'createdAt' } },
                { kind: 'Field', name: { kind: 'Name', value: 'description' } },
                { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'garages' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                    ],
                  },
                },
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'managers' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
                    ],
                  },
                },
                { kind: 'Field', name: { kind: 'Name', value: 'updatedAt' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<CompaniesQuery, CompaniesQueryVariables>
export const LoginDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'Login' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'loginInput' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'LoginInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'login' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'loginInput' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'loginInput' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'token' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'user' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
                      { kind: 'Field', name: { kind: 'Name', value: 'name' } },
                      { kind: 'Field', name: { kind: 'Name', value: 'image' } },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<LoginMutation, LoginMutationVariables>
export const GetAuthProviderDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'GetAuthProvider' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'uid' } },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'String' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'getAuthProvider' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'uid' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'uid' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
                { kind: 'Field', name: { kind: 'Name', value: 'type' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  GetAuthProviderQuery,
  GetAuthProviderQueryVariables
>
export const RegisterWithProviderDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'RegisterWithProvider' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'registerWithProviderInput' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'RegisterWithProviderInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'registerWithProvider' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'registerWithProviderInput' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'registerWithProviderInput' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  RegisterWithProviderMutation,
  RegisterWithProviderMutationVariables
>
export const SearchGaragesDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'SearchGarages' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'dateFilter' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'DateFilterInput' },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'locationFilter' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'LocationFilterInput' },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'slotsFilter' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'SlotWhereInput' },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'garageFilter' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'GarageFilter' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'searchGarages' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'dateFilter' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'dateFilter' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'locationFilter' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'locationFilter' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'slotsFilter' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'slotsFilter' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'garageFilter' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'garageFilter' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'address' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'lat' } },
                      { kind: 'Field', name: { kind: 'Name', value: 'lng' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'address' },
                      },
                    ],
                  },
                },
                { kind: 'Field', name: { kind: 'Name', value: 'images' } },
                { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'availableSlots' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'dateFilter' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'dateFilter' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'slotsFilter' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'slotsFilter' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'type' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'pricePerHour' },
                      },
                      { kind: 'Field', name: { kind: 'Name', value: 'count' } },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'verification' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'verified' },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<SearchGaragesQuery, SearchGaragesQueryVariables>
export const MyCompanyDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'myCompany' },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'myCompany' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'garages' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'displayName' },
                      },
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'description' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'address' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'address' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lat' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lng' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
                { kind: 'Field', name: { kind: 'Name', value: 'createdAt' } },
                { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<MyCompanyQuery, MyCompanyQueryVariables>
export const CreateCompanyDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'CreateCompany' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'createCompanyInput' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateCompanyInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'createCompany' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'createCompanyInput' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'createCompanyInput' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  CreateCompanyMutation,
  CreateCompanyMutationVariables
>
export const GaragesDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'Garages' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skip' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'take' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cursor' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'GarageWhereUniqueInput' },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'orderBy' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: { kind: 'Name', value: 'GarageOrderByWithRelationInput' },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'where' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'GarageWhereInput' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'garages' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'skip' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'skip' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'take' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'take' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'cursor' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'cursor' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'orderBy' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'orderBy' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
                { kind: 'Field', name: { kind: 'Name', value: 'description' } },
                { kind: 'Field', name: { kind: 'Name', value: 'images' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'verification' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'verified' },
                      },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'address' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                      { kind: 'Field', name: { kind: 'Name', value: 'lat' } },
                      { kind: 'Field', name: { kind: 'Name', value: 'lng' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'address' },
                      },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'slotCounts' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'type' } },
                      { kind: 'Field', name: { kind: 'Name', value: 'count' } },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'garagesCount' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'count' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<GaragesQuery, GaragesQueryVariables>
export const CreateGarageDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'CreateGarage' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'createGarageInput' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateGarageInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'createGarage' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'createGarageInput' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'createGarageInput' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  CreateGarageMutation,
  CreateGarageMutationVariables
>
export const CreateManySlotsDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'CreateManySlots' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'createSlotInput' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateSlotInput' },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'count' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'createManySlots' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'createSlotInput' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'createSlotInput' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'count' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'count' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'count' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  CreateManySlotsMutation,
  CreateManySlotsMutationVariables
>
export const BookingsForCustomerDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'BookingsForCustomer' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skip' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'take' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cursor' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'BookingWhereUniqueInput' },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'orderBy' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: {
                  kind: 'Name',
                  value: 'BookingOrderByWithRelationInput',
                },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'where' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'BookingWhereInput' },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'distinct' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: { kind: 'Name', value: 'BookingScalarFieldEnum' },
              },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingsForCustomer' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'skip' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'skip' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'take' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'take' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'cursor' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'cursor' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'orderBy' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'orderBy' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'distinct' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'distinct' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'BookingFields' },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingsCount' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'count' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'ValetFields' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'Valet' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'image' } },
          { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
          { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'BookingFields' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'Booking' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'pricePerHour' } },
          { kind: 'Field', name: { kind: 'Name', value: 'endTime' } },
          { kind: 'Field', name: { kind: 'Name', value: 'startTime' } },
          { kind: 'Field', name: { kind: 'Name', value: 'vehicleNumber' } },
          { kind: 'Field', name: { kind: 'Name', value: 'passcode' } },
          { kind: 'Field', name: { kind: 'Name', value: 'status' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingTimeline' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'status' } },
                { kind: 'Field', name: { kind: 'Name', value: 'timestamp' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'valetAssignment' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'pickupValet' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'FragmentSpread',
                        name: { kind: 'Name', value: 'ValetFields' },
                      },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'returnValet' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'FragmentSpread',
                        name: { kind: 'Name', value: 'ValetFields' },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'slot' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'garage' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'images' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'address' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'address' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lat' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lng' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  BookingsForCustomerQuery,
  BookingsForCustomerQueryVariables
>
export const BookingsForGarageDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'BookingsForGarage' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skip' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'take' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cursor' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'BookingWhereUniqueInput' },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'orderBy' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: {
                  kind: 'Name',
                  value: 'BookingOrderByWithRelationInput',
                },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'where' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'BookingWhereInput' },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'distinct' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: { kind: 'Name', value: 'BookingScalarFieldEnum' },
              },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingsForGarage' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'skip' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'skip' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'take' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'take' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'cursor' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'cursor' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'orderBy' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'orderBy' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'distinct' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'distinct' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'BookingFields' },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingsCount' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'count' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'ValetFields' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'Valet' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'image' } },
          { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
          { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'BookingFields' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'Booking' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'pricePerHour' } },
          { kind: 'Field', name: { kind: 'Name', value: 'endTime' } },
          { kind: 'Field', name: { kind: 'Name', value: 'startTime' } },
          { kind: 'Field', name: { kind: 'Name', value: 'vehicleNumber' } },
          { kind: 'Field', name: { kind: 'Name', value: 'passcode' } },
          { kind: 'Field', name: { kind: 'Name', value: 'status' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingTimeline' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'status' } },
                { kind: 'Field', name: { kind: 'Name', value: 'timestamp' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'valetAssignment' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'pickupValet' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'FragmentSpread',
                        name: { kind: 'Name', value: 'ValetFields' },
                      },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'returnValet' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'FragmentSpread',
                        name: { kind: 'Name', value: 'ValetFields' },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'slot' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'garage' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'images' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'address' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'address' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lat' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lng' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  BookingsForGarageQuery,
  BookingsForGarageQueryVariables
>
export const CreateBookingTimelineDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'createBookingTimeline' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'createBookingTimelineInput' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateBookingTimelineInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'createBookingTimeline' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'createBookingTimelineInput' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'createBookingTimelineInput' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'bookingId' } },
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                { kind: 'Field', name: { kind: 'Name', value: 'managerId' } },
                { kind: 'Field', name: { kind: 'Name', value: 'status' } },
                { kind: 'Field', name: { kind: 'Name', value: 'timestamp' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  CreateBookingTimelineMutation,
  CreateBookingTimelineMutationVariables
>
export const ValetMeDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'ValetMe' },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'valetMe' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
                { kind: 'Field', name: { kind: 'Name', value: 'companyId' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<ValetMeQuery, ValetMeQueryVariables>
export const AdminMeDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'AdminMe' },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'adminMe' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<AdminMeQuery, AdminMeQueryVariables>
export const CreateValetDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'CreateValet' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'createValetInput' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateValetInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'createValet' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'createValetInput' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'createValetInput' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<CreateValetMutation, CreateValetMutationVariables>
export const CompanyValetsDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'companyValets' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'distinct' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: { kind: 'Name', value: 'ValetScalarFieldEnum' },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skip' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'take' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cursor' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'ValetWhereUniqueInput' },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'orderBy' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: { kind: 'Name', value: 'ValetOrderByWithRelationInput' },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'where' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'ValetWhereInput' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'companyValets' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'distinct' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'distinct' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'skip' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'skip' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'take' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'take' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'cursor' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'cursor' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'orderBy' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'orderBy' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'displayName' } },
                { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
                { kind: 'Field', name: { kind: 'Name', value: 'createdAt' } },
                { kind: 'Field', name: { kind: 'Name', value: 'updatedAt' } },
                { kind: 'Field', name: { kind: 'Name', value: 'companyId' } },
                { kind: 'Field', name: { kind: 'Name', value: 'image' } },
                { kind: 'Field', name: { kind: 'Name', value: 'licenceID' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'companyValetsTotal' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<CompanyValetsQuery, CompanyValetsQueryVariables>
export const ValetPickupsDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'valetPickups' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skip' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'take' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'valetPickups' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'skip' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'skip' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'take' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'take' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'vehicleNumber' },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'valetAssignment' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'pickupLat' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'pickupLng' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'pickupValetId' },
                      },
                    ],
                  },
                },
                { kind: 'Field', name: { kind: 'Name', value: 'startTime' } },
                { kind: 'Field', name: { kind: 'Name', value: 'endTime' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'slot' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'garage' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'address' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'lat' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'lng' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'valetPickupsTotal' } },
        ],
      },
    },
  ],
} as unknown as DocumentNode<ValetPickupsQuery, ValetPickupsQueryVariables>
export const ValetDropsDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'valetDrops' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skip' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'take' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'valetDrops' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'skip' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'skip' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'take' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'take' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'vehicleNumber' },
                },
                { kind: 'Field', name: { kind: 'Name', value: 'startTime' } },
                { kind: 'Field', name: { kind: 'Name', value: 'endTime' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'valetAssignment' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'returnLat' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'returnLng' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'returnValetId' },
                      },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'slot' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'garage' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'address' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'lat' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'lng' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'valetDropsTotal' } },
        ],
      },
    },
  ],
} as unknown as DocumentNode<ValetDropsQuery, ValetDropsQueryVariables>
export const AssignValetDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'AssignValet' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'bookingId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'status' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'String' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'assignValet' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'bookingId' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'bookingId' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'status' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'status' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<AssignValetMutation, AssignValetMutationVariables>
export const MyPickupTripsDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'myPickupTrips' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'distinct' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: { kind: 'Name', value: 'BookingScalarFieldEnum' },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skip' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'take' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'orderBy' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: {
                  kind: 'Name',
                  value: 'BookingOrderByWithRelationInput',
                },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'where' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'BookingWhereInput' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingsForValet' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'distinct' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'distinct' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'skip' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'skip' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'take' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'take' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'orderBy' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'orderBy' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'ValetBookingFields' },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'valetAssignment' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'pickupLat' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'pickupLng' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'pickupValetId' },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingsCount' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'count' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'ValetBookingFields' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'Booking' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'vehicleNumber' } },
          { kind: 'Field', name: { kind: 'Name', value: 'passcode' } },
          { kind: 'Field', name: { kind: 'Name', value: 'status' } },
          { kind: 'Field', name: { kind: 'Name', value: 'startTime' } },
          { kind: 'Field', name: { kind: 'Name', value: 'endTime' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'slot' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'garage' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'address' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lat' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lng' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<MyPickupTripsQuery, MyPickupTripsQueryVariables>
export const MyDropTripsDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'myDropTrips' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'distinct' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: { kind: 'Name', value: 'BookingScalarFieldEnum' },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skip' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'take' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'orderBy' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: {
                  kind: 'Name',
                  value: 'BookingOrderByWithRelationInput',
                },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'where' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'BookingWhereInput' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingsForValet' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'distinct' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'distinct' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'skip' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'skip' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'take' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'take' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'orderBy' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'orderBy' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'ValetBookingFields' },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'valetAssignment' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'returnLat' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'returnLng' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'returnValetId' },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'bookingsCount' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'count' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'ValetBookingFields' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'Booking' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'vehicleNumber' } },
          { kind: 'Field', name: { kind: 'Name', value: 'passcode' } },
          { kind: 'Field', name: { kind: 'Name', value: 'status' } },
          { kind: 'Field', name: { kind: 'Name', value: 'startTime' } },
          { kind: 'Field', name: { kind: 'Name', value: 'endTime' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'slot' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'garage' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'address' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lat' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'lng' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<MyDropTripsQuery, MyDropTripsQueryVariables>
export const CreateVerificationDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'CreateVerification' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'createVerificationInput' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateVerificationInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'createVerification' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'createVerificationInput' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'createVerificationInput' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'adminId' } },
                { kind: 'Field', name: { kind: 'Name', value: 'createdAt' } },
                { kind: 'Field', name: { kind: 'Name', value: 'garageId' } },
                { kind: 'Field', name: { kind: 'Name', value: 'updatedAt' } },
                { kind: 'Field', name: { kind: 'Name', value: 'verified' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  CreateVerificationMutation,
  CreateVerificationMutationVariables
>
export const RemoveVerificationDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'RemoveVerification' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'where' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'VerificationWhereUniqueInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'removeVerification' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'adminId' } },
                { kind: 'Field', name: { kind: 'Name', value: 'createdAt' } },
                { kind: 'Field', name: { kind: 'Name', value: 'garageId' } },
                { kind: 'Field', name: { kind: 'Name', value: 'updatedAt' } },
                { kind: 'Field', name: { kind: 'Name', value: 'verified' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<
  RemoveVerificationMutation,
  RemoveVerificationMutationVariables
>
export const AdminsDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'admins' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'distinct' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: { kind: 'Name', value: 'AdminScalarFieldEnum' },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'skip' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'take' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Float' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cursor' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'AdminWhereUniqueInput' },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'orderBy' },
          },
          type: {
            kind: 'ListType',
            type: {
              kind: 'NonNullType',
              type: {
                kind: 'NamedType',
                name: { kind: 'Name', value: 'AdminOrderByWithRelationInput' },
              },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'where' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'AdminWhereInput' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'admins' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'distinct' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'distinct' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'skip' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'skip' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'take' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'take' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'cursor' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'cursor' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'orderBy' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'orderBy' },
                },
              },
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
                { kind: 'Field', name: { kind: 'Name', value: 'updatedAt' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'user' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'name' } },
                    ],
                  },
                },
                { kind: 'Field', name: { kind: 'Name', value: 'createdAt' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'verificationsCount' },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'adminsCount' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<AdminsQuery, AdminsQueryVariables>
export const RemoveAdminDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'RemoveAdmin' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'where' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'AdminWhereUniqueInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'removeAdmin' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'where' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'where' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'createdAt' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'user' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'name' } },
                    ],
                  },
                },
                { kind: 'Field', name: { kind: 'Name', value: 'updatedAt' } },
                { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<RemoveAdminMutation, RemoveAdminMutationVariables>
export const CreateAdminDocument = {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'CreateAdmin' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'createAdminInput' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateAdminInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'createAdmin' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'createAdminInput' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'createAdminInput' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'createdAt' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'user' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'name' } },
                    ],
                  },
                },
                { kind: 'Field', name: { kind: 'Name', value: 'uid' } },
                { kind: 'Field', name: { kind: 'Name', value: 'updatedAt' } },
              ],
            },
          },
        ],
      },
    },
  ],
} as unknown as DocumentNode<CreateAdminMutation, CreateAdminMutationVariables>
</file>

<file path="libs/network/src/gql/queries.graphql">
mutation RegisterWithCredentials(
  $registerWithCredentialsInput: RegisterWithCredentialsInput!
) {
  registerWithCredentials(
    registerWithCredentialsInput: $registerWithCredentialsInput
  ) {
    updatedAt
    uid
    name
    image
    createdAt
  }
}

query Companies(
  $distinct: [CompanyScalarFieldEnum!]
  $orderBy: [CompanyOrderByWithRelationInput!]
  $where: CompanyWhereInput
  $cursor: CompanyWhereUniqueInput
  $skip: Float
  $take: Float
) {
  companies(
    distinct: $distinct
    orderBy: $orderBy
    where: $where
    cursor: $cursor
    skip: $skip
    take: $take
  ) {
    createdAt
    description
    displayName
    garages {
      id
    }
    id
    managers {
      uid
    }
    updatedAt
  }
}

mutation Login($loginInput: LoginInput!) {
  login(loginInput: $loginInput) {
    token
    user {
      uid
      name
      image
    }
  }
}

query GetAuthProvider($uid: String!) {
  getAuthProvider(uid: $uid) {
    uid
    type
  }
}

mutation RegisterWithProvider(
  $registerWithProviderInput: RegisterWithProviderInput!
) {
  registerWithProvider(registerWithProviderInput: $registerWithProviderInput) {
    uid
  }
}
query SearchGarages(
  $dateFilter: DateFilterInput!
  $locationFilter: LocationFilterInput!
  $slotsFilter: SlotWhereInput
  $garageFilter: GarageFilter
) {
  searchGarages(
    dateFilter: $dateFilter
    locationFilter: $locationFilter
    slotsFilter: $slotsFilter
    garageFilter: $garageFilter
  ) {
    id
    address {
      lat
      lng
      address
    }
    images
    displayName
    availableSlots(dateFilter: $dateFilter, slotsFilter: $slotsFilter) {
      type
      pricePerHour
      count
    }
    verification {
      verified
    }
  }
}

query myCompany {
  myCompany {
    id
    garages {
      displayName
      id
      description
      address {
        id
        address
        lat
        lng
      }
    }
    createdAt
    displayName
  }
}

mutation CreateCompany($createCompanyInput: CreateCompanyInput!) {
  createCompany(createCompanyInput: $createCompanyInput) {
    id
  }
}

query Garages(
  $skip: Float
  $take: Float
  $cursor: GarageWhereUniqueInput
  $orderBy: [GarageOrderByWithRelationInput!]
  $where: GarageWhereInput
) {
  garages(
    skip: $skip
    take: $take
    cursor: $cursor
    orderBy: $orderBy
    where: $where
  ) {
    id
    displayName
    description
    images
    verification {
      verified
    }
    address {
      id
      lat
      lng
      address
    }
    slotCounts {
      type
      count
    }
  }

  garagesCount(where: $where) {
    count
  }
}

mutation CreateGarage($createGarageInput: CreateGarageInput!) {
  createGarage(createGarageInput: $createGarageInput) {
    id
  }
}

mutation CreateManySlots($createSlotInput: CreateSlotInput!, $count: Float!) {
  createManySlots(createSlotInput: $createSlotInput, count: $count) {
    count
  }
}

fragment ValetFields on Valet {
  image
  uid
  displayName
}

fragment BookingFields on Booking {
  id
  pricePerHour
  endTime
  startTime
  vehicleNumber
  passcode
  status
  bookingTimeline {
    status
    timestamp
  }
  valetAssignment {
    pickupValet {
      ...ValetFields
    }
    returnValet {
      ...ValetFields
    }
  }
  slot {
    displayName
    garage {
      images
      address {
        address
        lat
        lng
      }
    }
  }
}

query BookingsForCustomer(
  $skip: Float
  $take: Float
  $cursor: BookingWhereUniqueInput
  $orderBy: [BookingOrderByWithRelationInput!]
  $where: BookingWhereInput
  $distinct: [BookingScalarFieldEnum!]
) {
  bookingsForCustomer(
    skip: $skip
    take: $take
    cursor: $cursor
    orderBy: $orderBy
    where: $where
    distinct: $distinct
  ) {
    ...BookingFields
  }

  bookingsCount(where: $where) {
    count
  }
}

query BookingsForGarage(
  $skip: Float
  $take: Float
  $cursor: BookingWhereUniqueInput
  $orderBy: [BookingOrderByWithRelationInput!]
  $where: BookingWhereInput
  $distinct: [BookingScalarFieldEnum!]
) {
  bookingsForGarage(
    skip: $skip
    take: $take
    cursor: $cursor
    orderBy: $orderBy
    where: $where
    distinct: $distinct
  ) {
    ...BookingFields
  }

  bookingsCount(where: $where) {
    count
  }
}

mutation createBookingTimeline(
  $createBookingTimelineInput: CreateBookingTimelineInput!
) {
  createBookingTimeline(
    createBookingTimelineInput: $createBookingTimelineInput
  ) {
    bookingId
    id
    managerId
    status
    timestamp
  }
}

query ValetMe {
  valetMe {
    uid
    companyId
  }
}

query AdminMe {
  adminMe {
    uid
  }
}

mutation CreateValet($createValetInput: CreateValetInput!) {
  createValet(createValetInput: $createValetInput) {
    uid
  }
}

query companyValets(
  $distinct: [ValetScalarFieldEnum!]
  $skip: Float
  $take: Float
  $cursor: ValetWhereUniqueInput
  $orderBy: [ValetOrderByWithRelationInput!]
  $where: ValetWhereInput
) {
  companyValets(
    distinct: $distinct
    skip: $skip
    take: $take
    cursor: $cursor
    orderBy: $orderBy
    where: $where
  ) {
    displayName
    uid
    createdAt
    updatedAt
    companyId
    image
    licenceID
  }

  companyValetsTotal(where: $where)
}

query valetPickups($skip: Float, $take: Float) {
  valetPickups(skip: $skip, take: $take) {
    id
    vehicleNumber
    valetAssignment {
      pickupLat
      pickupLng
      pickupValetId
    }
    startTime
    endTime
    slot {
      garage {
        address {
          lat
          lng
        }
      }
    }
  }
  valetPickupsTotal
}

query valetDrops($skip: Float, $take: Float) {
  valetDrops(skip: $skip, take: $take) {
    id
    vehicleNumber
    startTime
    endTime
    valetAssignment {
      returnLat
      returnLng
      returnValetId
    }
    slot {
      garage {
        address {
          lat
          lng
        }
      }
    }
  }
  valetDropsTotal
}

mutation AssignValet($bookingId: Float!, $status: String!) {
  assignValet(bookingId: $bookingId, status: $status) {
    id
  }
}

fragment ValetBookingFields on Booking {
  id
  vehicleNumber
  passcode
  status
  startTime
  endTime
  slot {
    garage {
      address {
        lat
        lng
      }
    }
  }
}

query myPickupTrips(
  $distinct: [BookingScalarFieldEnum!]
  $skip: Float
  $take: Float
  $orderBy: [BookingOrderByWithRelationInput!]
  $where: BookingWhereInput
) {
  bookingsForValet(
    distinct: $distinct
    skip: $skip
    take: $take
    orderBy: $orderBy
    where: $where
  ) {
    ...ValetBookingFields
    valetAssignment {
      pickupLat
      pickupLng
      pickupValetId
    }
  }
  bookingsCount(where: $where) {
    count
  }
}
query myDropTrips(
  $distinct: [BookingScalarFieldEnum!]
  $skip: Float
  $take: Float
  $orderBy: [BookingOrderByWithRelationInput!]
  $where: BookingWhereInput
) {
  bookingsForValet(
    distinct: $distinct
    skip: $skip
    take: $take
    orderBy: $orderBy
    where: $where
  ) {
    ...ValetBookingFields
    valetAssignment {
      returnLat
      returnLng
      returnValetId
    }
  }
  bookingsCount(where: $where) {
    count
  }
}

mutation CreateVerification(
  $createVerificationInput: CreateVerificationInput!
) {
  createVerification(createVerificationInput: $createVerificationInput) {
    adminId
    createdAt
    garageId
    updatedAt
    verified
  }
}

mutation RemoveVerification($where: VerificationWhereUniqueInput!) {
  removeVerification(where: $where) {
    adminId
    createdAt
    garageId
    updatedAt
    verified
  }
}

query admins(
  $distinct: [AdminScalarFieldEnum!]
  $skip: Float
  $take: Float
  $cursor: AdminWhereUniqueInput
  $orderBy: [AdminOrderByWithRelationInput!]
  $where: AdminWhereInput
) {
  admins(
    distinct: $distinct
    skip: $skip
    take: $take
    cursor: $cursor
    orderBy: $orderBy
    where: $where
  ) {
    uid
    updatedAt
    user {
      name
    }
    createdAt
    verificationsCount
  }
  adminsCount(where: $where)
}

mutation RemoveAdmin($where: AdminWhereUniqueInput!) {
  removeAdmin(where: $where) {
    createdAt
    user {
      name
    }
    updatedAt
    uid
  }
}

mutation CreateAdmin($createAdminInput: CreateAdminInput!) {
  createAdmin(createAdminInput: $createAdminInput) {
    createdAt
    user {
      name
    }
    uid
    updatedAt
  }
}
</file>

<file path="libs/network/codegen.ts">
import type { CodegenConfig } from '@graphql-codegen/cli'
const documentsPattern = '**/*.graphql'
const plugins = [
  'typescript',
  'typescript-operations',
  'named-operations-object',
  'typed-document-node',
]

const config: CodegenConfig = {
  overwrite: true,
  schema: '../../apps/api/src/schema.gql',
  watch: true,
  generates: {
    './src/gql/generated.tsx': {
      documents: `./src/${documentsPattern}`,
      plugins,
    },
  },
}

export default config
</file>

<file path="libs/network/next-auth.d.ts">
import type { DefaultUser } from 'next-auth'

declare module 'next-auth' {
  interface Session {
    user?: Omit<DefaultUser, 'id'> & { uid: string }
  }
}
</file>

<file path="libs/network/package.json">
{
  "name": "@autospace/network",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "devDependencies": {
    "@graphql-codegen/cli": "^5.0.2",
    "@graphql-codegen/named-operations-object": "^3.0.0",
    "@graphql-codegen/typed-document-node": "^5.0.6",
    "@parcel/watcher": "^2.4.1",
    "@types/jsonwebtoken": "^9.0.6"
  },
  "scripts": {
    "codegen": "graphql-codegen --config codegen.ts"
  },
  "dependencies": {
    "@apollo/client": "^3.10.2",
    "jsonwebtoken": "^9.0.2"
  },
  "peerDependencies": {
    "react": "^18.3.1"
  }
}
</file>

<file path="libs/network/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": ".",
    "jsx": "react-jsx"
  }
}
</file>

<file path="libs/sample-lib/index.ts">
export const add = (a: number, b: number) => {
  return a + b
}
</file>

<file path="libs/sample-lib/package.json">
{
  "name": "@autospace/sample-lib",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "tsc": "tsc --noEmit"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
</file>

<file path="libs/sample-lib/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "."
  }
}
</file>

<file path="libs/ui/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="libs/ui/public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="libs/ui/src/app/globals.css">
@import '../components/organisms/map/map.css';
@import 'react-toastify/dist/ReactToastify.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

.Toastify__toast {
  @apply rounded-none font-sans shadow-lg;
}

.Toastify__progress-bar-theme--light {
  background: #000;
  @apply rounded-none;
}

.bg-checker {
  background-image: linear-gradient(45deg, #000 25%, transparent 25%),
    linear-gradient(-45deg, #000 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, #000 75%),
    linear-gradient(-45deg, transparent 75%, #000 75%);
  background-size: 1rem 1rem;
  background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
}
</file>

<file path="libs/ui/src/app/layout.tsx">
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
</file>

<file path="libs/ui/src/app/page.tsx">
import Image from 'next/image'

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <div className="z-10 w-full max-w-5xl items-center justify-between font-mono text-sm lg:flex">
        <p className="fixed left-0 top-0 flex w-full justify-center border-b border-gray-300 bg-gradient-to-b from-zinc-200 pb-6 pt-8 backdrop-blur-2xl dark:border-neutral-800 dark:bg-zinc-800/30 dark:from-inherit lg:static lg:w-auto  lg:rounded-xl lg:border lg:bg-gray-200 lg:p-4 lg:dark:bg-zinc-800/30">
          Get started by editing&nbsp;
          <code className="font-mono font-bold">src/app/page.tsx</code>
        </p>
        <div className="fixed bottom-0 left-0 flex h-48 w-full items-end justify-center bg-gradient-to-t from-white via-white dark:from-black dark:via-black lg:static lg:size-auto lg:bg-none">
          <a
            className="pointer-events-none flex place-items-center gap-2 p-8 lg:pointer-events-auto lg:p-0"
            href="https://vercel.com?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            By{' '}
            <Image
              src="/vercel.svg"
              alt="Vercel Logo"
              className="dark:invert"
              width={100}
              height={24}
              priority
            />
          </a>
        </div>
      </div>

      <div className="relative z-[-1] flex place-items-center before:absolute before:h-[300px] before:w-full before:-translate-x-1/2 before:rounded-full before:bg-gradient-radial before:from-white before:to-transparent before:blur-2xl before:content-[''] after:absolute after:-z-20 after:h-[180px] after:w-full after:translate-x-1/3 after:bg-gradient-conic after:from-sky-200 after:via-blue-200 after:blur-2xl after:content-[''] before:dark:bg-gradient-to-br before:dark:from-transparent before:dark:to-blue-700 before:dark:opacity-10 after:dark:from-sky-900 after:dark:via-[#0141ff] after:dark:opacity-40 sm:before:w-[480px] sm:after:w-[240px] before:lg:h-[360px]">
        <Image
          className="relative dark:drop-shadow-[0_0_0.3rem_#ffffff70] dark:invert"
          src="/next.svg"
          alt="Next.js Logo"
          width={180}
          height={37}
          priority
        />
      </div>

      <div className="mb-32 grid text-center lg:mb-0 lg:w-full lg:max-w-5xl lg:grid-cols-4 lg:text-left">
        <a
          href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          className="group rounded-lg border border-transparent px-5 py-4 transition-colors hover:border-gray-300 hover:bg-gray-100 hover:dark:border-neutral-700 hover:dark:bg-neutral-800/30"
          target="_blank"
          rel="noopener noreferrer"
        >
          <h2 className="mb-3 text-2xl font-semibold">
            Docs{' '}
            <span className="inline-block transition-transform group-hover:translate-x-1 motion-reduce:transform-none">
              -&gt;
            </span>
          </h2>
          <p className="m-0 max-w-[30ch] text-sm opacity-50">
            Find in-depth information about Next.js features and API.
          </p>
        </a>

        <a
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          className="group rounded-lg border border-transparent px-5 py-4 transition-colors hover:border-gray-300 hover:bg-gray-100 hover:dark:border-neutral-700 hover:dark:bg-neutral-800/30"
          target="_blank"
          rel="noopener noreferrer"
        >
          <h2 className="mb-3 text-2xl font-semibold">
            Learn{' '}
            <span className="inline-block transition-transform group-hover:translate-x-1 motion-reduce:transform-none">
              -&gt;
            </span>
          </h2>
          <p className="m-0 max-w-[30ch] text-sm opacity-50">
            Learn about Next.js in an interactive course with&nbsp;quizzes!
          </p>
        </a>

        <a
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          className="group rounded-lg border border-transparent px-5 py-4 transition-colors hover:border-gray-300 hover:bg-gray-100 hover:dark:border-neutral-700 hover:dark:bg-neutral-800/30"
          target="_blank"
          rel="noopener noreferrer"
        >
          <h2 className="mb-3 text-2xl font-semibold">
            Templates{' '}
            <span className="inline-block transition-transform group-hover:translate-x-1 motion-reduce:transform-none">
              -&gt;
            </span>
          </h2>
          <p className="m-0 max-w-[30ch] text-sm opacity-50">
            Explore starter templates for Next.js.
          </p>
        </a>

        <a
          href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          className="group rounded-lg border border-transparent px-5 py-4 transition-colors hover:border-gray-300 hover:bg-gray-100 hover:dark:border-neutral-700 hover:dark:bg-neutral-800/30"
          target="_blank"
          rel="noopener noreferrer"
        >
          <h2 className="mb-3 text-2xl font-semibold">
            Deploy{' '}
            <span className="inline-block transition-transform group-hover:translate-x-1 motion-reduce:transform-none">
              -&gt;
            </span>
          </h2>
          <p className="m-0 max-w-[30ch] text-balance text-sm opacity-50">
            Instantly deploy your Next.js site to a shareable URL with Vercel.
          </p>
        </a>
      </div>
    </main>
  )
}
</file>

<file path="libs/ui/src/components/atoms/Accordion.tsx">
import {
  Disclosure,
  DisclosureButton,
  DisclosurePanel,
} from '@headlessui/react'
import { IconChevronDown } from '@tabler/icons-react'
import { ReactNode } from 'react'

export interface IAccordionProps {
  title: ReactNode
  children: ReactNode
  className?: string
  defaultOpen?: boolean
}

export const Accordion = ({
  title,
  children,
  className,
  defaultOpen = false,
}: IAccordionProps) => (
  <Disclosure defaultOpen={defaultOpen}>
    {({ open }) => (
      <>
        <DisclosureButton
          className={`flex justify-between items-center w-full py-2 font-medium ${className}`}
        >
          <span
            className={`text-left ${open ? 'font-semibold' : 'text-gray-600'}`}
          >
            {title}
          </span>
          <IconChevronDown
            className={` ${
              open ? 'transform rotate-180' : 'text-gray-500'
            } w-5 h-5 `}
          />
        </DisclosureButton>
        <DisclosurePanel className="w-full px-2 pb-4 text-gray-600">
          {children}
        </DisclosurePanel>
      </>
    )}
  </Disclosure>
)
</file>

<file path="libs/ui/src/components/atoms/Autocomplete.tsx">
import MuiAutocomplete, { AutocompleteProps } from '@mui/material/Autocomplete'
import { IconSearch } from '@tabler/icons-react'
type AutocompleteSimplifiedProps<T> = Omit<
  AutocompleteProps<T, false, false, false>,
  'renderInput'
> & {
  placeholder?: string
}

export const Autocomplete = <T,>({
  placeholder = 'Search...',
  ...props
}: AutocompleteSimplifiedProps<T>) => {
  return (
    <MuiAutocomplete
      autoSelect
      handleHomeEndKeys
      classes={{
        root: ' font-light  ',
        input: 'p-2',
        noOptions: ' backdrop-filter backdrop-blur',
        loading: ' backdrop-filter backdrop-blur',
        listbox: 'p-0  backdrop-filter backdrop-blur max-h-64',
        option: 'hover:bg-white bg-opacity-100',
        paper:
          ' shadow-md border border-white mt-1 bg-transparent rounded-none',
      }}
      renderInput={(params) => (
        <div
          ref={params.InputProps.ref}
          className="flex items-center bg-transparent"
        >
          <input
            type="text"
            {...params.inputProps}
            className="w-full py-2 pl-3 text-sm pr-8 shadow-none focus:ring-0  border border-white"
            placeholder={placeholder}
          />
          <IconSearch className="w-4 h-4 text-gray-800 stroke-2 -ml-7" />
        </div>
      )}
      {...props}
    />
  )
}
</file>

<file path="libs/ui/src/components/atoms/Badge.tsx">
import { ReactNode } from 'react'

export interface IBadgeProps {
  children: ReactNode
  size?: 'sm' | 'md' | 'lg'
  variant?: 'primary' | 'gray' | 'red' | 'yellow' | 'green'
}

export const Badge = ({
  children,
  size = 'md',
  variant = 'gray',
}: IBadgeProps) => {
  const sizeCls = {
    sm: 'px-2 text-xs',
    md: 'px-2 py-1.5 text-sm',
    lg: 'px-3 py-1.5',
  }
  const variantCls = {
    primary: 'bg-primary-100 border border-white text-primary-900',
    gray: 'bg-gray-100 border border-white text-gray-900',
    red: 'bg-red-100 border border-white text-red-900',
    yellow: 'bg-yellow-100 border border-white  text-yellow-900',
    green: 'bg-green-100 border border-white  text-green-900',
  }
  return (
    <span
      className={`transition-all  py-1 px-2 items-center shadow justify-center duration-300  rounded-full ${sizeCls[size]} ${variantCls[variant]}`}
    >
      {children}
    </span>
  )
}
</file>

<file path="libs/ui/src/components/atoms/Brand.tsx">
import { Role } from '@autospace/util/types'
import { BrandIcon } from './BrandIcon'

export interface IBrandProps {
  className?: string
  shortForm?: boolean
  type?: Role
}

export const Brand = ({
  shortForm = false,
  className,
  type = undefined,
}: IBrandProps) => {
  return (
    <div className={`grid place-items-center z-50 ${className}`}>
      <div className="text-xl ">
        {shortForm ? (
          <div className="flex gap-1">
            <BrandIcon /> A.
          </div>
        ) : (
          <div className="flex items-center gap-2 font-medium tracking-tighter font-playfair">
            <BrandIcon />
            <div>
              <div className="flex gap-1">
                <div>Autospace</div>
                {type ? <span className="text-xs">{type}</span> : null}
              </div>
              <div className="text-xs text-gray">Karthick Ragavendran</div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/atoms/BrandIcon.tsx">
import { ReactNode } from 'react'

export interface IBrandIconProps {
  children?: ReactNode
}

export const BrandIcon = ({
  children = <div className={`bg-gray-100 shadow w-2 h-4 animate-park-car `} />,
}: IBrandIconProps) => {
  return (
    <div className="inline-block overflow-hidden">
      <div
        className={`flex items-center justify-center border-2 border-primary w-4 h-6`}
      >
        {children}
      </div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/atoms/Button.tsx">
import { IconRotateClockwise2 } from '@tabler/icons-react'

type ButtonSizes = 'none' | 'sm' | 'md' | 'lg' | 'xl'

export type IButtonProps = {
  size?: ButtonSizes
  variant?: 'contained' | 'outlined' | 'text'
  color?: 'primary' | 'success' | 'error' | 'white' | 'black'
  fullWidth?: boolean
  loading?: boolean
} & React.DetailedHTMLProps<
  React.ButtonHTMLAttributes<HTMLButtonElement>,
  HTMLButtonElement
>

const variantColor = {
  contained: {
    primary:
      'text-black bg-primary border-2 border-primary enabled:hover:bg-primary-600',
    white: 'text-black bg-white',
    black: 'text-primary bg-black enabled:hover:bg-gray-900',
    success: 'text-white bg-green enabled:hover:bg-green-700',
    error: 'text-white bg-red enabled:hover:bg-red-700',
  },

  outlined: {
    primary: 'border-2 border-primary text-black enabled:hover:bg-black/10',
    white: 'border-2 border-white text-white enabled:hover:bg-white/10',
    black: 'border-2 border-black text-black enabled:hover:bg-black/10',
    success: 'border-2 border-green text-green enabled:hover:bg-green-100',
    error: 'border-2 border-red text-red enabled:hover:bg-red-100',
  },
  text: {
    primary: 'text-primary-900 ',
    white: 'text-white',
    black: 'text-black',
    success: 'text-green ',
    error: 'text-red ',
  },
}

const sizes: { [key in ButtonSizes]: string } = {
  none: 'text-xs',
  sm: 'px-3 py-1.5 text-xs',
  md: 'px-4 py-2 text-sm',
  lg: 'px-5 py-2 text-base',
  xl: 'px-8 py-3 text-xl',
}

export const Button = ({
  size = 'md',
  variant = 'contained',
  color = 'primary',
  fullWidth = false,
  disabled = false,
  children,
  className,
  loading = false,
  type = 'button',
  ...props
}: IButtonProps) => {
  const variantCls = variantColor[variant][color]
  //   variant === 'text' ? sizes.none :
  const sizeCls = sizes[size]

  const fwCls = fullWidth && 'w-full'
  const disCls = (disabled || loading) && 'opacity-60 cursor-auto'

  return (
    <button
      type={type}
      disabled={disabled || loading}
      className={`rounded relative font-medium ${sizeCls} ${fwCls} ${variantCls} ${disCls}  ${className} `}
      {...props}
    >
      {loading ? (
        <>
          <div className="absolute inset-0 flex items-center justify-center">
            <IconRotateClockwise2 className="w-5 h-5 animate-spin" />
          </div>
          <div className="opacity-10">{children}</div>
        </>
      ) : (
        <>{children}</>
      )}
    </button>
  )
}
</file>

<file path="libs/ui/src/components/atoms/Container.tsx">
import { ReactNode } from 'react'

export interface IContainerProps {
  children: ReactNode
  className?: string
}

export const Container = ({ children, className }: IContainerProps) => (
  <div className={`container sm:px-2 mx-auto ${className}`}>{children}</div>
)
</file>

<file path="libs/ui/src/components/atoms/Dialog.tsx">
import {
  Dialog as HeadlessUIDialog,
  DialogPanel,
  DialogTitle,
  Transition,
  TransitionChild,
} from '@headlessui/react'
import { IconX } from '@tabler/icons-react'
import { Dispatch, Fragment, ReactNode, SetStateAction } from 'react'

interface IMyDialogProps {
  open: boolean
  setOpen: Dispatch<SetStateAction<boolean>>
  children: ReactNode
  title: string
  className?: string
  widthClassName?: string
}

export const Dialog = ({
  open,
  setOpen,
  children,
  title,
  widthClassName = 'max-w-md',
}: IMyDialogProps) => {
  function closeModal() {
    setOpen(false)
  }

  return (
    <Transition appear show={open} as={Fragment}>
      <HeadlessUIDialog
        as="div"
        className="relative z-50 rounded"
        onClose={closeModal}
      >
        <TransitionChild
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black/20 backdrop-blur-sm" />
        </TransitionChild>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex items-center justify-center min-h-full p-4 text-center">
            <TransitionChild
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <DialogPanel
                className={`w-full  p-4 overflow-hidden text-left align-middle transition-all transform bg-white shadow-xl ${widthClassName}`}
              >
                <button
                  type="button"
                  className="absolute top-0 right-0 flex items-center justify-center w-8 h-8 hover:bg-black/10"
                  onClick={() => setOpen(false)}
                >
                  <IconX className="text-gray-600" />
                </button>
                <DialogTitle
                  as="h3"
                  className="mb-4 text-lg font-medium leading-6 text-gray-900"
                >
                  {title}
                </DialogTitle>
                {children}
              </DialogPanel>
            </TransitionChild>
          </div>
        </div>
      </HeadlessUIDialog>
    </Transition>
  )
}
</file>

<file path="libs/ui/src/components/atoms/Dot.tsx">
import { BaseComponent } from '@autospace/util/types'

export const PulsingDot = ({ children }: BaseComponent) => {
  if (children)
    return (
      <div className="absolute top-0 px-2 bg-primary-500 rounded-full left-full animate-pulse">
        {children}
      </div>
    )
  return (
    <div className="absolute top-0 left-full animate-pulse">
      <div className="w-2 h-2 rounded-full bg-primary-500" />
    </div>
  )
}
</file>

<file path="libs/ui/src/components/atoms/Form.tsx">
import React, { FormHTMLAttributes } from 'react'

type FormProps = FormHTMLAttributes<HTMLFormElement>

export const Form = React.forwardRef<HTMLFormElement, FormProps>(
  (props, ref) => (
    <form
      ref={ref}
      className="flex flex-col w-full gap-2 appearance-none placeholder-gray focus:ring-primary sm:text-sm"
      {...props}
    >
      {props.children}
    </form>
  ),
)
Form.displayName = 'Form'
</file>

<file path="libs/ui/src/components/atoms/FormError.tsx">
import { IconExclamationCircle } from '@tabler/icons-react'

export interface IFormErrorProps {}

export const FormError = ({ error }: { error?: string | undefined }) => {
  if (error) {
    return (
      <div className="flex items-center justify-start gap-1 mt-1 text-xs text-gray-900">
        <IconExclamationCircle className="inline w-4 h-4 text-red-600" />{' '}
        {error}
      </div>
    )
  }
  return null
}
</file>

<file path="libs/ui/src/components/atoms/HtmlInput.tsx">
import React, { InputHTMLAttributes } from 'react'

export type HtmlInputProps = InputHTMLAttributes<HTMLInputElement>

export const HtmlInput = React.forwardRef<HTMLInputElement, HtmlInputProps>(
  ({ className, ...props }, ref) => (
    <input
      ref={ref}
      className={`block w-full px-3 py-2 border rounded appearance-none placeholder-gray read-only:text-gray-600 focus:outline-none focus:ring-primary focus:border-primary sm:text-sm ${className}`}
      {...props}
    />
  ),
)
HtmlInput.displayName = 'Input'
</file>

<file path="libs/ui/src/components/atoms/HtmlLabel.tsx">
import React, { HTMLProps } from 'react'
import { FormError } from './FormError'

export type HtmlLabelProps = HTMLProps<HTMLLabelElement> & {
  error?: string | undefined
  optional?: boolean
}

export const HtmlLabel = React.forwardRef<HTMLLabelElement, HtmlLabelProps>(
  ({ children, title, optional, error, className }, ref) => (
    <label ref={ref} className={` text-sm block select-none ${className}`}>
      <div className="flex items-baseline justify-between">
        <div className="mb-1 font-semibold capitalize">{title}</div>
        <div className="text-xs text-gray-600 ">
          {optional ? '(optional)' : null}
        </div>
      </div>
      {children}
      <FormError error={error} />
    </label>
  ),
)

HtmlLabel.displayName = 'HtmlLabel'
</file>

<file path="libs/ui/src/components/atoms/HtmlSelect.tsx">
import React, { InputHTMLAttributes } from 'react'

export const HtmlSelect = React.forwardRef<
  HTMLSelectElement,
  InputHTMLAttributes<HTMLSelectElement>
>(({ children, ...props }: InputHTMLAttributes<HTMLSelectElement>, ref) => (
  <select
    {...props}
    ref={ref}
    className="block w-full px-3 py-2 placeholder-gray-500 border border-gray-200 rounded shadow-sm appearance-none focus:outline-none focus:ring-primary-500 focus:border-primary-500 sm:text-sm"
  >
    {children}
  </select>
))

HtmlSelect.displayName = 'HtmlSelect'
</file>

<file path="libs/ui/src/components/atoms/HtmlTextArea.tsx">
import React, { HTMLProps } from 'react'

export const HtmlTextArea = React.forwardRef<
  HTMLTextAreaElement,
  HTMLProps<HTMLTextAreaElement>
>((props, ref) => (
  <textarea
    ref={ref}
    {...props}
    className="block w-full px-3 py-2 border border-gray-200 rounded appearance-none read-only:text-gray-600 read-only:cursor-not-allowed focus:outline-none focus:ring-primary focus:border-primary sm:text-sm"
  />
))
HtmlTextArea.displayName = 'TextArea'
</file>

<file path="libs/ui/src/components/atoms/ParkingIcon.tsx">
export const ParkingIcon = () => {
  return (
    <div className="flex items-center justify-center w-6 h-6 text-lg font-bold border border-black shadow-lg cursor-pointer bg-primary shadow-black/30">
      P
    </div>
  )
}
</file>

<file path="libs/ui/src/components/atoms/Switch.tsx">
import { Switch as HUISwitch, SwitchGroup, Label } from '@headlessui/react'
import { ReactNode } from 'react'

export interface Switch2Props {
  label: ReactNode
  children?: ReactNode
  checked: boolean
  onChange: (checked: boolean) => void
  className?: string
}

export const Switch = ({
  label,
  children,
  checked,
  onChange,
  className,
}: Switch2Props) => {
  return (
    <SwitchGroup>
      <div className={`flex items-center ${className}`}>
        <Label className="mr-2 text-sm">{label}</Label>
        <HUISwitch
          checked={checked}
          onChange={onChange}
          className={`${
            checked ? 'bg-primary-600' : 'bg-gray-200'
          } relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}
        >
          <span
            className={`${
              checked ? 'translate-x-6' : 'translate-x-1'
            } inline-block h-4 w-4 transform rounded-full bg-white transition-transform`}
          >
            {children}
          </span>
        </HUISwitch>
      </div>
    </SwitchGroup>
  )
}
</file>

<file path="libs/ui/src/components/atoms/TitleValue.tsx">
import { ReactNode } from 'react'

export const TitleValue = ({
  title,
  children,
}: {
  title: string
  children: ReactNode
}) => (
  <div>
    <strong className="font-semibold">{title}</strong>{' '}
    <div className="text-sm">{children}</div>
  </div>
)

export const TitleStrongValue = ({
  title,
  children,
}: {
  title: string
  children: ReactNode
}) => (
  <div>
    <div className="text-sm text-gray">{title}</div>
    <div className="text-black">{children}</div>{' '}
  </div>
)
</file>

<file path="libs/ui/src/components/molecules/AlertSection.tsx">
import { ReactNode } from 'react'

export interface IAlertSectionProps {
  title?: ReactNode
  children: ReactNode
}

export const AlertSection = ({ title, children }: IAlertSectionProps) => {
  return (
    <div className="min-h-[calc(100vh-8rem)] mt-4">
      {title ? <div className="mb-1 text-lg font-semibold">{title}</div> : null}
      <div className="h-64 bg-white">
        <div className="flex flex-col items-center justify-center h-full gap-4 font-light">
          {children}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/molecules/AuthLayout.tsx">
'use client'
import { CarScene } from '@autospace/3d/src/scenes/CarScene'
import { RotatingCamera } from '@autospace/3d/src/components/camera/Rotating'
import { IconArrowBack } from '@tabler/icons-react'
import Link from 'next/link'
import { ReactNode } from 'react'
import { BrandIcon } from '../atoms/BrandIcon'
import { GoogleButton } from './GoogleButton'

export interface IAuthLayoutProps {
  children: ReactNode
  title: string
}

export const AuthLayout = ({ title, children }: IAuthLayoutProps) => {
  return (
    <div className="relative h-[calc(100vh-4rem)]  ">
      <CarScene
        orbitControls={false}
        camera={<RotatingCamera />}
        hideAllComments
      />
      <div className=" flex flex-col justify-center items-center absolute top-0 bg-black/20 backdrop-blur-sm bottom-0  ">
        <div className="p-4 text-white ">
          <div className="w-full max-w-lg mx-auto ">
            <h1 className="flex items-center gap-2 mb-2 text-2xl">
              <BrandIcon /> <div>{title}</div>
            </h1>
            {children}
            <div className="mt-4 text-sm text-gray-300">
              <div className="flex flex-col items-center mb-4">
                <div className="mb-1 text-xs">Or, continue with</div>
                <GoogleButton />
              </div>
              <Link href="/" className="flex items-center gap-2">
                <IconArrowBack className="w-4 h-4" /> Back to home
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/molecules/CostTitleValue.tsx">
import { ReactNode } from 'react'

export const CostTitleValue = ({
  title,
  price,
}: {
  title: string
  price: ReactNode
}) => {
  if (!price) return null
  return (
    <div className="flex justify-between text-lg font-bold">
      <div>{title}</div>
      <div>${price}</div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/molecules/DateRangeBookingInfo.tsx">
import { IconArrowRightCircle } from '@tabler/icons-react'
import { useEffect, useState } from 'react'

import {
  differenceInTime,
  formatDate,
  formatTime,
  getTimeUnits,
} from '@autospace/util/date'

export interface IDateRangeBookingInfoProps {
  startTime?: string
  endTime?: string
}

export const DateRangeBookingInfo = ({
  startTime,
  endTime,
}: IDateRangeBookingInfoProps) => {
  const [duration, setDuration] = useState<string | null>(null)

  useEffect(() => {
    if (!startTime || !endTime) return
    const differenceInMilliseconds = differenceInTime({
      startTime,
      endTime,
    })

    if (differenceInMilliseconds < 0) {
      setDuration('Invalid date range')
      return
    }

    setDuration(getTimeUnits(differenceInMilliseconds).timeString)
  }, [startTime, endTime])

  if (!startTime || !endTime) return null

  return (
    <>
      <div className="flex items-center justify-between gap-2 my-4">
        <div>
          <div className="text-lg font-bold">{formatTime(startTime)}</div>
          <div className="text-xs text-gray-600">{formatDate(startTime)}</div>
        </div>
        <div className="flex flex-col items-center justify-end">
          <IconArrowRightCircle />
          <div className="-mt-1 text-xs text-center text-gray-600">
            {duration ? duration : 'Select date'}
          </div>
        </div>
        <div className="text-right">
          <div>
            <div className="text-lg font-bold">{formatTime(endTime)}</div>
            <div className="text-xs text-gray-600">{formatDate(endTime)}</div>
          </div>
        </div>
      </div>
    </>
  )
}
</file>

<file path="libs/ui/src/components/molecules/FilterHeading.tsx">
import { PulsingDot } from '../atoms/Dot'

export const FilterHeading = ({
  title,
  dirty = true,
}: {
  title: string
  dirty: boolean
}) => (
  <div className="relative inline-block font-semibold ">
    {dirty && <PulsingDot />}
    {title}
  </div>
)
</file>

<file path="libs/ui/src/components/molecules/GoogleButton.tsx">
import { signIn } from 'next-auth/react'

export const GoogleButton = () => {
  return (
    <button
      onClick={() => {
        signIn('google', { callbackUrl: '/' })
      }}
      className="text-lg hover:shadow-lg transition-shadow flex items-center justify-center w-8 h-8 border border-[#ea4335] rounded-full"
    >
      G
    </button>
  )
}
</file>

<file path="libs/ui/src/components/molecules/IconTypes.tsx">
import { SlotType } from '@autospace/network/src/gql/generated'
import {
  IconBike,
  IconMotorbike,
  IconCar,
  IconTir,
  IconMoonStars,
  IconSunset,
  IconSun,
  IconSunrise,
} from '@tabler/icons-react'

export const IconTypes = {
  [SlotType.Bicycle]: <IconBike className="w-6 h-6 " />,
  [SlotType.Bike]: <IconMotorbike className="w-6 h-6 " />,
  [SlotType.Car]: <IconCar className="w-6 h-6 " />,
  [SlotType.Heavy]: <IconTir className="w-6 h-6 " />,
}

export const IconType = ({
  time,
  className,
}: {
  time: string
  className?: string
}) => {
  const date = new Date(time)
  const hour = date.getHours() // get the hour in UTC

  if (hour >= 4 && hour < 10) return <IconSunrise className="w-5 h-5" />
  if (hour >= 10 && hour < 16) return <IconSun className="w-5 h-5" />
  if (hour >= 16 && hour < 20) return <IconSunset className="w-5 h-5" />
  return <IconMoonStars className={`w-5 h-5 ${className}`} />
}
</file>

<file path="libs/ui/src/components/molecules/Loader.tsx">
import { IconRotateClockwise2 } from '@tabler/icons-react'
import { AlertSection } from './AlertSection'

export const Loader = () => <IconRotateClockwise2 className="animate-spin" />
export const LoaderPanel = ({ text }: { text?: string }) => (
  <AlertSection title={text}>
    <Loader />
  </AlertSection>
)
</file>

<file path="libs/ui/src/components/molecules/LogoutButton.tsx">
'use client'
import { IconDoorExit } from '@tabler/icons-react'
import { signOut } from 'next-auth/react'
import { Button } from '../atoms/Button'

export const LogoutButton = () => {
  return (
    <Button
      variant="outlined"
      onClick={() => {
        signOut()
      }}
      className="flex gap-2"
    >
      <IconDoorExit /> Logout
    </Button>
  )
}
</file>

<file path="libs/ui/src/components/molecules/MapLink.tsx">
import { LatLng } from '@autospace/util/types'
import { IconMap2 } from '@tabler/icons-react'
import Link from 'next/link'
import { ReactNode } from 'react'

export interface IMapLinkProps {
  waypoints: LatLng[]
  children?: ReactNode
  className?: string
}

export const MapLink = ({
  waypoints,
  children = <IconMap2 />,
  className,
}: IMapLinkProps) => {
  if (waypoints.length === 0) {
    return null
  }

  if (waypoints.length === 1) {
    const { lat, lng } = waypoints[0]
    const googleMapsUrl = `https://www.google.com/maps/search/?api=1&query=${lat},${lng}`

    return (
      <Link
        href={googleMapsUrl}
        target="_blank"
        rel="noopener noreferrer"
        className={className}
      >
        {children}
      </Link>
    )
  }

  const origin = waypoints[0]
  const destination = waypoints[waypoints.length - 1]
  const waypointsParam = waypoints
    .slice(1, -1)
    .map(({ lat, lng }) => `${lat},${lng}`)
    .join('|')

  const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&origin=${origin.lat},${origin.lng}&destination=${destination.lat},${destination.lng}&waypoints=${waypointsParam}`
  return (
    <Link
      href={googleMapsUrl}
      target="_blank"
      rel="noopener noreferrer"
      className={className}
    >
      {children}
    </Link>
  )
}
</file>

<file path="libs/ui/src/components/molecules/NoResults.tsx">
import { IconBox } from '@tabler/icons-react'

export const NoResults = () => {
  return (
    <div className="flex flex-col items-center justify-center gap-2 h-60 bg-gray-25">
      <IconBox className="w-10 h-10" />
      <div className="text-sm">No results</div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/molecules/RangeSlider.tsx">
import Slider, { SliderProps } from '@mui/material/Slider'

export const RangeSlider = (props: SliderProps) => (
  <div className="w-full pt-6 pl-2 pr-4">
    <Slider
      valueLabelDisplay="on"
      classes={{
        root: `h-0.5 w-full border-0 `,
        thumb:
          'rounded-none border w-4 h-4 after:active:bg-black/10 after:w-8 after:h-8 after:rounded-none bg-white hover:shadow-none hover:border-black hover:bg-gray-50 focus:bg-gray-50',
        track: 'text-gray-800 ',
        rail: 'bg-gray-400',
        valueLabel:
          'text-black rounded-none py-1 px-0.5 text-sm bg-white/20 h-0 w-0',
      }}
      {...props}
    />
  </div>
)
</file>

<file path="libs/ui/src/components/molecules/Reveal.tsx">
'use client'
import { ReactNode, useState } from 'react'
export interface IRevealProps {
  secret: ReactNode
  showIntruction?: boolean
  className?: string
}

export const Reveal = ({
  secret,
  showIntruction = false,
  className,
}: IRevealProps) => {
  const [revealed, setRevealed] = useState(false)

  return (
    <button
      className={`flex flex-col items-center gap-2 ${className}`}
      onClick={() => setRevealed((state) => !state)}
    >
      <span
        className={`text-lg tracking-wider w-full border px-1 ${
          revealed
            ? 'bg-white   shadow-sm '
            : 'bg-checker border-white  text-transparent'
        }`}
      >
        {secret}
      </span>
      {showIntruction ? (
        <span className="text-xs text-gray-600">
          {revealed ? 'Hide' : 'Tap to reveal'}
        </span>
      ) : null}
    </button>
  )
}
</file>

<file path="libs/ui/src/components/molecules/SessionProvider.tsx">
'use client'

import { SessionProvider as NextAuthSessionProvider } from 'next-auth/react'
import { ReactNode } from 'react'

export const SessionProvider = ({ children }: { children: ReactNode }) => {
  return <NextAuthSessionProvider>{children}</NextAuthSessionProvider>
}
</file>

<file path="libs/ui/src/components/molecules/Tabs.tsx">
import TabMui, { TabProps } from '@mui/material/Tab'
import TabsMui, { TabsProps } from '@mui/material/Tabs'

export const Tabs = (props: TabsProps) => {
  return (
    <TabsMui
      classes={{
        indicator: 'bg-black',
        flexContainer: 'gap-4',
        root: 'min-h-0 py-2',
      }}
      {...props}
    />
  )
}
export const Tab = (props: TabProps) => {
  return (
    <TabMui
      disableRipple
      classes={{
        root: 'px-0 py-2 min-w-0 min-h-0 capitalize z-10',
        selected: 'text-black font-semibold',
      }}
      {...props}
    />
  )
}

interface TabPanelProps {
  children?: React.ReactNode
  index: number
  value: number
}

export const TabPanel = (props: TabPanelProps) => {
  const { children, value, index, ...other } = props

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`simple-tabpanel-${index}`}
      aria-labelledby={`simple-tab-${index}`}
      {...other}
    >
      {value === index && children}
    </div>
  )
}
</file>

<file path="libs/ui/src/components/molecules/Toast.tsx">
import {
  ToastContainer as ReactToastifyContainer,
  toast,
  Slide,
} from 'react-toastify'

export const ToastContainer = () => (
  <ReactToastifyContainer transition={Slide} />
)

export { toast }
</file>

<file path="libs/ui/src/components/molecules/ToggleButtonGroup.tsx">
import ToggleButtonMui, { ToggleButtonProps } from '@mui/material/ToggleButton'
import ToggleButtonGroupMui, {
  ToggleButtonGroupProps,
} from '@mui/material/ToggleButtonGroup'
import { forwardRef } from 'react'

export const ToggleButtonGroup = forwardRef<
  JSX.Element,
  ToggleButtonGroupProps
>((props, ref) => (
  <ToggleButtonGroupMui classes={{ root: 'block mt-2' }} ref={ref} {...props} />
))

ToggleButtonGroup.displayName = 'ToggleButtonGroup'

export const ToggleButton = (props: ToggleButtonProps) => (
  <ToggleButtonMui
    classes={{
      root: 'rounded-none transition-all',
      selected: 'border border-black bg-white shadow-lg',
      //   standard: 'bg-gray-50 ',
    }}
    disableRipple
    disableTouchRipple
    disableFocusRipple
    {...props}
  />
)
</file>

<file path="libs/ui/src/components/molecules/UserInfo.tsx">
import { BaseComponent } from '@autospace/util/types'
import { useSession } from 'next-auth/react'
import Image from 'next/image'

export const UserInfo = ({ children, className }: BaseComponent) => {
  const session = useSession()
  const image = session.data?.user?.image
  const name = session.data?.user?.name
  const uid = session.data?.user?.uid
  return (
    <div className={`flex gap-2 ${className}`}>
      <Image
        src={image || '/user.png'}
        alt=""
        width={300}
        height={300}
        className="w-16 h-16 object-cover border"
      />
      <div>
        <div>{name}</div>
        <div className="text-sm text-gray">{uid}</div>
      </div>
      {children}
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/admin/AdminCard.tsx">
import { AdminsQuery } from '@autospace/network/src/gql/generated'
import { ReactNode } from 'react'
import { useSession } from 'next-auth/react'
import { format } from 'date-fns'

type AdminCardProps = {
  admin: AdminsQuery['admins'][number]
  children?: ReactNode
}

export const AdminCard = ({ admin, children }: AdminCardProps) => {
  const session = useSession()
  const uid = session.data?.user?.uid
  return (
    <div className="bg-white p-2 shadow-lg">
      <div className="flex items-start gap-2">
        <h2 className="text-lg font-bold ">{admin.user?.name}</h2>
        {uid === admin.uid ? (
          <span className="px-1 text-xs bg-primary">You</span>
        ) : null}
      </div>
      <p className="text-xs text-gray"> {admin.uid}</p>
      <div className="text-xs text-gray mt-1">
        <p>Since {format(new Date(admin.createdAt), 'PP')}</p>
      </div>
      <p className="mt-2">
        <span className="text-2xl">{admin.verificationsCount}</span>{' '}
        <span className="text-sm text-gray">verifications.</span>
      </p>
      <div className="mt-2">{children}</div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/admin/CreateAdmin.tsx">
import { useState } from 'react'
import { Button } from '../../atoms/Button'
import { Dialog } from '../../atoms/Dialog'
import { useFormUid } from '@autospace/forms/src/createUid'
import { Form } from '../../atoms/Form'
import { HtmlLabel } from '../../atoms/HtmlLabel'
import { HtmlInput } from '../../atoms/HtmlInput'
import { useMutation } from '@apollo/client'
import {
  CreateAdminDocument,
  namedOperations,
} from '@autospace/network/src/gql/generated'

export const CreateAdmin = () => {
  const [open, setOpen] = useState(false)
  const { register, handleSubmit } = useFormUid()
  const [createAdmin, { data, loading }] = useMutation(CreateAdminDocument, {
    awaitRefetchQueries: true,
    refetchQueries: [namedOperations.Query.admins],
  })
  return (
    <>
      <Button onClick={() => setOpen(true)}>Create admin</Button>
      <Dialog open={open} setOpen={setOpen} title={'Create admin'}>
        <Form
          onSubmit={handleSubmit(async ({ uid }) => {
            await createAdmin({
              variables: { createAdminInput: { uid } },
            })
            setOpen(false)
          })}
        >
          <HtmlLabel title="uid">
            <HtmlInput placeholder="uid" {...register('uid')} />
          </HtmlLabel>

          <Button loading={loading} type="submit">
            Create
          </Button>
        </Form>
      </Dialog>
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/admin/CreateVerificationButton.tsx">
import { useMutation } from '@apollo/client'
import {
  CreateVerificationDocument,
  namedOperations,
} from '@autospace/network/src/gql/generated'
import { Button } from '../../atoms/Button'

export const CreateVerificationButton = ({
  garageId,
}: {
  garageId: number
}) => {
  const [createVerification, { loading }] = useMutation(
    CreateVerificationDocument,
    {
      awaitRefetchQueries: true,
      refetchQueries: [namedOperations.Query.Garages],
    },
  )

  return (
    <Button
      size="none"
      variant="text"
      loading={loading}
      className="font-semibold underline underline-offset-4"
      onClick={async () => {
        await createVerification({
          variables: {
            createVerificationInput: {
              garageId,
              verified: true,
            },
          },
        })
      }}
    >
      Verify
    </Button>
  )
}
</file>

<file path="libs/ui/src/components/organisms/admin/RemoveAdminButton.tsx">
import { useMutation } from '@apollo/client'
import {
  RemoveAdminDocument,
  namedOperations,
} from '@autospace/network/src/gql/generated'
import { Button } from '../../atoms/Button'
import { IconTrash } from '@tabler/icons-react'
import { Dialog } from '../../atoms/Dialog'
import { useState } from 'react'

export const RemoveAdminButton = ({ uid }: { uid: string }) => {
  const [removeAdmin, { loading }] = useMutation(RemoveAdminDocument, {
    awaitRefetchQueries: true,
    refetchQueries: [namedOperations.Query.admins],
  })

  const [open, setOpen] = useState(false)

  return (
    <>
      <Button
        variant="text"
        size="none"
        loading={loading}
        onClick={() => setOpen(true)}
      >
        <IconTrash className="w-8 h-8 p-2 bg-red-50" />
      </Button>
      <Dialog open={open} setOpen={setOpen} title={'Delete'}>
        <div>
          Are you sure you want to delete this innocent soul from the admin
          realm?
        </div>
        <div className="my-2 text-xs text-gray">{uid}</div>
        <div className="grid w-full grid-cols-2 gap-2 mt-4">
          <Button variant="outlined" onClick={() => setOpen(false)}>
            No.
          </Button>
          <Button
            loading={loading}
            onClick={async () => {
              await removeAdmin({ variables: { where: { uid } } })
            }}
          >
            Yes.
          </Button>
        </div>
      </Dialog>
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/admin/RemoveVerificationButton.tsx">
import { useMutation } from '@apollo/client'
import {
  RemoveVerificationDocument,
  namedOperations,
} from '@autospace/network/src/gql/generated'
import { Button } from '../../atoms/Button'

export const RemoveVerificationButton = ({
  garageId,
}: {
  garageId: number
}) => {
  const [removeVerification, { loading }] = useMutation(
    RemoveVerificationDocument,
    {
      awaitRefetchQueries: true,
      refetchQueries: [namedOperations.Query.Garages],
    },
  )

  return (
    <Button
      size="none"
      variant="text"
      loading={loading}
      className="font-semibold"
      onClick={async () => {
        await removeVerification({
          variables: {
            where: {
              garageId,
            },
          },
        })
      }}
    >
      Unlist
    </Button>
  )
}
</file>

<file path="libs/ui/src/components/organisms/map/CurrentLocationButton.tsx">
import { IconCurrentLocation } from '@tabler/icons-react'
import { useMap } from 'react-map-gl'
import { Button } from '../../atoms/Button'

export interface ICurrentLocationButtonProps {}

export const CurrentLocationButton = () => {
  const { current: map } = useMap()

  return (
    <Button
      variant="text"
      className="hover:bg-gray-200"
      onClick={() => {
        navigator.geolocation.getCurrentPosition(
          ({ coords: { latitude, longitude } }) => {
            map?.flyTo({ center: { lat: latitude, lng: longitude }, zoom: 10 })
          },
          (error) => {
            console.error(error)
          },
          { enableHighAccuracy: true, timeout: 20000 },
        )
      }}
    >
      <IconCurrentLocation className="stroke-1.5" />
    </Button>
  )
}
</file>

<file path="libs/ui/src/components/organisms/map/map.css">
@import 'mapbox-gl/dist/mapbox-gl.css';
</file>

<file path="libs/ui/src/components/organisms/map/Map.tsx">
import MapGl, { useMap } from 'react-map-gl'

type MapProps = React.ComponentProps<typeof MapGl> & { height?: string }

export const Map = ({ height = 'calc(100vh - 4rem)', ...props }: MapProps) => {
  return (
    <MapGl
      {...props}
      projection={{ name: 'globe' }}
      mapStyle="mapbox://styles/iamkarthick/clebahxqe001701mo1i1adtw3"
      mapboxAccessToken={process.env.NEXT_PUBLIC_MAPBOX_TOKEN}
      style={{ height }}
      scrollZoom={false}
    >
      <StyleMap />
      {props.children}
    </MapGl>
  )
}

export const StyleMap = () => {
  const { current } = useMap()

  current?.on('style.load', () => {
    current?.getMap().setFog({
      color: 'rgb(255, 255, 255)', // Lower atmosphere
      range: [1, 10],
      //   @ts-ignore
      'high-color': 'rgb(200, 200, 200)', // Upper atmosphere
      'horizon-blend': 0.05, // Atmosphere thickness (default 0.2 at low zooms)
      'space-color': 'rgb(150, 150, 150)', // Background color
      'star-intensity': 0.5, // Background star brightness (default 0.35 at low zoooms )
    })
  })
  return null
}
</file>

<file path="libs/ui/src/components/organisms/map/MapMarker.tsx">
import { Marker as MarkerGl, MarkerProps } from 'react-map-gl'

export const Marker = (props: MarkerProps) => {
  return <MarkerGl {...props} />
}
</file>

<file path="libs/ui/src/components/organisms/map/Panel.tsx">
import { ReactNode } from 'react'

export type MapPanelTypes = {
  children?: ReactNode
  className?: string
  position?:
    | 'left-top'
    | 'left-center'
    | 'left-bottom'
    | 'center-bottom'
    | 'right-bottom'
    | 'right-center'
    | 'right-top'
    | 'center-top'
    | 'center-center'
}

export const Panel = ({ children, className, position }: MapPanelTypes) => {
  const classes = {
    'left-top': 'top-0 left-0 flex flex-col items-start',
    'left-center': 'top-1/2 -translate-y-1/2 left-0 flex flex-col items-start',
    'left-bottom': 'bottom-0 left-0 flex flex-col items-start',
    'center-bottom':
      'bottom-0 left-1/2 -translate-x-1/2 flex flex-col items-center text-center',
    'right-bottom': 'bottom-0 right-0 flex flex-col items-end text-right',
    'right-center':
      'top-1/2 -translate-y-1/2 right-0 flex flex-col items-end text-right',
    'right-top': 'top-0 right-0 flex flex-col items-end text-right',
    'center-top':
      'top-0 left-1/2 -translate-x-1/2 flex flex-col items-center text-center',
    'center-center':
      'top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex flex-col items-center text-center',
  }
  return (
    <div
      className={`absolute space-y-2 p-2 ${classes[position!]} ${className}`}
    >
      {children}
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/map/SearchPlacesBox.tsx">
import { LocationInfo, ViewState } from '@autospace/util/types'
import { useMap } from 'react-map-gl'
import { Autocomplete } from '../../atoms/Autocomplete'
import { useSearchLocation } from '@autospace/util/hooks/location'
import { majorCitiesLocationInfo } from '@autospace/util/constants'

export const SearchPlaceBox = ({
  onLocationChange,
}: {
  onLocationChange?: (location: ViewState) => void
}) => {
  const { current: map } = useMap()
  const { loading, locationInfo, searchText, setLoading, setSearchText } =
    useSearchLocation()

  return (
    <Autocomplete<LocationInfo>
      options={locationInfo?.length ? locationInfo : majorCitiesLocationInfo}
      isOptionEqualToValue={(option, value) =>
        option.placeName === value.placeName
      }
      noOptionsText={searchText ? 'No options.' : 'Type something...'}
      getOptionLabel={(x) => x.placeName}
      onInputChange={(_, v) => {
        setLoading(true)
        setSearchText(v)
      }}
      loading={loading}
      onChange={async (_, v) => {
        if (v) {
          const { latLng, placeName } = v
          await map?.flyTo({
            center: { lat: latLng[0], lng: latLng[1] },
            zoom: 12,
            // essential: true,
          })
          if (onLocationChange) {
            onLocationChange({ latitude: latLng[0], longitude: latLng[1] })
          }
        }
      }}
    />
  )
}
</file>

<file path="libs/ui/src/components/organisms/map/StaticMapDirections.tsx">
import { LatLng } from '@autospace/util/types'
import polyline from '@mapbox/polyline'
import Image from 'next/image'

export const StaticMapDirections = ({
  start,
  end,
  padding = [100, 100, 100],
  coordinates,
  className = 'w-full shadow-xl aspect-square',
}: {
  start: LatLng
  end: LatLng
  padding?: [number, number, number]
  coordinates: [number, number][]
  className?: string
}) => {
  if (!coordinates.length) {
    return <div className="w-full bg-gray-100 shadow-xl aspect-square" />
  }

  const encodedPolyline = polyline.fromGeoJSON({
    type: 'Feature',
    geometry: {
      type: 'LineString',
      coordinates,
    },
    properties: {},
  })

  const boundingBox = [
    Math.min(start.lng, end.lng),
    Math.min(start.lat, end.lat),
    Math.max(start.lng, end.lng),
    Math.max(start.lat, end.lat),
  ].join(',')

  const paddingString = padding.join(',')

  const url = `https://api.mapbox.com/styles/v1/iamkarthick/clk4em1h900i201pf3jvuei21/static/pin-s-a+000(${
    start.lng
  },${start.lat}),pin-s-b+000(${end.lng},${
    end.lat
  }),path-2+000(${encodeURIComponent(
    encodedPolyline,
  )})/[${boundingBox}]/600x600?padding=${paddingString}&access_token=${
    process.env.NEXT_PUBLIC_MAPBOX_TOKEN
  }`

  return (
    <Image
      width={300}
      height={300}
      src={url}
      alt="Map"
      className={` ${className}`}
    />
  )
}
</file>

<file path="libs/ui/src/components/organisms/map/StaticMapSimple.tsx">
import Image from 'next/image'

export const StaticMapSimple = ({
  position,
  padding = [100, 100, 100],
  className = 'w-full shadow-xl aspect-square',
}: {
  position: { lng: number; lat: number }
  padding?: [number, number, number]
  className?: string
}) => {
  if (!position) {
    return <div className="w-full bg-gray-100 shadow-xl aspect-square" />
  }

  const url = `https://api.mapbox.com/styles/v1/iamkarthick/clk4em1h900i201pf3jvuei21/static/pin-s(${position.lng},${position.lat})/${position.lng},${position.lat},9,0/600x600?access_token=${process.env.NEXT_PUBLIC_MAPBOX_TOKEN}`

  return (
    <Image
      src={url}
      alt="Map"
      className={` ${className}`}
      width={200}
      height={200}
    />
  )
}
</file>

<file path="libs/ui/src/components/organisms/map/ZoomControls.tsx">
import { MouseEventHandler, ReactNode } from 'react'

import { IconMinus, IconParking, IconPlus } from '@tabler/icons-react'

import { useMap } from 'react-map-gl'

export interface IZoomControlsProps {}

const MapControls = ({ children }: { children: ReactNode }) => (
  <div className="flex flex-col overflow-hidden gap-0.5 space-y rounded shadow-lg divide-primary-800 backdrop-blur-sm">
    {children}
  </div>
)

const ZoomControlButton = ({
  children,
  onClick,
}: {
  children: ReactNode
  onClick: MouseEventHandler<HTMLButtonElement>
}) => (
  <button
    className=" hover:bg-white bg-white/40"
    type="button"
    onClick={onClick}
  >
    {children}
  </button>
)

const ZoomIn = () => {
  const { current: map } = useMap()

  return (
    <ZoomControlButton onClick={() => map?.zoomIn()}>
      <IconPlus className="w-8 h-8 p-1.5 text-black" />
    </ZoomControlButton>
  )
}

const ZoomOut = () => {
  const { current: map } = useMap()
  return (
    <ZoomControlButton onClick={() => map?.zoomOut()}>
      <IconMinus className="w-8 h-8 p-1.5 text-black" />
    </ZoomControlButton>
  )
}

export const CenterOfMap = ({
  onClick,
  Icon = IconParking,
}: {
  onClick: (latLng: { lng: number; lat: number }) => void
  Icon?: typeof IconParking
}) => {
  const { current: map } = useMap()
  return (
    <ZoomControlButton
      onClick={() => {
        const { lat, lng } = map?.getCenter() as { lng: number; lat: number }
        onClick({ lat, lng })
      }}
    >
      <Icon className="w-8 h-8 p-1.5 text-black" />
    </ZoomControlButton>
  )
}

MapControls.ZoomIn = ZoomIn
MapControls.ZoomOut = ZoomOut
MapControls.CenterOfMap = CenterOfMap

export default MapControls

export const DefaultZoomControls = ({ children }: { children?: ReactNode }) => (
  <MapControls>
    <ZoomIn />
    <ZoomOut />
    {children}
  </MapControls>
)
</file>

<file path="libs/ui/src/components/organisms/search/FilterSidebar.tsx">
import {
  FormTypeSearchGarage,
  formDefaultValuesSearchGarages,
} from '@autospace/forms/src/searchGarages'
import { useState } from 'react'
import { useFormContext, Controller } from 'react-hook-form'
import { Button } from '../../atoms/Button'
import { IconFilter } from '@tabler/icons-react'
import { PulsingDot } from '../../atoms/Dot'
import { Sidebar } from '../Sidebar'
import { RangeSlider } from '../../molecules/RangeSlider'
import {
  ToggleButtonGroup,
  ToggleButton,
} from '../../molecules/ToggleButtonGroup'
import { FilterHeading } from '../../molecules/FilterHeading'
import { IconTypes } from '../../molecules/IconTypes'

export const FilterSidebar = () => {
  const [open, setOpen] = useState(false)
  const {
    control,
    reset,
    getValues,
    formState: { dirtyFields },
  } = useFormContext<FormTypeSearchGarage>()

  return (
    <>
      <Button
        size="sm"
        variant="text"
        onClick={() => setOpen(true)}
        className=" hover:bg-gray-200"
      >
        <IconFilter className="stroke-1.5 text-black" />
        {Object.values(dirtyFields).length ? <PulsingDot /> : null}
      </Button>
      <Sidebar open={open} setOpen={setOpen} blur={false}>
        <div className="flex flex-col items-start gap-3">
          <Controller
            name="types"
            control={control}
            render={({
              field: { value = [], onChange },
              fieldState: { isDirty },
              formState: { defaultValues },
            }) => {
              return (
                <div>
                  <FilterHeading dirty={isDirty} title="Vehicle type" />
                  <ToggleButtonGroup
                    value={value}
                    onChange={(_, value) => {
                      onChange(value.sort())
                    }}
                    aria-label="text formatting"
                  >
                    {defaultValues?.types?.map((val) => {
                      if (!val) return null
                      return (
                        <ToggleButton
                          key={val}
                          value={val}
                          selected={value.includes(val)}
                        >
                          {IconTypes[val]}
                        </ToggleButton>
                      )
                    })}
                  </ToggleButtonGroup>
                </div>
              )
            }}
          />
          <Controller
            name="pricePerHour"
            control={control}
            render={({
              field: { value, onChange },
              fieldState: { isDirty },
              formState: { defaultValues },
            }) => {
              return (
                <div className="w-full">
                  <FilterHeading dirty={isDirty} title="Price per hour" />
                  <RangeSlider
                    min={defaultValues?.pricePerHour?.[0]}
                    max={defaultValues?.pricePerHour?.[1]}
                    // max={200}
                    value={value}
                    onChange={onChange}
                    valueLabelFormat={(sliderValue) =>
                      `$ ${sliderValue.toLocaleString()}`
                    }
                    step={5}
                  />
                </div>
              )
            }}
          />
          <Controller
            name="width"
            control={control}
            render={({
              field: { value, onChange },
              fieldState: { isDirty },
              formState: { defaultValues },
            }) => {
              return (
                <div className="w-full">
                  <FilterHeading dirty={isDirty} title="Width" />
                  <RangeSlider
                    min={defaultValues?.width?.[0]}
                    max={defaultValues?.width?.[1]}
                    value={value}
                    onChange={onChange}
                    valueLabelFormat={(sliderValue) =>
                      `${sliderValue.toLocaleString()} ft`
                    }
                    step={2}
                  />
                </div>
              )
            }}
          />
          <Controller
            name="height"
            control={control}
            render={({
              field: { value, onChange },
              fieldState: { isDirty },
              formState: { defaultValues },
            }) => {
              return (
                <div className="w-full">
                  <FilterHeading dirty={isDirty} title="Height" />
                  <RangeSlider
                    min={defaultValues?.height?.[0]}
                    max={defaultValues?.height?.[1]}
                    value={value}
                    onChange={onChange}
                    valueLabelFormat={(sliderValue) =>
                      `${sliderValue.toLocaleString()} ft`
                    }
                    step={2}
                  />
                </div>
              )
            }}
          />
          <Controller
            name="length"
            control={control}
            render={({
              field: { value, onChange },
              fieldState: { isDirty },
              formState: { defaultValues },
            }) => {
              return (
                <div className="w-full">
                  <FilterHeading dirty={isDirty} title="Length" />
                  <RangeSlider
                    min={defaultValues?.length?.[0]}
                    max={defaultValues?.length?.[1]}
                    value={value}
                    onChange={onChange}
                    valueLabelFormat={(sliderValue) =>
                      `${sliderValue.toLocaleString()} ft`
                    }
                    step={5}
                  />
                </div>
              )
            }}
          />
          <Button
            onClick={() =>
              reset({ ...getValues(), ...formDefaultValuesSearchGarages })
            }
            disabled={!Object.values(dirtyFields).length}
          >
            Reset
          </Button>
        </div>
      </Sidebar>
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/search/GarageMarker.tsx">
import { SearchGaragesQuery } from '@autospace/network/src/gql/generated'
import { useKeypress } from '@autospace/util/hooks/keys'
import { useState } from 'react'
import { Marker } from '../map/MapMarker'
import { Dialog } from '../../atoms/Dialog'
import { ParkingIcon } from '../../atoms/ParkingIcon'
import { FormProviderBookSlot } from '@autospace/forms/src/bookSlot'
import { useWatch } from 'react-hook-form'
import { FormTypeSearchGarage } from '@autospace/forms/src/searchGarages'
import { BookSlotPopup } from '../BookSlotPopup'

export const GarageMarker = ({
  marker,
}: {
  marker: SearchGaragesQuery['searchGarages'][number]
}) => {
  const [showPopup, setShowPopup] = useState(false)
  useKeypress(['Escape'], () => setShowPopup(false))

  const { endTime, startTime } = useWatch<FormTypeSearchGarage>()

  if (!marker.address?.lat || !marker.address.lng) {
    return null
  }

  return (
    <>
      <Dialog
        title="Booking"
        widthClassName="max-w-3xl"
        open={showPopup}
        setOpen={setShowPopup}
      >
        <FormProviderBookSlot defaultValues={{ endTime, startTime }}>
          <BookSlotPopup garage={marker} />
        </FormProviderBookSlot>
      </Dialog>

      <Marker
        latitude={marker.address.lat}
        longitude={marker.address.lng}
        onClick={(e) => {
          e.originalEvent.stopPropagation()
          setShowPopup((state) => !state)
        }}
      >
        <ParkingIcon />
      </Marker>
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/search/ShowGarages.tsx">
import { useLazyQuery } from '@apollo/client'
import { SearchGaragesDocument } from '@autospace/network/src/gql/generated'
import { useEffect } from 'react'
import { GarageMarker } from './GarageMarker'
import { useConvertSearchFormToVariables } from '@autospace/forms/src/adapters/searchFormAdapter'
import { Panel } from '../map/Panel'
import { Loader } from '../../molecules/Loader'
import { IconInfoCircle } from '@tabler/icons-react'
import { toast } from '../../molecules/Toast'

export const ShowGarages = () => {
  const { variables, debouncing } = useConvertSearchFormToVariables()

  const [
    searchGarages,
    { loading: garagesLoading, data, previousData, error },
  ] = useLazyQuery(SearchGaragesDocument)

  useEffect(() => {
    if (variables) {
      searchGarages({ variables })
    }
  }, [variables])

  const garages = data?.searchGarages || previousData?.searchGarages || []
  const loading = debouncing || garagesLoading

  if (error) {
    return (
      <Panel
        position="center-center"
        className="bg-white/50 shadow border-white border backdrop-blur-sm"
      >
        <div className="flex items-center justify-center gap-2 ">
          <IconInfoCircle /> <div>{error.message}</div>
        </div>
      </Panel>
    )
  }
  if (!loading && garages.length === 0) {
    return (
      <Panel
        position="center-center"
        className="bg-white/50 shadow border-white border backdrop-blur-sm"
      >
        <div className="flex items-center justify-center gap-2 ">
          <IconInfoCircle /> <div>No parking slots found in this area.</div>
        </div>
      </Panel>
    )
  }

  return (
    <>
      {loading ? (
        <Panel position="center-bottom">
          <Loader />
        </Panel>
      ) : null}
      {garages.map((garage) => (
        <GarageMarker key={garage.id} marker={garage} />
      ))}
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/AddValet.tsx">
import { useFormCreateValet } from '@autospace/forms/src/createValet'
import { useState } from 'react'
import { Button } from '../atoms/Button'
import { Dialog } from '../atoms/Dialog'
import { Form } from '../atoms/Form'
import { ImagePreview } from './ImagePreview'
import { Controller } from 'react-hook-form'
import { HtmlInput } from '../atoms/HtmlInput'
import { HtmlLabel } from '../atoms/HtmlLabel'
import { useCloudinaryUpload } from '@autospace/util/hooks/cloudinary'
import { useMutation } from '@apollo/client'
import {
  CreateValetDocument,
  namedOperations,
} from '@autospace/network/src/gql/generated'
import { toast } from '../molecules/Toast'

export const AddValet = () => {
  const {
    register,
    resetField,
    control,
    watch,
    reset,
    handleSubmit,
    formState: { errors },
  } = useFormCreateValet()
  const [open, setOpen] = useState(false)
  const { image } = watch()

  const [createValet, { data, loading }] = useMutation(CreateValetDocument, {
    onCompleted() {
      toast('Valet created.🎉')
      reset()
      setOpen(false)
    },
    awaitRefetchQueries: true,
    refetchQueries: [namedOperations.Query.companyValets],
  })

  const { uploading, upload } = useCloudinaryUpload()

  return (
    <div>
      <Button onClick={() => setOpen(true)}>Create Valet</Button>
      <Dialog
        widthClassName="max-w-xl"
        open={open}
        setOpen={setOpen}
        title={'Create Valet'}
      >
        <Form
          onSubmit={handleSubmit(async ({ image, ...data }) => {
            const images = await upload(image)
            await createValet({
              variables: { createValetInput: { ...data, image: images[0] } },
            })
          })}
        >
          <HtmlLabel title="UID" error={errors.uid?.message}>
            <HtmlInput placeholder="uid of the valet" {...register('uid')} />
          </HtmlLabel>
          <HtmlLabel title="Display Name" error={errors.displayName?.message}>
            <HtmlInput
              placeholder="Name of the valet"
              {...register('displayName')}
            />
          </HtmlLabel>
          <HtmlLabel title="Licence ID" error={errors.licenceID?.message}>
            <HtmlInput
              placeholder="Licence ID of the valet"
              {...register('licenceID')}
            />
          </HtmlLabel>
          <ImagePreview srcs={image} clearImage={() => resetField('image')}>
            <Controller
              control={control}
              name={`image`}
              render={({ field }) => (
                <HtmlInput
                  type="file"
                  accept="image/*"
                  multiple={false}
                  onChange={(e) => field.onChange(e?.target?.files)}
                />
              )}
            />
          </ImagePreview>
          <Button loading={uploading || loading} type="submit">
            Create valet
          </Button>
        </Form>
      </Dialog>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/AssignValetButton.tsx">
import {
  AssignValetDocument,
  BookingStatus,
  namedOperations,
} from '@autospace/network/src/gql/generated'
import { ReactNode } from 'react'
import { useMutation } from '@apollo/client'
import { toast } from '../molecules/Toast'
import { Button } from '../atoms/Button'

export const AssignValetButton = ({
  bookingId,
  status,
  children,
}: {
  bookingId: number
  status: BookingStatus
  children: ReactNode
}) => {
  const [assignPickup, { data, loading }] = useMutation(AssignValetDocument, {
    awaitRefetchQueries: true,
    refetchQueries: [
      namedOperations.Query.valetDrops,
      namedOperations.Query.valetPickups,
      namedOperations.Query.myDropTrips,
      namedOperations.Query.myPickupTrips,
    ],
    onCompleted(data, clientOptions) {
      toast(`Action successful.
            ID: ${data.assignValet.id}`)
    },
  })

  return (
    <Button
      loading={loading}
      variant="outlined"
      fullWidth
      onClick={async () => {
        await assignPickup({
          variables: { bookingId, status },
        })
      }}
    >
      {children}
    </Button>
  )
}
</file>

<file path="libs/ui/src/components/organisms/AutoImageChanger.tsx">
import { useEffect, useState } from 'react'
import {
  IconPhotoCancel,
  IconChevronLeft,
  IconChevronRight,
} from '@tabler/icons-react'

export interface IAutoImageChangerProps {
  images: string[]
  durationPerImage?: number
  aspectRatio?: 'aspect-square' | 'aspect-video' | 'aspect-auto'
  noAutoChange?: boolean
}

export const AutoImageChanger = ({
  images,
  durationPerImage = 5000,
  aspectRatio = 'aspect-square',
  noAutoChange = false,
}: IAutoImageChangerProps) => {
  const [currentImageIndex, setCurrentImageIndex] = useState(0)

  useEffect(() => {
    if (noAutoChange) return

    const interval = setInterval(() => {
      setCurrentImageIndex((oldIndex) => (oldIndex + 1) % images.length)
    }, durationPerImage)

    return () => clearInterval(interval)
  }, [durationPerImage, images])

  if (images.length === 0)
    return (
      <div className="flex items-center justify-center w-full h-48 gap-2 text-sm bg-white border select-none border-gray-50 text-gray">
        <IconPhotoCancel /> No images.
      </div>
    )

  return (
    <div className={`relative w-full overflow-hidden ${aspectRatio}`}>
      <img
        src={images[currentImageIndex]}
        alt="Garage"
        className="object-cover h-full w-full"
      />
      <div className="absolute bottom-0 left-0 right-0 flex justify-center p-1 space-x-2">
        {images.map((_, index) => (
          <div
            className={`h-2 rounded-full ${
              currentImageIndex === index ? 'bg-white w-4' : 'bg-gray-300 w-2'
            }`}
            key={index}
          />
        ))}
      </div>
      {images.length > 1 && (
        <>
          <button
            type="button"
            className="absolute transform -translate-y-1/2 top-1/2 left-2"
            onClick={() =>
              setCurrentImageIndex((prevIndex) =>
                prevIndex === 0 ? images.length - 1 : prevIndex - 1,
              )
            }
          >
            <IconChevronLeft className="w-6 h-6 text-black rounded-full bg-white/40 hover:bg-white" />
          </button>
          <button
            type="button"
            className="absolute transform -translate-y-1/2 top-1/2 right-2"
            onClick={() =>
              setCurrentImageIndex(
                (prevIndex) => (prevIndex + 1) % images.length,
              )
            }
          >
            <IconChevronRight className="w-6 h-6 text-black rounded-full bg-white/40 hover:bg-white" />
          </button>
        </>
      )}
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/BookSlotPopup.tsx">
'use client'
import { FormTypeBookSlot } from '@autospace/forms/src/bookSlot'
import { loadStripe } from '@stripe/stripe-js'

import {
  CreateBookingInput,
  SearchGaragesQuery,
} from '@autospace/network/src/gql/generated'
import { useFormContext, useWatch, Controller } from 'react-hook-form'
import { Form } from '../atoms/Form'
import { Badge } from '../atoms/Badge'
import { AutoImageChanger } from './AutoImageChanger'
import { DateRangeBookingInfo } from '../molecules/DateRangeBookingInfo'
import { HtmlLabel } from '../atoms/HtmlLabel'
import { Radio, RadioGroup } from '@headlessui/react'
import { IconTypes } from '../molecules/IconTypes'
import { FormError } from '../atoms/FormError'
import { HtmlInput } from '../atoms/HtmlInput'
import { toLocalISOString } from '@autospace/util/date'
import { useTotalPrice } from '@autospace/util/hooks/price'
import { CostTitleValue } from '../molecules/CostTitleValue'
import { Button } from '../atoms/Button'
import { useState } from 'react'
import { useSession } from 'next-auth/react'
import { TotalPrice } from '@autospace/util/types'
import { ManageValets } from './ManageValets'
import { toast } from '../molecules/Toast'

export const BookSlotPopup = ({
  garage,
}: {
  garage: SearchGaragesQuery['searchGarages'][0]
}) => {
  const session = useSession()
  const uid = session.data?.user?.uid
  const {
    control,
    register,
    handleSubmit,
    setValue,
    formState: { errors },
  } = useFormContext<FormTypeBookSlot>()

  const { startTime, endTime, phoneNumber, type, valet, vehicleNumber } =
    useWatch<FormTypeBookSlot>()

  const pricePerHour = garage.availableSlots.find(
    (slot) => slot.type === type,
  )?.pricePerHour

  const totalPriceObj = useTotalPrice({
    pricePerHour,
  })

  const totalPrice =
    totalPriceObj.parkingCharge +
    totalPriceObj.valetChargeDropoff +
    totalPriceObj.valetChargePickup

  const [booking, setBooking] = useState(false)

  return (
    <div className="flex gap-2 text-left border-t-2 border-white bg-white/50 backdrop-blur-sm">
      <Form
        onSubmit={handleSubmit(async (data) => {
          if (!uid) {
            alert('You are not logged in.')
            return
          }
          const bookingData: CreateBookingInput = {
            phoneNumber: data.phoneNumber,
            customerId: uid,
            endTime: data.endTime,
            startTime: data.startTime,
            type: data.type,
            garageId: garage.id,
            vehicleNumber: data.vehicleNumber,
            totalPrice,
            pricePerHour,
            ...(data.valet?.pickupInfo && data.valet?.dropoffInfo
              ? {
                  valetAssignment: {
                    pickupLat: data.valet?.pickupInfo?.lat,
                    pickupLng: data.valet?.pickupInfo?.lng,
                    returnLat: data.valet?.dropoffInfo?.lat,
                    returnLng: data.valet?.dropoffInfo?.lng,
                  },
                }
              : null),
          }

          try {
            setBooking(true)
            // Create booking session
            const res = await createBookingSession(
              uid!,
              totalPriceObj,
              bookingData,
            )
          } catch (error) {
            toast('An error occurred while creating the booking session.')
          } finally {
            setBooking(false)
          }
        })}
      >
        <div className="flex items-start gap-2">
          <div className="mb-2 text-lg font-bold">{garage.displayName}</div>
          {garage.verification?.verified ? (
            <Badge variant="green" size="sm">
              Verified
            </Badge>
          ) : (
            <Badge variant="gray" size="sm">
              Not verified
            </Badge>
          )}
        </div>
        <div className="mb-2 text-xl font-extralight">
          {garage.address?.address}
        </div>
        <AutoImageChanger
          images={garage.images || []}
          durationPerImage={10000}
          aspectRatio="aspect-video"
          noAutoChange
        />
        <DateRangeBookingInfo startTime={startTime} endTime={endTime} />

        <div className="flex flex-wrap gap-2 mt-2">
          <HtmlLabel title="Slot type" error={errors.type?.message}>
            <Controller
              name="type"
              control={control}
              render={({ field: { onChange, value } }) => {
                return (
                  <RadioGroup
                    value={value || ''}
                    onChange={onChange}
                    className="flex w-full gap-2"
                    defaultValue={''}
                  >
                    {garage.availableSlots.map((slot) => (
                      <div
                        key={slot.type}
                        className="flex flex-wrap items-center gap-2 bg-white"
                      >
                        <Radio key={slot.type} value={slot.type}>
                          {({ checked }) => (
                            <div
                              className={`cursor-default border-2 p-2 ${
                                checked
                                  ? 'border-primary-500 shadow-md'
                                  : 'border-gray-200'
                              }`}
                            >
                              <div className="flex items-center gap-2">
                                {slot.type ? IconTypes[slot.type] : null}
                                <div>
                                  <span className="text-lg font-bold">
                                    ${slot.pricePerHour}
                                  </span>
                                  /hr
                                </div>
                              </div>

                              <div className="text-gray-600">
                                {slot.count} open
                              </div>
                            </div>
                          )}
                        </Radio>
                      </div>
                    ))}
                  </RadioGroup>
                )
              }}
            />
          </HtmlLabel>
        </div>
        {!type ? <FormError error="Set type" /> : null}

        <HtmlLabel title="Start time" error={errors.startTime?.message}>
          <HtmlInput
            type="datetime-local"
            min={toLocalISOString(new Date()).slice(0, 16)}
            {...register('startTime')}
          />
        </HtmlLabel>
        <HtmlLabel title="End time" error={errors.endTime?.message}>
          <HtmlInput
            min={toLocalISOString(new Date()).slice(0, 16)}
            type="datetime-local"
            {...register('endTime')}
          />
        </HtmlLabel>

        <HtmlLabel title="Vehicle number" error={errors.vehicleNumber?.message}>
          <HtmlInput placeholder="KA01AB1234" {...register('vehicleNumber')} />
        </HtmlLabel>
        <HtmlLabel title="Phone number" error={errors.phoneNumber?.message}>
          <HtmlInput placeholder="+910000000000" {...register('phoneNumber')} />
        </HtmlLabel>
        <ManageValets garage={garage} />

        {totalPriceObj ? (
          <div className="mt-4">
            <CostTitleValue
              title="Parking"
              price={totalPriceObj.parkingCharge}
            />
            <CostTitleValue
              title="Valet Pickup"
              price={totalPriceObj.valetChargePickup}
            />
            <CostTitleValue
              title="Valet Dropoff"
              price={totalPriceObj.valetChargeDropoff}
            />

            <CostTitleValue title="Total" price={totalPrice} />
          </div>
        ) : null}

        <Button loading={booking} type="submit" className="w-full mt-2">
          Book now
        </Button>
      </Form>
    </div>
  )
}

export const createBookingSession = async (
  uid: string,
  totalPriceObj: TotalPrice,
  bookingData: CreateBookingInput,
) => {
  try {
    const response = await fetch(process.env.NEXT_PUBLIC_API_URL + '/stripe', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        totalPriceObj,
        uid,
        bookingData,
      }),
    })
    const checkoutSession = await response.json()

    const publishableKey = process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY

    const stripe = await loadStripe(publishableKey || '')
    const result = await stripe?.redirectToCheckout({
      sessionId: checkoutSession.sessionId,
    })

    return result
  } catch (error) {
    console.error('Error creating booking session:', error)
    throw error
  }
}
</file>

<file path="libs/ui/src/components/organisms/CheckInOutButtons.tsx">
import {
  BookingStatus,
  CreateBookingTimelineDocument,
  namedOperations,
} from '@autospace/network/src/gql/generated'
import { useMutation } from '@apollo/client'
import { Button } from '../atoms/Button'

export const CheckInOutButton = ({
  bookingId,
  buttonText,
  status,
}: {
  bookingId: number
  status: BookingStatus
  buttonText: string
}) => {
  const [checkIn, { data, loading }] = useMutation(
    CreateBookingTimelineDocument,
  )
  return (
    <Button
      loading={loading}
      onClick={() => {
        checkIn({
          variables: {
            createBookingTimelineInput: {
              bookingId,
              status,
            },
          },
          awaitRefetchQueries: true,
          refetchQueries: [namedOperations.Query.BookingsForGarage],
        })
      }}
      color="white"
      className="mt-1"
      fullWidth
    >
      {buttonText}
    </Button>
  )
}
</file>

<file path="libs/ui/src/components/organisms/CreateCompany.tsx">
'use client'
import { useFormCreateCompany } from '@autospace/forms/src/createCompany'
import { Button } from '../atoms/Button'
import { Dialog } from '../atoms/Dialog'
import { useEffect, useState } from 'react'
import { HtmlLabel } from '../atoms/HtmlLabel'
import { HtmlInput } from '../atoms/HtmlInput'
import { Form } from '../atoms/Form'
import { HtmlTextArea } from '../atoms/HtmlTextArea'
import { useSession } from 'next-auth/react'
import { useMutation } from '@apollo/client'
import {
  CreateCompanyDocument,
  namedOperations,
} from '@autospace/network/src/gql/generated'

export const CreateCompany = () => {
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
  } = useFormCreateCompany()

  const session = useSession()
  const uid = session.data?.user?.uid
  const managerName = session.data?.user?.name

  const [createCompany, { loading, data }] = useMutation(CreateCompanyDocument)

  useEffect(() => {
    if (uid) {
      setValue('managerId', uid)
    }
    setValue('managerName', managerName)
  }, [uid])

  const [open, setOpen] = useState(false)

  return (
    <div>
      <Button onClick={() => setOpen(true)}>Create Company</Button>
      <Dialog open={open} setOpen={setOpen} title="Create company">
        <Form
          onSubmit={handleSubmit(async (data) => {
            await createCompany({
              variables: {
                createCompanyInput: data,
              },
              awaitRefetchQueries: true,
              refetchQueries: [namedOperations.Query.myCompany],
            })
          })}
        >
          <HtmlLabel title="Company name" error={errors.displayName?.message}>
            <HtmlInput
              placeholder="Company name"
              {...register('displayName')}
            />
          </HtmlLabel>
          <HtmlLabel title="Description" error={errors.displayName?.message}>
            <HtmlTextArea
              placeholder="Describe your parking company"
              {...register('description')}
            />
          </HtmlLabel>
          <HtmlLabel title="Manager ID" error={errors.managerId?.message}>
            <HtmlInput
              placeholder="Manager ID"
              {...register('managerId')}
              readOnly
            />
          </HtmlLabel>
          <HtmlLabel title="Manager name" error={errors.managerName?.message}>
            <HtmlInput
              placeholder="Manager name"
              {...register('managerName')}
            />
          </HtmlLabel>
          <Button loading={loading} type="submit">
            Submit
          </Button>
        </Form>
      </Dialog>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/CreateGarageComponents.tsx">
import { FormTypeCreateGarage } from '@autospace/forms/src/createGarage'
import { ViewState } from '@autospace/util/types'
import { useEffect } from 'react'
import { useWatch, useFormContext, useFieldArray } from 'react-hook-form'
import { Marker } from '../organisms/map/MapMarker'
import { ParkingIcon } from '../atoms/ParkingIcon'
import { initialViewState } from '@autospace/util/constants'
import { dividerClasses } from '@mui/material'
import { Accordion } from '../atoms/Accordion'
import { Button } from '../atoms/Button'
import { IconPlus } from '@tabler/icons-react'
import { SlotType } from '@autospace/network/src/gql/generated'
import { HtmlLabel } from '../atoms/HtmlLabel'
import { HtmlSelect } from '../atoms/HtmlSelect'
import { HtmlInput } from '../atoms/HtmlInput'

export const GarageMapMarker = () => {
  const { location } = useWatch<FormTypeCreateGarage>()
  const { setValue } = useFormContext<FormTypeCreateGarage>()

  return (
    <Marker
      pitchAlignment="auto"
      longitude={location?.lng || 0}
      latitude={location?.lat || 0}
      draggable
      onDragEnd={({ lngLat }) => {
        const { lat, lng } = lngLat
        setValue('location.lat', lat || 0)
        setValue('location.lng', lng || 0)
      }}
    >
      <ParkingIcon />
    </Marker>
  )
}

export const AddSlots = () => {
  const {
    control,
    register,
    formState: { errors },
  } = useFormContext<FormTypeCreateGarage>()

  const { fields, append, remove } = useFieldArray({
    control,
    name: `slotTypes`,
  })

  const { slotTypes } = useWatch<FormTypeCreateGarage>()
  return (
    <div>
      {fields.map((item, slotIndex) => (
        <Accordion
          defaultOpen
          key={item.id}
          title={
            <div>
              <div>
                {' '}
                {slotTypes?.[slotIndex]?.type} x {slotTypes?.[slotIndex]?.count}
              </div>
            </div>
          }
        >
          <div className={`flex justify-end my-2`}>
            <Button
              variant="text"
              size="none"
              className="text-xs text-gray-600 underline underline-offset-2"
              onClick={() => {
                remove(slotIndex)
              }}
            >
              remove slot type
            </Button>
          </div>
          <div className="grid grid-cols-3 gap-2">
            <HtmlLabel
              title="Vehicle type"
              error={errors.slotTypes?.[slotIndex]?.type?.toString()}
            >
              <HtmlSelect
                placeholder="vehicle type"
                {...register(`slotTypes.${slotIndex}.type`)}
              >
                {Object.values(SlotType).map((type) => (
                  <option key={type} value={type}>
                    {type}
                  </option>
                ))}
              </HtmlSelect>
            </HtmlLabel>
            <HtmlLabel
              title="Price/hr"
              optional
              error={errors.slotTypes?.[slotIndex]?.pricePerHour?.message}
            >
              <HtmlInput
                type="number"
                placeholder="Price per hour"
                {...register(`slotTypes.${slotIndex}.pricePerHour`, {
                  valueAsNumber: true,
                })}
              />
            </HtmlLabel>

            <HtmlLabel
              title="Number of slots"
              optional
              error={errors.slotTypes?.[slotIndex]?.count?.message}
            >
              <HtmlInput
                type="number"
                placeholder="Enter the number of slots"
                {...register(`slotTypes.${slotIndex}.count`, {
                  valueAsNumber: true,
                })}
              />
            </HtmlLabel>

            <HtmlLabel
              title="Length"
              optional
              error={errors.slotTypes?.[slotIndex]?.length?.message}
            >
              <HtmlInput
                type="number"
                placeholder="Enter the description"
                {...register(`slotTypes.${slotIndex}.length`, {
                  valueAsNumber: true,
                })}
              />
            </HtmlLabel>
            <HtmlLabel
              title="Width"
              optional
              error={errors.slotTypes?.[slotIndex]?.width?.message}
            >
              <HtmlInput
                type="number"
                placeholder="Enter the description"
                {...register(`slotTypes.${slotIndex}.width`, {
                  valueAsNumber: true,
                })}
              />
            </HtmlLabel>
            <HtmlLabel
              title="Height"
              optional
              error={errors.slotTypes?.[slotIndex]?.height?.message}
            >
              <HtmlInput
                type="number"
                placeholder="Enter the description"
                {...register(`slotTypes.${slotIndex}.height`, {
                  valueAsNumber: true,
                })}
              />
            </HtmlLabel>
          </div>
        </Accordion>
      ))}
      <Button
        className="flex items-center justify-center w-full py-2 text-xs border border-dashed"
        variant="text"
        size="none"
        onClick={() => {
          append({
            length: 10,
            width: 10,
            height: 10,
            pricePerHour: 20,
            count: 5,
            type: SlotType.Car,
          })
        }}
      >
        <IconPlus className="w-4 h-4" /> Add slots
      </Button>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/CreateManySlotsDialog.tsx">
import { useFormCreateManySlots } from '@autospace/forms/src/createSlots'
import { useMutation } from '@apollo/client'
import {
  CreateManySlotsDocument,
  SlotType,
  namedOperations,
} from '@autospace/network/src/gql/generated'
import { useState } from 'react'
import { Button } from '../atoms/Button'
import { Dialog } from '../atoms/Dialog'
import { HtmlLabel } from '../atoms/HtmlLabel'
import { HtmlSelect } from '../atoms/HtmlSelect'
import { HtmlInput } from '../atoms/HtmlInput'
import { Form } from '../atoms/Form'
import { toast } from '../molecules/Toast'

export const CreateManySlotsDialog = ({ garageId }: { garageId: number }) => {
  const [open, setOpen] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useFormCreateManySlots()

  const [createManySlots, { loading, data, error }] = useMutation(
    CreateManySlotsDocument,
    {
      awaitRefetchQueries: true,
      refetchQueries: [namedOperations.Query.Garages],
      onCompleted(data, clientOptions) {
        setOpen(false)
        toast('Slots created successfully.')
      },
      onError(error, clientOptions) {
        toast('Action failed.')
      },
    },
  )

  return (
    <>
      <Button
        variant="text"
        size="none"
        onClick={() => setOpen(true)}
        className="w-16 h-10 border-2 group border-primary"
      >
        <div className="transition-transform duration-300 group-hover:scale-150">
          +
        </div>
      </Button>
      <Dialog open={open} setOpen={setOpen} title={'Create slots'}>
        <Form
          onSubmit={handleSubmit(async ({ count, ...data }) => {
            await createManySlots({
              variables: { count, createSlotInput: { ...data, garageId } },
            })
          })}
        >
          <div className="grid grid-cols-2 gap-2">
            <HtmlLabel title="Slot type" error={errors.type?.toString()}>
              <HtmlSelect placeholder="Slot type" {...register(`type`)}>
                {Object.values(SlotType).map((type) => (
                  <option key={type} value={type}>
                    {type}
                  </option>
                ))}
              </HtmlSelect>
            </HtmlLabel>
            <HtmlLabel title="Price/hr" error={errors.pricePerHour?.message}>
              <HtmlInput
                type="number"
                placeholder="Price per hour"
                {...register(`pricePerHour`, {
                  valueAsNumber: true,
                })}
              />
            </HtmlLabel>
            <HtmlLabel title="Number of slots" error={errors.count?.message}>
              <HtmlInput
                type="number"
                placeholder="Enter the number of slots"
                {...register(`count`, {
                  valueAsNumber: true,
                })}
              />
            </HtmlLabel>
            <HtmlLabel title="Length" error={errors.length?.message}>
              <HtmlInput
                type="number"
                placeholder="Enter the length in ft"
                {...register('length', {
                  valueAsNumber: true,
                })}
              />
            </HtmlLabel>
            <HtmlLabel title="Width" error={errors.width?.message}>
              <HtmlInput
                type="number"
                placeholder="Enter the width in ft"
                {...register(`width`, {
                  valueAsNumber: true,
                })}
              />
            </HtmlLabel>
            <HtmlLabel title="Height" error={errors.height?.message}>
              <HtmlInput
                type="number"
                placeholder="Enter the height in ft"
                {...register(`height`, {
                  valueAsNumber: true,
                })}
              />
            </HtmlLabel>
            <Button type="submit" loading={loading}>
              Submit
            </Button>
          </div>
        </Form>
      </Dialog>
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/CustomerBookingCard.tsx">
import { BookingsForCustomerQuery } from '@autospace/network/src/gql/generated'
import { StartEndDateCard } from './DateCard'
import { MapLink } from '../molecules/MapLink'
import { StaticMapSimple } from './map/StaticMapSimple'
import { TitleStrongValue, TitleValue } from '../atoms/TitleValue'
import { Reveal } from '../molecules/Reveal'
import { Accordion } from '../atoms/Accordion'
import { format } from 'date-fns'

export interface IBookingCardProps {
  booking: NonNullable<BookingsForCustomerQuery['bookingsForCustomer']>[number]
}

export const CustomerBookingCard = ({ booking }: IBookingCardProps) => {
  const lat = booking.slot.garage.address?.lat || 0
  const lng = booking.slot.garage.address?.lng || 0

  return (
    <div className="shadow-lg bg-white p-2">
      <div className="flex flex-col gap-2">
        <StartEndDateCard
          startTime={booking.startTime}
          endTime={booking.endTime}
        />
        <MapLink waypoints={[{ lat, lng }]}>
          <StaticMapSimple
            position={{
              lat,
              lng,
            }}
            className="h-full w-full"
          />
        </MapLink>
      </div>
      <div className="grid grid-cols-2 w-full gap-2 mt-2  ">
        <TitleStrongValue title={'Slot'}>
          {booking.slot.displayName}
        </TitleStrongValue>
        <TitleStrongValue title={'Vehicle number'}>
          {booking.vehicleNumber}
        </TitleStrongValue>

        <TitleStrongValue title={'Address'}>
          <div>
            {booking.slot.garage.address?.address}
            <div className="text-gray text-xs">
              {lat.toFixed(2)} {lng.toFixed(2)}
            </div>
          </div>
        </TitleStrongValue>
        <TitleStrongValue title={'Code'}>
          <Reveal secret={booking.passcode || ''} />
        </TitleStrongValue>
      </div>
      <Accordion
        defaultOpen={false}
        title={
          <TitleStrongValue title={'Status'}>
            <div className="font-bold">
              {booking.status.split('_').join(' ')}
            </div>
          </TitleStrongValue>
        }
      >
        <div className="flex flex-col gap-2">
          {booking.bookingTimeline.map((timeline) => (
            <div key={timeline.timestamp}>
              <TitleValue title={timeline.status}>
                {format(new Date(timeline.timestamp), 'PPp')}
              </TitleValue>
            </div>
          ))}
        </div>
      </Accordion>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/DateCard.tsx">
import { differenceInTime, getTimeUnits } from '@autospace/util/date'
import { IconArrowRightRhombus } from '@tabler/icons-react'
import { format } from 'date-fns'

export interface IDateCardProps {
  startTime: string
  endTime: string
}

export const StartEndDateCard = ({ startTime, endTime }: IDateCardProps) => {
  const numOfHours = getTimeUnits(
    differenceInTime({ startTime, endTime, unit: 'seconds' }),
  ).timeString
  return (
    <div className="flex items-center justify-between gap-2 p-2">
      <DateCard dateTime={startTime} />
      <div className="flex flex-col items-center">
        <IconArrowRightRhombus />
        <div className="text-xs">{numOfHours}</div>
      </div>
      <DateCard dateTime={endTime} justify="right" />
    </div>
  )
}

export const DateCard = ({
  dateTime,
  justify = 'left',
}: {
  dateTime: string
  justify?: 'left' | 'right'
}) => {
  const [date, time] = [
    format(new Date(dateTime), 'dd MMMM yyyy'),
    format(new Date(dateTime), 'HH:mm'),
  ]

  return (
    <div
      className={`flex flex-col  ${
        justify === 'left' ? 'items-start' : 'items-end'
      }`}
    >
      <div className="text-xl">{time}</div>
      <div className="text-xs text-gray-500">{date}</div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/Directions.tsx">
import { useDebounce } from '@autospace/util/hooks/async'
import { LatLng, LngLatTuple } from '@autospace/util/types'
import { useEffect, useMemo, useRef, useState } from 'react'
import { Source, Layer } from 'react-map-gl'

export const Directions = ({
  origin,
  destination,
  setDistance,
  sourceId,
}: {
  origin?: LatLng
  destination?: Partial<LatLng>
  setDistance?: (distance?: number) => void
  sourceId: string
}) => {
  const [coordinates, setCoordinates] = useState<LngLatTuple[]>([])
  const prevDistanceRef = useRef<number | undefined>(undefined)
  const prevOriginRef = useRef<LatLng | undefined>(undefined)
  const prevDestinationRef = useRef<Partial<LatLng> | undefined>(undefined)

  const [originDebounced] = useDebounce(origin, 400)
  const [destinationDebounced] = useDebounce(destination, 400)

  useEffect(() => {
    if (
      !originDebounced ||
      !destinationDebounced ||
      (prevOriginRef.current &&
        prevOriginRef.current.lat === originDebounced.lat &&
        prevOriginRef.current.lng === originDebounced.lng &&
        prevDestinationRef.current &&
        prevDestinationRef.current.lat === destinationDebounced.lat &&
        prevDestinationRef.current.lng === destinationDebounced.lng)
    ) {
      return
    }

    prevOriginRef.current = originDebounced
    prevDestinationRef.current = destinationDebounced
    ;(async () => {
      const response = await fetch(
        `https://api.mapbox.com/directions/v5/mapbox/driving/${originDebounced.lng},${originDebounced.lat};${destinationDebounced.lng},${destinationDebounced.lat}?access_token=${process.env.NEXT_PUBLIC_MAPBOX_TOKEN}&steps=true&overview=simplified`,
      )

      const data = await response.json()

      const coordinates =
        data?.routes[0]?.legs[0]?.steps?.map(
          (step: { maneuver: { location: any } }) => step.maneuver.location,
        ) || []

      const newDistance = data.routes[0].distance || 0

      setCoordinates(coordinates)

      if (newDistance !== prevDistanceRef.current && setDistance) {
        setDistance(newDistance)
        prevDistanceRef.current = newDistance
      }
    })()
  }, [originDebounced, destinationDebounced, setDistance])

  const dataOne = useMemo(
    () => ({
      type: 'Feature' as const,
      properties: {},
      geometry: {
        type: 'LineString' as const,
        coordinates,
      },
    }),
    [coordinates],
  )

  return (
    <Source id={sourceId} type="geojson" data={dataOne}>
      <Layer
        id={sourceId}
        type="line"
        source="my-data"
        paint={{
          'line-color': 'rgb(0,0,0)',
          'line-width': 2,
        }}
      />
    </Source>
  )
}
</file>

<file path="libs/ui/src/components/organisms/GarageAdminCard.tsx">
import { GaragesQuery } from '@autospace/network/src/gql/generated'
import { ReactNode } from 'react'
import { MapLink } from '../molecules/MapLink'
import { IconTypes } from '../molecules/IconTypes'

export const GarageAdminCard = ({
  children,
  garage,
}: {
  children: ReactNode
  garage: GaragesQuery['garages'][0]
}) => {
  return (
    <div className="p-2 bg-white flex flex-col gap-2">
      <p className="text-xs ">#{garage.id}</p>
      <div className="flex items-start gap-2">
        <h2 className="mb-1 font-semibold">{garage.displayName}</h2>
        <div>
          {garage.verification?.verified ? (
            <span className="px-1 py-0.5 shadow text-xs bg-green-50 ">
              Verified
            </span>
          ) : (
            <span className="px-1 py-0.5 shadow text-xs bg-red-50 ">
              Not Verified
            </span>
          )}
        </div>
      </div>
      <div className="flex items-center gap-2">
        {garage.address ? (
          <MapLink
            waypoints={[garage.address]}
            className="hover:underline underline-offset-4"
          >
            <p className="text-xs text-gray-700 ">{garage.address?.address}</p>
          </MapLink>
        ) : null}
      </div>
      <div className="mt-2 mb-4 flex gap-3 ">
        {garage.slotCounts.length === 0 ? (
          <div className="text-sm ">No slots.</div>
        ) : null}
        {garage.slotCounts.map((slot, index) => (
          <div key={index} className="py-2 flex gap-1 ">
            {IconTypes[slot.type]}
            <span className="text-gray-500">{slot.count}</span>
          </div>
        ))}
      </div>

      <div className="mt-auto">{children}</div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/GarageCard.tsx">
import { GaragesQuery } from '@autospace/network/src/gql/generated'
import { AutoImageChanger } from './AutoImageChanger'
import Link from 'next/link'
import { IconTypes } from '../molecules/IconTypes'
import { CreateManySlotsDialog } from './CreateManySlotsDialog'

export interface IGarageCardProps {
  garage: GaragesQuery['garages'][number]
}

export const GarageCard = ({ garage }: IGarageCardProps) => {
  return (
    <div className="overflow-hidden bg-white shadow-lg flex flex-col">
      <AutoImageChanger images={garage.images || []} durationPerImage={5000} />

      <div className="p-2 flex-grow flex flex-col gap-4">
        <div>
          <div className="flex justify-between ">
            <h3 className="font-semibold ">{garage.displayName}</h3>
            <Link
              className="text-sm underline underline-offset-4"
              href={{ pathname: 'bookings', query: { garageId: garage.id } }}
            >
              Bookings
            </Link>
          </div>
          <p className="text-gray-500 text-sm my-2 line-clamp-2 ">
            {garage.description}
          </p>
          <p className="text-sm text-gray-400">
            Address: {garage.address?.address}
          </p>
        </div>
        <div className="flex gap-2 mt-auto">
          <>
            {garage.slotCounts.map((slotType) => (
              <div
                key={slotType.type}
                className="flex items-center justify-center w-16 h-10 gap-1 border-2 border-primary"
              >
                <div>{IconTypes[slotType.type]}</div>
                <div className="text-sm">{slotType.count}</div>
              </div>
            ))}
            <CreateManySlotsDialog garageId={garage.id} />
          </>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/Header.tsx">
'use client'
import { BaseComponent, MenuItem, Role } from '@autospace/util/types'
import { Brand } from '../atoms/Brand'
import { Container } from '../atoms/Container'
import { useSession } from 'next-auth/react'
import Link from 'next/link'
import { Sidebar } from './Sidebar'
import { UserInfo } from '../molecules/UserInfo'
import { LogoutButton } from '../molecules/LogoutButton'
import { Button } from '../atoms/Button'
import { useDialogState } from '@autospace/util/hooks/dialog'
import { NavSidebar } from './NavSidebar'
import { Menus } from './Menus'

export type IHeaderProps = {
  type?: Role
  menuItems: MenuItem[]
} & BaseComponent

export const Header = ({ type, menuItems }: IHeaderProps) => {
  const session = useSession()
  const uid = session?.data?.user?.uid
  let [open, setOpen] = useDialogState(false)

  return (
    <header>
      <nav className="fixed z-40 top-0 w-full shadow-md bg-white/50 backdrop-blur-md">
        <Container className="relative   flex items-center justify-between h-16 py-2 gap-16">
          <Link href="/" aria-label="Home" className="w-auto z-50">
            <Brand type={type} className="hidden h-10 sm:block" />
            <Brand type={type} shortForm className="block sm:hidden" />
          </Link>
          <div className="flex items-center gap-2">
            {uid ? (
              <div className="flex gap-6 items-center">
                <div className="text-sm mr-6 flex gap-3">
                  <Menus menuItems={menuItems} />
                </div>

                <NavSidebar menuItems={menuItems} />
              </div>
            ) : (
              <>
                <Link href="/register">
                  <Button variant="outlined" className="hidden md:block">
                    Register
                  </Button>
                </Link>
                <Link href="/login">
                  <Button>Log in</Button>
                </Link>
              </>
            )}
          </div>
        </Container>
      </nav>
      <div className="h-16" />
    </header>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ImagePreview.tsx">
import { BaseComponent } from '@autospace/util/types'
import { IconTrash } from '@tabler/icons-react'
import Image from 'next/image'

export interface IImageUploadProps extends BaseComponent {
  srcs?: FileList
  clearImage: () => void
}

export const ImagePreview = ({
  srcs,
  clearImage,
  children,
}: IImageUploadProps) => {
  if (srcs && srcs?.length > 0) {
    return (
      <div className="grid grid-cols-2 gap-2 relative">
        <button
          onClick={() => clearImage()}
          className="absolute z-10 p-2 text-white bg-red/80 flex gap-2 items-center rounded left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2"
        >
          <IconTrash /> Clear all
        </button>
        {Array.from(srcs)?.map((src, index) => (
          <Image
            key={index}
            className="object-cover h-full w-full aspect-square"
            alt=""
            width={300}
            height={300}
            src={URL.createObjectURL(src)}
          />
        ))}
      </div>
    )
  }

  return (
    <div className="flex items-center justify-center w-full h-full min-h-36">
      {children}
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/IsAdmin.tsx">
'use client'
import { AdminMeDocument } from '@autospace/network/src/gql/generated'
import { useQuery } from '@apollo/client'
import { LoaderPanel } from '../molecules/Loader'
import { AlertSection } from '../molecules/AlertSection'
import { ReactNode } from 'react'
import { useSession } from 'next-auth/react'

export const IsAdmin = ({ children }: { children: ReactNode }) => {
  const { data, loading } = useQuery(AdminMeDocument)

  if (loading) {
    return <LoaderPanel text="Loading company..." />
  }

  if (!data?.adminMe?.uid)
    return (
      <AlertSection>
        <div>You are not an admin.</div>
      </AlertSection>
    )

  return <>{children}</>
}
</file>

<file path="libs/ui/src/components/organisms/IsLoggedIn.tsx">
'use client'
import { ReactNode } from 'react'
import { useSession } from 'next-auth/react'
import { LoaderPanel } from '../molecules/Loader'
import { AlertSection } from '../molecules/AlertSection'
import Link from 'next/link'

type RenderPropChild = (uid: string) => ReactNode

export const IsLoggedIn = ({
  children,
  notLoggedIn,
}: {
  children: RenderPropChild | ReactNode
  notLoggedIn?: ReactNode
}) => {
  const { status, data } = useSession()

  if (status === 'loading') {
    return <LoaderPanel text="Loading user..." />
  }

  if (!data?.user?.uid) {
    if (notLoggedIn) {
      return <>{notLoggedIn}</>
    } else {
      return (
        <AlertSection title="You are not logged in.">
          <Link href="/login">Login</Link>
        </AlertSection>
      )
    }
  }

  return (
    <>
      {typeof children === 'function'
        ? (children as RenderPropChild)(data.user.uid)
        : children}
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/IsManager.tsx">
'use client'
import { MyCompanyDocument } from '@autospace/network/src/gql/generated'
import { BaseComponent } from '@autospace/util/types'
import { useQuery } from '@apollo/client'
import { LoaderPanel } from '../molecules/Loader'
import { AlertSection } from '../molecules/AlertSection'
import { CreateCompany } from './CreateCompany'
import { ReactNode } from 'react'

type RenderPropChild = (id: number) => ReactNode

export const IsManager = ({
  children,
}: {
  children: RenderPropChild | ReactNode
}) => {
  const { data, loading } = useQuery(MyCompanyDocument)

  if (loading) {
    return <LoaderPanel text="Loading company..." />
  }

  if (!data?.myCompany)
    return (
      <AlertSection>
        <div>You don&apos;t have a company yet.</div>
        <CreateCompany />
      </AlertSection>
    )

  return (
    <>
      {typeof children === 'function'
        ? (children as RenderPropChild)(data.myCompany.id)
        : children}
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/IsValet.tsx">
'use client'
import { ValetMeDocument } from '@autospace/network/src/gql/generated'
import { useQuery } from '@apollo/client'
import { LoaderPanel } from '../molecules/Loader'
import { AlertSection } from '../molecules/AlertSection'
import { ReactNode } from 'react'
import { useSession } from 'next-auth/react'
type RenderPropChild = (id: number) => ReactNode

export const IsValet = ({
  children,
  uid,
}: {
  children: RenderPropChild | ReactNode
  uid: string
}) => {
  const { data, loading } = useQuery(ValetMeDocument)

  if (loading) {
    return <LoaderPanel text="Loading company..." />
  }

  if (!data?.valetMe?.companyId)
    return (
      <AlertSection>
        <div>You are not a valet.</div>
        <div>Please contact the company&apos;s managers with your ID. </div>
        <div>{uid}</div>
      </AlertSection>
    )

  return (
    <>
      {typeof children === 'function'
        ? (children as RenderPropChild)(data.valetMe.companyId)
        : children}
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ListGarages.tsx">
import {
  GaragesDocument,
  MyCompanyQuery,
} from '@autospace/network/src/gql/generated'
import { useTakeSkip } from '@autospace/util/hooks/pagination'
import { useQuery } from '@apollo/client'
import {} from '@autospace/network/src/gql/generated'
import { ShowData } from './ShowData'
import { dividerClasses } from '@mui/material'
import { IconPlus } from '@tabler/icons-react'
import Link from 'next/link'
import { GarageCard } from './GarageCard'

export const ListGarages = ({
  companyId,
}: {
  companyId: MyCompanyQuery['myCompany']['id']
}) => {
  const { setSkip, setTake, skip, take } = useTakeSkip()
  const { data, loading, error } = useQuery(GaragesDocument, {
    variables: {
      skip,
      take,
      where: { companyId: { equals: companyId } },
    },
  })
  return (
    <ShowData
      error={error?.message}
      loading={loading}
      pagination={{
        skip,
        take,
        resultCount: data?.garages.length,
        totalCount: data?.garagesCount.count,
        setSkip,
        setTake,
      }}
      childrenClassName="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-6 gap-3"
      title={
        <div className="flex items-center gap-4">
          <div>Garages</div>
          <Link
            href="/new-garage"
            className="rounded-full border border-black p-0.5"
          >
            <IconPlus />
          </Link>
        </div>
      }
    >
      {data?.garages.map((garage) => (
        <GarageCard key={garage.id} garage={garage} />
      ))}
    </ShowData>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ListValets.tsx">
import { useTakeSkip } from '@autospace/util/hooks/pagination'
import { useQuery } from '@apollo/client'
import { CompanyValetsDocument } from '@autospace/network/src/gql/generated'
import { ShowData } from './ShowData'
import { ValetCard } from './ValetCard'

export const ListValets = () => {
  const { take, skip, setSkip, setTake } = useTakeSkip()
  const { data, loading } = useQuery(CompanyValetsDocument)

  return (
    <ShowData
      loading={loading}
      pagination={{
        resultCount: data?.companyValets.length,
        totalCount: data?.companyValetsTotal,
        take,
        skip,
        setSkip,
        setTake,
      }}
    >
      {data?.companyValets.map((valet) => (
        <ValetCard key={valet.uid} valet={valet} />
      ))}
    </ShowData>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ManageBookingCard.tsx">
import { BookingsForGarageQuery } from '@autospace/network/src/gql/generated'
import { TitleStrongValue, TitleValue } from '../atoms/TitleValue'
import { Reveal } from '../molecules/Reveal'
import { StartEndDateCard } from './DateCard'
import { Accordion } from '../atoms/Accordion'
import { format } from 'date-fns'

export interface IManageBookingCardProps {
  booking: BookingsForGarageQuery['bookingsForGarage'][0]
}

export const ManageBookingCard = ({ booking }: IManageBookingCardProps) => {
  return (
    <div className="p-4 space-y-3 bg-white ">
      <div className="flex items-start justify-between">
        <TitleStrongValue title={'Vehicle number'}>
          <div className="text-3xl font-bold">{booking.vehicleNumber}</div>
        </TitleStrongValue>
        <div className="px-1 py-0.5 border border-primary">
          <TitleValue title={'Slot'}>{booking.slot.displayName}</TitleValue>
        </div>
      </div>
      <StartEndDateCard
        startTime={booking.startTime}
        endTime={booking.endTime}
      />
      <TitleStrongValue title={'Code'}>
        <Reveal showIntruction={false} secret={booking.passcode || ''} />
      </TitleStrongValue>

      <Accordion
        defaultOpen={false}
        title={
          <TitleStrongValue title={'Status'}>
            <div className="font-bold">
              {booking.status.split('_').join(' ')}
            </div>
          </TitleStrongValue>
        }
      >
        <div className="flex flex-col gap-2">
          {booking.bookingTimeline.map((timeline) => (
            <div key={timeline.timestamp}>
              <TitleValue title={timeline.status}>
                {format(new Date(timeline.timestamp), 'PPp')}
              </TitleValue>
            </div>
          ))}
        </div>
      </Accordion>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ManageValets.tsx">
import { SearchGaragesQuery } from '@autospace/network/src/gql/generated'
import { useState } from 'react'
import { toast } from '../molecules/Toast'
import { useFormContext, useWatch } from 'react-hook-form'
import { FormTypeBookSlot } from '@autospace/forms/src/bookSlot'
import { Switch } from '../atoms/Switch'
import { dividerClasses } from '@mui/material'
import { Marker } from './map/MapMarker'
import { Map } from './map/Map'
import { ParkingIcon } from '../atoms/ParkingIcon'
import { IconUser } from '@tabler/icons-react'
import { Directions } from './Directions'
import { Panel } from './map/Panel'
import { DefaultZoomControls } from './map/ZoomControls'

export const ManageValets = ({
  garage,
}: {
  garage: SearchGaragesQuery['searchGarages'][number]
}) => {
  const [showValet, setShowValet] = useState(false)

  const { setValue } = useFormContext<FormTypeBookSlot>()
  const { valet } = useWatch<FormTypeBookSlot>()

  const lat = garage.address?.lat
  const lng = garage.address?.lng
  if (!lat || !lng) {
    toast('Garage location not set.')
    return <div>Something went wrong.</div>
  }

  return (
    <div className="p-2 space-y-3 bg-gray-25">
      <div className="text-xl font-bold">Valet</div>
      <p className="text-sm text-gray">
        Our valets will whisk your car away to its reserved spot and bring it
        back when you&apos;re ready. It&apos;s like magic, but with cars!
      </p>

      <Switch
        checked={showValet}
        onChange={(e) => {
          setShowValet(e)

          if (!e) {
            setValue('valet', undefined, {
              shouldValidate: true,
            })
            setValue('valet.differentLocations', false)
          } else {
            setValue('valet.pickupInfo', {
              lat,
              lng,
            })
            setValue('valet.dropoffInfo', {
              lat,
              lng,
            })
          }
        }}
        label={'Need valet?'}
      />

      {showValet ? (
        <div>
          <div className="mb-6 space-y-3">
            <p className="text-sm text-gray">
              Want your car delivered somewhere else? No problem! Choose a
              different drop-off point and we&apos;ll make sure your ride is
              there waiting for you.
            </p>
            <Switch
              checked={valet?.differentLocations || false}
              onChange={(e) => {
                setValue('valet.differentLocations', e)
                if (!e) {
                  setValue('valet.dropoffInfo', {
                    lat: valet?.pickupInfo?.lat || lat,
                    lng: valet?.pickupInfo?.lng || lat,
                  })
                } else {
                  setValue('valet.dropoffInfo', {
                    lat,
                    lng,
                  })
                }
              }}
              label={'Add a different drop off location?'}
            />
          </div>
          <Map
            initialViewState={{
              latitude: lat,
              longitude: lng,
              zoom: 13,
            }}
            height="50vh"
          >
            <Panel position="right-center">
              <DefaultZoomControls />
            </Panel>
            <Marker latitude={lat} longitude={lng}>
              <ParkingIcon />
            </Marker>
            {valet?.pickupInfo?.lng && valet?.pickupInfo?.lat ? (
              <>
                <Marker
                  pitchAlignment="auto"
                  longitude={valet?.pickupInfo?.lng}
                  latitude={valet?.pickupInfo?.lat}
                  draggable
                  onDragEnd={({ lngLat }) => {
                    const { lat, lng } = lngLat
                    setValue('valet.pickupInfo.lat', lat || 0)
                    setValue('valet.pickupInfo.lng', lng || 0)
                    if (!valet.differentLocations) {
                      setValue('valet.dropoffInfo.lat', lat || 0)
                      setValue('valet.dropoffInfo.lng', lng || 0)
                    }
                  }}
                >
                  <div className="flex flex-col items-center">
                    <IconUser />
                    <span>
                      Pickup {!valet.differentLocations ? '& drop off' : null}
                    </span>
                  </div>
                </Marker>
                <Directions
                  sourceId={'pickup_route'}
                  origin={{ lat, lng }}
                  destination={{
                    lat: valet.pickupInfo.lat,
                    lng: valet.pickupInfo.lng,
                  }}
                  setDistance={(distance) => {
                    setValue('valet.pickupInfo.distance', distance)
                  }}
                />
              </>
            ) : null}

            {valet?.differentLocations &&
            valet?.dropoffInfo?.lng &&
            valet?.dropoffInfo?.lat ? (
              <>
                <Marker
                  pitchAlignment="auto"
                  longitude={valet.dropoffInfo.lng}
                  latitude={valet.dropoffInfo.lat}
                  draggable
                  onDragEnd={({ lngLat }) => {
                    const { lat, lng } = lngLat
                    setValue('valet.dropoffInfo.lat', lat || 0)
                    setValue('valet.dropoffInfo.lng', lng || 0)
                  }}
                >
                  <div className="flex flex-col items-center">
                    <IconUser />
                    <span>Drop off</span>
                  </div>
                </Marker>
                <Directions
                  sourceId={'dropoff_route'}
                  origin={{ lat, lng }}
                  destination={{
                    lat: valet.dropoffInfo.lat,
                    lng: valet.dropoffInfo.lng,
                  }}
                  setDistance={(distance) => {
                    setValue('valet.dropoffInfo.distance', distance)
                  }}
                />
              </>
            ) : null}
          </Map>
        </div>
      ) : null}
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/Menus.tsx">
import { MenuItem } from '@autospace/util/types'
import Link from 'next/link'

export interface IMenuItemProps {
  menuItems: MenuItem[]
}

export const Menus = ({ menuItems }: IMenuItemProps) => {
  return (
    <>
      {menuItems.map(({ label, href }) => (
        <Link
          className="hover:underline underline-offset-8 transition-all "
          key={label}
          href={href}
        >
          {label}
        </Link>
      ))}
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/NavSidebar.tsx">
'use client'
import { IconMenu2 } from '@tabler/icons-react'
import Link from 'next/link'
import { Sidebar } from './Sidebar'
import { useDialogState } from '@autospace/util/hooks/dialog'

import { MenuItem } from '@autospace/util/types'
import { LogoutButton } from '../molecules/LogoutButton'
import { UserInfo } from '../molecules/UserInfo'
import { Menus } from './Menus'

export interface INavSidebarProps {
  menuItems: MenuItem[]
}

export const NavSidebar = ({ menuItems }: INavSidebarProps) => {
  const [open, setOpen] = useDialogState()

  return (
    <>
      <button
        type="button"
        onClick={() => setOpen((state) => !state)}
        className="p-2"
        aria-label="Open main menu"
      >
        <IconMenu2 className="w-5 h-5" />
      </button>
      <Sidebar open={open} setOpen={setOpen}>
        <div className="flex flex-col items-start space-y-1">
          <UserInfo className="mb-4" />
          <Menus menuItems={menuItems} />
        </div>
        <div className=" mt-auto">
          <LogoutButton />
        </div>
      </Sidebar>
    </>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ShowCustomerBookings.tsx">
import {
  BookingStatus,
  BookingsForCustomerDocument,
} from '@autospace/network/src/gql/generated'
import { useTakeSkip } from '@autospace/util/hooks/pagination'
import { useSession } from 'next-auth/react'
import { useLazyQuery, useQuery } from '@apollo/client'
import { useEffect } from 'react'
import { ShowData } from './ShowData'
import { CustomerBookingCard } from './CustomerBookingCard'

export const ShowCustomerBookings = ({
  statuses,
}: {
  statuses: BookingStatus[]
}) => {
  const session = useSession()
  const uid = session.data?.user?.uid

  const { setSkip, setTake, skip, take } = useTakeSkip()

  const { loading, data, error } = useQuery(BookingsForCustomerDocument, {
    variables: {
      skip,
      take,
      where: {
        status: {
          in: statuses,
        },
      },
    },
  })

  return (
    <ShowData
      error={error?.message}
      loading={loading}
      pagination={{
        skip,
        take,
        resultCount: data?.bookingsForCustomer.length || 0,
        totalCount: data?.bookingsCount.count || 0,
        setSkip,
        setTake,
      }}
    >
      {data?.bookingsForCustomer.map((booking) => (
        <CustomerBookingCard key={booking.id} booking={booking} />
      ))}
    </ShowData>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ShowData.tsx">
import { AlertSection } from '../molecules/AlertSection'
import { LoaderPanel } from '../molecules/Loader'
import { NoResults } from '../molecules/NoResults'
import { Pagination } from '@mui/material'

interface ShowDataProps {
  error?: string
  loading?: boolean
  pagination: {
    setSkip: (skip: number) => void
    setTake: (take: number) => void
    skip: number
    take: number
    resultCount?: number
    totalCount?: number
  }
  title?: React.ReactNode
  children: React.ReactNode
  childrenClassName?: string
}

export const ShowData = ({
  error,
  loading,
  pagination,
  title,
  children,
  childrenClassName = 'grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-4 gap-3',
}: ShowDataProps) => {
  const { setSkip, setTake, skip, take, resultCount, totalCount } = pagination

  const handlePageChange = (
    event: React.ChangeEvent<unknown>,
    page: number,
  ) => {
    setSkip((page - 1) * take)
  }

  const totalPages = Math.ceil((totalCount || 0) / take)

  return (
    <div>
      <h2 className="text-lg mb-1 font-semibold mt-2">{title}</h2>
      {loading && <LoaderPanel />}
      {!loading && !error && resultCount === 0 && <NoResults />}

      {error && (
        <AlertSection>
          Oops. Something went wrong.{' '}
          <span className="text-xs">Psst. {error}</span>
        </AlertSection>
      )}

      <div className={childrenClassName}>{children}</div>
      <div className="flex justify-center mt-8">
        <Pagination
          count={totalPages}
          showFirstButton
          showLastButton
          page={skip / take + 1}
          onChange={handlePageChange}
        />
      </div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ShowGarageBookings.tsx">
import {
  BookingStatus,
  BookingsForGarageDocument,
  QueryMode,
} from '@autospace/network/src/gql/generated'
import { IconSearch } from '@tabler/icons-react'
import { useState } from 'react'
import { useQuery } from '@apollo/client'
import { useTakeSkip } from '@autospace/util/hooks/pagination'
import { ShowData } from './ShowData'
import { ManageBookingCard } from './ManageBookingCard'
import { CheckInOutButton } from './CheckInOutButtons'

export const ShowGarageBookings = ({
  garageId,
  statuses,
  showCheckIn = false,
  showCheckOut = false,
}: {
  garageId: number
  statuses: BookingStatus[]
  showCheckIn?: boolean
  showCheckOut?: boolean
}) => {
  const [searchTerm, setSearchTerm] = useState('')
  const { take, setTake, skip, setSkip } = useTakeSkip()

  const { data, loading, error } = useQuery(BookingsForGarageDocument, {
    variables: {
      skip,
      take,
      where: {
        status: { in: statuses },
        Slot: {
          is: {
            garageId: { equals: garageId },
          },
        },
        ...(searchTerm && {
          vehicleNumber: {
            contains: searchTerm,
            mode: QueryMode.Insensitive,
          },
        }),
      },
    },
  })

  return (
    <div className="mt-4">
      <div className="flex justify-center">
        <div className="flex justify-start items-center gap-2 w-full max-w-xl  rounded-full shadow-xl bg-white px-4">
          <IconSearch />
          <input
            placeholder="Search vehicle number"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="flex-grow py-4 bg-transparent"
          />
        </div>
      </div>
      <ShowData
        loading={loading}
        pagination={{
          skip,
          take,
          resultCount: data?.bookingsForGarage.length,
          totalCount: data?.bookingsCount.count,
          setSkip,
          setTake,
        }}
      >
        {data?.bookingsForGarage.map((booking) => (
          <div key={booking.id}>
            <ManageBookingCard booking={booking} />
            {showCheckIn ? (
              <CheckInOutButton
                status={BookingStatus.CheckedIn}
                buttonText="CHECK IN"
                bookingId={booking.id}
              />
            ) : null}
            {showCheckOut ? (
              <CheckInOutButton
                status={BookingStatus.CheckedOut}
                buttonText="CHECK OUT"
                bookingId={booking.id}
              />
            ) : null}
          </div>
        ))}
      </ShowData>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ShowValetAllDropTrips.tsx">
import {
  BookingStatus,
  ValetDropsDocument,
  ValetPickupsDocument,
} from '@autospace/network/src/gql/generated'
import { useQuery } from '@apollo/client'
import { useTakeSkip } from '@autospace/util/hooks/pagination'
import { ShowData } from './ShowData'
import { ValetTripCard } from './ValetTripCard'
import { AssignValetButton } from './AssignValetButton'

export const ShowValetAllDropTrips = () => {
  const { loading, data } = useQuery(ValetDropsDocument)
  const { setSkip, setTake, skip, take } = useTakeSkip()
  return (
    <ShowData
      loading={loading}
      pagination={{
        setSkip,
        setTake,
        skip,
        take,
        resultCount: data?.valetDrops.length || 0,
        totalCount: data?.valetDropsTotal || 0,
      }}
    >
      {data?.valetDrops.map((booking) => (
        <ValetTripCard
          key={booking.id}
          booking={{
            id: booking.id,
            time: booking.endTime,
          }}
          end={{
            lat: booking.valetAssignment?.returnLat || undefined,
            lng: booking.valetAssignment?.returnLng || undefined,
          }}
          start={booking.slot.garage.address}
        >
          <AssignValetButton
            bookingId={booking.id}
            status={BookingStatus.ValetAssignedForCheckOut}
          >
            Accept
          </AssignValetButton>
        </ValetTripCard>
      ))}
    </ShowData>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ShowValetAllPickupTrips.tsx">
import {
  BookingStatus,
  ValetPickupsDocument,
} from '@autospace/network/src/gql/generated'
import { useQuery } from '@apollo/client'
import { useTakeSkip } from '@autospace/util/hooks/pagination'
import { ShowData } from './ShowData'
import { ValetTripCard } from './ValetTripCard'
import { AssignValetButton } from './AssignValetButton'

export const ShowValetAllPickupTrips = () => {
  const { loading, data } = useQuery(ValetPickupsDocument)
  const { setSkip, setTake, skip, take } = useTakeSkip()
  return (
    <ShowData
      loading={loading}
      pagination={{
        setSkip,
        setTake,
        skip,
        take,
        resultCount: data?.valetPickups.length || 0,
        totalCount: data?.valetPickupsTotal || 0,
      }}
    >
      {data?.valetPickups.map((booking) => (
        <ValetTripCard
          key={booking.id}
          booking={{
            id: booking.id,
            time: booking.startTime,
          }}
          start={{
            lat: booking.valetAssignment?.pickupLat,
            lng: booking.valetAssignment?.pickupLng,
          }}
          end={booking.slot.garage.address}
        >
          <AssignValetButton
            bookingId={booking.id}
            status={BookingStatus.ValetAssignedForCheckIn}
          >
            Accept
          </AssignValetButton>
        </ValetTripCard>
      ))}
    </ShowData>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ShowValetMyDropTrips.tsx">
import { useTakeSkip } from '@autospace/util/hooks/pagination'
import { useQuery } from '@apollo/client'
import {
  BookingStatus,
  MyDropTripsDocument,
  SortOrder,
} from '@autospace/network/src/gql/generated'
import { ShowData } from './ShowData'
import { ValetTripCard } from './ValetTripCard'
import { Reveal } from '../molecules/Reveal'
import { AssignValetButton } from './AssignValetButton'

export const ShowValetMyDropTrips = ({ uid }: { uid: string }) => {
  const { setSkip, setTake, skip, take } = useTakeSkip()

  const { data, loading } = useQuery(MyDropTripsDocument, {
    variables: {
      skip,
      take,
      orderBy: { endTime: SortOrder.Asc },
      where: {
        BookingTimeline: {
          none: {
            status: BookingStatus.ValetReturned,
          },
        },
        ValetAssignment: {
          is: {
            returnValetId: { equals: uid },
          },
        },
      },
    },
  })

  return (
    <ShowData
      loading={loading}
      pagination={{
        setSkip,
        setTake,
        skip,
        take,
        resultCount: data?.bookingsForValet.length || 0,
        totalCount: data?.bookingsCount.count || 0,
      }}
    >
      {data?.bookingsForValet.map((booking) => (
        <ValetTripCard
          key={booking.id}
          booking={{
            id: booking.id,
            time: booking.startTime,
          }}
          end={{
            lat: booking.valetAssignment?.returnLat || undefined,
            lng: booking.valetAssignment?.returnLng || undefined,
          }}
          start={booking.slot.garage.address}
        >
          <div className="space-y-2">
            <div className="grid grid-cols-2 gap-3">
              <div className="text-xl font-semibold ">
                {booking.vehicleNumber}
              </div>

              <Reveal
                secret={booking.passcode}
                showIntruction={false}
                className="w-full"
              />
            </div>

            <div className="text-sm">
              {booking.status?.split('_').join(' ')}
            </div>

            {[
              BookingStatus.ValetAssignedForCheckIn,
              BookingStatus.CheckedOut,
            ].includes(booking.status) ? (
              <AssignValetButton
                bookingId={booking.id}
                status={BookingStatus.ValetReturned}
              >
                Drop
              </AssignValetButton>
            ) : null}
          </div>
        </ValetTripCard>
      ))}
    </ShowData>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ShowValetMyPickupTrips.tsx">
import { useTakeSkip } from '@autospace/util/hooks/pagination'
import { useQuery } from '@apollo/client'
import {
  BookingStatus,
  MyPickupTripsDocument,
  SortOrder,
} from '@autospace/network/src/gql/generated'
import { ShowData } from './ShowData'
import { ValetTripCard } from './ValetTripCard'
import { Reveal } from '../molecules/Reveal'
import { AssignValetButton } from './AssignValetButton'

export const ShowValetMyPickupTrips = ({ uid }: { uid: string }) => {
  const { setSkip, setTake, skip, take } = useTakeSkip()

  const { data, loading } = useQuery(MyPickupTripsDocument, {
    variables: {
      skip,
      take,
      orderBy: { startTime: SortOrder.Asc },
      where: {
        BookingTimeline: {
          none: {
            status: BookingStatus.CheckedIn,
          },
        },
        ValetAssignment: {
          is: {
            pickupValetId: { equals: uid },
          },
        },
      },
    },
  })

  return (
    <ShowData
      loading={loading}
      pagination={{
        setSkip,
        setTake,
        skip,
        take,
        resultCount: data?.bookingsForValet.length || 0,
        totalCount: data?.bookingsCount.count || 0,
      }}
    >
      {data?.bookingsForValet.map((booking) => (
        <ValetTripCard
          key={booking.id}
          booking={{
            id: booking.id,
            time: booking.startTime,
          }}
          start={{
            lat: booking.valetAssignment?.pickupLat,
            lng: booking.valetAssignment?.pickupLng,
          }}
          end={booking.slot.garage.address}
        >
          <div className="space-y-2">
            <div className="grid grid-cols-2 gap-3">
              <div className="text-xl font-semibold ">
                {booking.vehicleNumber}
              </div>

              <Reveal
                secret={booking.passcode}
                showIntruction={false}
                className="w-full"
              />
            </div>

            <div className="text-sm">
              {booking.status?.split('_').join(' ')}
            </div>

            {booking.status === BookingStatus.ValetAssignedForCheckIn ? (
              <AssignValetButton
                bookingId={booking.id}
                status={BookingStatus.ValetPickedUp}
              >
                Pickup
              </AssignValetButton>
            ) : null}
          </div>
        </ValetTripCard>
      ))}
    </ShowData>
  )
}
</file>

<file path="libs/ui/src/components/organisms/Sidebar.tsx">
import {
  Dialog,
  DialogPanel,
  Transition,
  TransitionChild,
} from '@headlessui/react'
import { Fragment, ReactNode } from 'react'
import { IconX } from '@tabler/icons-react'

export interface ISidebarProps {
  open: boolean
  setOpen: (open: boolean) => void
  children: ReactNode
  blur?: boolean
}

export const Sidebar = ({
  open,
  setOpen,
  children,
  blur = true,
}: ISidebarProps) => {
  return (
    <Transition appear show={open} as={Fragment}>
      <Dialog
        as="div"
        className="fixed inset-0 z-50 overflow-hidden"
        onClose={() => setOpen(false)}
      >
        {blur ? (
          <TransitionChild
            as={Fragment}
            enter="transition-opacity ease-linear duration-150"
            enterFrom="opacity-0"
            enterTo="opacity-100"
            leave="transition-opacity ease-linear duration-100"
            leaveFrom="opacity-100"
            leaveTo="opacity-0"
          >
            <div className="absolute inset-0 bg-black/30 backdrop-blur-sm" />
          </TransitionChild>
        ) : null}

        <div className="fixed inset-y-0 right-0 flex max-w-full bg-white  ">
          <TransitionChild
            as={Fragment}
            enter="transform transition ease-in-out duration-150"
            enterFrom="translate-x-full"
            enterTo="translate-x-0"
            leave="transform transition ease-in-out duration-100"
            leaveFrom="translate-x-0"
            leaveTo="translate-x-full"
          >
            <DialogPanel className="flex flex-col w-screen max-w-md p-3">
              <button
                type="button"
                className="absolute top-0 right-0 z-10 m-2 ml-auto rounded-full"
                onClick={() => setOpen(false)}
              >
                <IconX className="w-6 h-6 p-1" aria-hidden="true" />
              </button>
              {children}
            </DialogPanel>
          </TransitionChild>
        </div>
      </Dialog>
    </Transition>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ValetCard.tsx">
import { CompanyValetsQuery } from '@autospace/network/src/gql/generated'
import { format } from 'date-fns'
import Image from 'next/image'

export interface IValetCardProps {
  valet: CompanyValetsQuery['companyValets'][0]
}

export const ValetCard = ({ valet }: IValetCardProps) => {
  return (
    <div className="space-y-2">
      <div className="p-1 border-2 shadow-lg border-primary">
        <Image
          className="object-cover w-full aspect-square "
          width={200}
          height={300}
          src={valet.image || '/valet.jpeg'}
          alt={''}
        />
      </div>
      <div>
        <div className="font-semibold ">{valet.displayName}</div>
        <div className="mb-1 text-xs ">{valet.uid}</div>
        <div className="mb-1 text-xs ">{valet.licenceID}</div>
        <div className="text-xs text-gray">
          {format(new Date(valet.createdAt), 'PP')}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/organisms/ValetTripCard.tsx">
import { useMapboxDirections } from '@autospace/util/hooks/directions'
import { LatLng } from '@autospace/util/types'
import { isLatLng } from '@autospace/util'
import { ReactNode } from 'react'
import { AlertSection } from '../molecules/AlertSection'
import { MapLink } from '../molecules/MapLink'
import { StaticMapDirections } from './map/StaticMapDirections'
import { format } from 'date-fns'

export interface IValetTripCardProps {
  start?: Partial<LatLng> | null
  end?: Partial<LatLng> | null
  booking: {
    id: number
    time: string
  }
  children?: ReactNode
}

export const ValetTripCard = ({
  start,
  end,
  booking,
  children,
}: IValetTripCardProps) => {
  const { data, distance, error, loading } = useMapboxDirections(start, end)

  if (!isLatLng(start) || !isLatLng(end)) {
    return (
      <AlertSection>
        <div>Something went wrong.</div>
        <div className="text-xs">Start end locations not set.</div>
      </AlertSection>
    )
  }

  return (
    <div>
      <MapLink waypoints={[start, end]}>
        <StaticMapDirections start={start} end={end} coordinates={data} />
      </MapLink>
      <div className="p-2 bg-white space-y-2 ">
        <div className="flex justify-between gap-2 ">
          <div>
            <div className="text-lg font-semibold">
              {format(new Date(booking.time), 'p')}
            </div>
            <div className="text-xs text-gray">
              {format(new Date(booking.time), 'PP')}
            </div>
          </div>
          <div className="font-medium">
            {((distance || 0) / 1000).toFixed(2)}Km
          </div>
        </div>
        {children}
      </div>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/templates/AdminHome.tsx">
'use client'
import { useTakeSkip } from '@autospace/util/hooks/pagination'
import { useQuery } from '@apollo/client'
import { GaragesDocument } from '@autospace/network/src/gql/generated'
import { ShowData } from '../organisms/ShowData'
import { GarageAdminCard } from '../organisms/GarageAdminCard'
import { CreateVerificationButton } from '../organisms/admin/CreateVerificationButton'
import { RemoveVerificationButton } from '../organisms/admin/RemoveVerificationButton'

export const AdminHome = () => {
  return <ShowGarages />
}

export const ShowGarages = () => {
  const { setSkip, setTake, skip, take } = useTakeSkip()
  const { loading, data, error } = useQuery(GaragesDocument, {
    variables: { skip, take },
  })

  return (
    <ShowData
      error={error?.message}
      title="Garages"
      loading={loading}
      pagination={{
        resultCount: data?.garages.length || 0,
        totalCount: data?.garagesCount.count || 0,
        setSkip,
        setTake,
        skip,
        take,
      }}
    >
      {data?.garages.map((garage) => (
        <GarageAdminCard key={garage.id} garage={garage}>
          <div className="flex justify-end">
            {!garage?.verification?.verified ? (
              <CreateVerificationButton garageId={garage.id} />
            ) : (
              <RemoveVerificationButton garageId={garage.id} />
            )}
          </div>
        </GarageAdminCard>
      ))}
    </ShowData>
  )
}
</file>

<file path="libs/ui/src/components/templates/CreateGarage.tsx">
'use client'
import {
  FormProviderCreateGarage,
  FormTypeCreateGarage,
  useFormCreateGarage,
} from '@autospace/forms/src/createGarage'
import { useMutation } from '@apollo/client'
import { useCloudinaryUpload } from '@autospace/util/hooks/cloudinary'
import {
  CreateGarageDocument,
  namedOperations,
} from '@autospace/network/src/gql/generated'
import { Form } from '../atoms/Form'
import { HtmlLabel } from '../atoms/HtmlLabel'
import { HtmlInput } from '../atoms/HtmlInput'
import { Button } from '../atoms/Button'
import { HtmlTextArea } from '../atoms/HtmlTextArea'
import { ImagePreview } from '../organisms/ImagePreview'
import { Controller } from 'react-hook-form'
import { Map } from '../organisms/map/Map'
import { initialViewState } from '@autospace/util/constants'
import { Panel } from '../organisms/map/Panel'
import { SearchPlaceBox } from '../organisms/map/SearchPlacesBox'
import { ViewState } from '@autospace/util/types'
import { CenterOfMap, DefaultZoomControls } from '../organisms/map/ZoomControls'
import { useFormContext } from 'react-hook-form'
import { AddSlots, GarageMapMarker } from '../organisms/CreateGarageComponents'
import { ToastContainer, toast } from '../molecules/Toast'

const CreateGarageContent = () => {
  const {
    register,
    handleSubmit,
    setValue,
    reset,
    control,
    formState: { errors },
    resetField,
    watch,
  } = useFormContext<FormTypeCreateGarage>()

  const { images } = watch()

  const { uploading, upload } = useCloudinaryUpload()

  const [createGarage, { data, error, loading }] = useMutation(
    CreateGarageDocument,
    {
      refetchQueries: [namedOperations.Query.Garages],
      onCompleted: () => {
        reset()
        toast('Garage created successfully.')
      },
      onError(error, clientOptions) {
        toast('Action failed.')
      },
    },
  )

  return (
    <div className="grid md:grid-cols-2 gap-2 mt-2 ">
      <div>
        <Form
          onSubmit={handleSubmit(
            async ({
              images,
              description,
              displayName,
              location,
              slotTypes,
            }) => {
              const uploadedImages = await upload(images)

              const result = await createGarage({
                variables: {
                  createGarageInput: {
                    Address: location,
                    images: uploadedImages,
                    Slots: slotTypes,
                    description,
                    displayName,
                  },
                },
              })
            },
          )}
        >
          <HtmlLabel error={errors.displayName?.message} title="Display Name">
            <HtmlInput {...register('displayName')} placeholder="Garage name" />
          </HtmlLabel>
          <HtmlLabel title="Description" error={errors.description?.message}>
            <HtmlTextArea
              cols={5}
              {...register('description')}
              placeholder="Describe..."
            />
          </HtmlLabel>
          <HtmlLabel title="Address" error={errors.location?.address?.message}>
            <HtmlTextArea
              cols={5}
              {...register('location.address')}
              placeholder="123, street name"
            />
          </HtmlLabel>
          <ImagePreview srcs={images} clearImage={() => resetField('images')}>
            <Controller
              control={control}
              name={`images`}
              render={({ field }) => (
                <HtmlInput
                  type="file"
                  accept="image/*"
                  multiple={true}
                  onChange={(e) => field.onChange(e?.target?.files)}
                  className="border-0"
                />
              )}
            />
          </ImagePreview>
          <AddSlots />
          <Button loading={uploading || loading} type="submit">
            Submit
          </Button>
        </Form>
      </div>
      <Map
        initialViewState={initialViewState}
        onLoad={(e) => {
          const { lat, lng } = e.target.getCenter()
          setValue('location.lat', lat)
          setValue('location.lng', lng)
        }}
      >
        <GarageMapMarker />
        <Panel position="left-top">
          <SearchPlaceBox
            onLocationChange={(location: ViewState) => {
              setValue('location.lat', location.latitude)
              setValue('location.lng', location.longitude)
            }}
          />
          <DefaultZoomControls>
            <CenterOfMap
              onClick={(latLng) => {
                const lat = parseFloat(latLng.lat.toFixed(8))
                const lng = parseFloat(latLng.lng.toFixed(8))

                setValue('location.lat', lat, {
                  shouldValidate: true,
                })
                setValue('location.lng', lng, {
                  shouldValidate: true,
                })
              }}
            />
          </DefaultZoomControls>
        </Panel>
      </Map>
    </div>
  )
}

export const CreateGarage = () => {
  return (
    <FormProviderCreateGarage>
      <CreateGarageContent />
    </FormProviderCreateGarage>
  )
}
</file>

<file path="libs/ui/src/components/templates/ListCustomerBookings.tsx">
'use client'
import { Tab, Tabs, TabPanel } from '../molecules/Tabs'
import { useState } from 'react'
import { ShowCustomerBookings } from '../organisms/ShowCustomerBookings'
import { BookingStatus } from '@autospace/network/src/gql/generated'

export const ListCustomerBookings = () => {
  const [value, setValue] = useState<0 | 1>(1)
  return (
    <>
      <Tabs
        value={value}
        onChange={(e, v) => setValue(v)}
        aria-label="bookings"
      >
        <Tab label={'PAST'} />
        <Tab label={'ON GOING'} />
      </Tabs>
      <TabPanel value={value} index={0}>
        <ShowCustomerBookings
          statuses={[BookingStatus.CheckedOut, BookingStatus.ValetReturned]}
        />
      </TabPanel>
      <TabPanel value={value} index={1}>
        <ShowCustomerBookings
          statuses={[
            BookingStatus.Booked,
            BookingStatus.ValetPickedUp,
            BookingStatus.ValetAssignedForCheckIn,
            BookingStatus.CheckedIn,
            BookingStatus.ValetAssignedForCheckOut,
          ]}
        />
      </TabPanel>
    </>
  )
}
</file>

<file path="libs/ui/src/components/templates/ListGarageBookings.tsx">
'use client'
import { useState } from 'react'
import { Tab, TabPanel, Tabs } from '../molecules/Tabs'
import { ShowGarageBookings } from '../organisms/ShowGarageBookings'
import { BookingStatus } from '@autospace/network/src/gql/generated'

export interface IListBookingsProps {
  garageId: number
}
export const ListGarageBookings = ({ garageId }: IListBookingsProps) => {
  const [value, setValue] = useState<0 | 1 | 2>(0)

  return (
    <div>
      <Tabs
        value={value}
        onChange={(e, v) => setValue(v)}
        aria-label="bookings"
      >
        <Tab label={'IN'} />
        <Tab label={'OUT'} />
        <Tab label={'RESOLVED'} />
      </Tabs>
      <TabPanel value={value} index={0}>
        <ShowGarageBookings
          garageId={garageId}
          statuses={[
            BookingStatus.Booked,
            BookingStatus.ValetPickedUp,
            BookingStatus.ValetAssignedForCheckIn,
          ]}
          showCheckIn
        />
      </TabPanel>
      <TabPanel value={value} index={1}>
        <ShowGarageBookings
          garageId={garageId}
          statuses={[
            BookingStatus.CheckedIn,
            BookingStatus.ValetAssignedForCheckOut,
          ]}
          showCheckOut
        />
      </TabPanel>
      <TabPanel value={value} index={2}>
        <ShowGarageBookings
          garageId={garageId}
          statuses={[BookingStatus.CheckedOut]}
        />
      </TabPanel>
    </div>
  )
}
</file>

<file path="libs/ui/src/components/templates/LoginForm.tsx">
'use client'
import { useFormLogin } from '@autospace/forms/src/login'
import { Form } from '../atoms/Form'
import { HtmlLabel } from '../atoms/HtmlLabel'
import { HtmlInput } from '../atoms/HtmlInput'
import { Button } from '../atoms/Button'
import Link from 'next/link'
import { signIn } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

export interface ILoginFormProps {
  className?: string
}
export const LoginForm = ({ className }: ILoginFormProps) => {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useFormLogin()

  const { replace } = useRouter()
  const [loading, setLoading] = useState(false)

  return (
    <Form
      onSubmit={handleSubmit(async (data) => {
        const { email, password } = data
        setLoading(true)

        const result = await signIn('credentials', {
          email,
          password,
          redirect: false,
        })
        setLoading(false)

        if (result?.ok) {
          replace('/')
        }
        if (result?.error) {
          alert('Login failed. Try again.')
        }
      })}
    >
      <HtmlLabel title="Email" error={errors.email?.message}>
        <HtmlInput
          className="text-black"
          {...register('email')}
          placeholder="email"
        />
      </HtmlLabel>
      <HtmlLabel title="Password" error={errors.password?.message}>
        <HtmlInput
          className="text-black"
          type="password"
          {...register('password')}
          placeholder="******"
        />
      </HtmlLabel>
      <Button type="submit" loading={loading}>
        Submit
      </Button>
      <div className="mt-4 text-sm">
        Do not have an autospace account?
        <br />
        <Link
          href="/register"
          className="font-bold underline underline-offset-4"
        >
          Create one
        </Link>{' '}
        now.
      </div>
    </Form>
  )
}
</file>

<file path="libs/ui/src/components/templates/ManageAdmins.tsx">
'use client'
import { useTakeSkip } from '@autospace/util/hooks/pagination'
import { useMutation, useQuery } from '@apollo/client'
import { AdminsDocument } from '@autospace/network/src/gql/generated'
import { ShowData } from '../organisms/ShowData'
import { AdminCard } from '../organisms/admin/AdminCard'
import { RemoveAdminButton } from '../organisms/admin/RemoveAdminButton'
import { CreateAdmin } from '../organisms/admin/CreateAdmin'

export const ManageAdmins = () => {
  const { setSkip, setTake, skip, take } = useTakeSkip(0)

  const { data, loading } = useQuery(AdminsDocument, {
    variables: { skip, take },
  })

  return (
    <>
      <div className="flex justify-end">
        <CreateAdmin />
      </div>
      <ShowData
        loading={loading}
        pagination={{
          skip,
          take,
          resultCount: data?.admins.length,
          totalCount: data?.adminsCount,
          setSkip,
          setTake,
        }}
        title={'Manage admins'}
      >
        {data?.admins.map((admin) => (
          <div key={admin.uid} className="pl-0.5 border-l-2  border-primary">
            <AdminCard key={admin.uid} admin={admin}>
              <div className="flex justify-end">
                <RemoveAdminButton uid={admin.uid} />
              </div>
            </AdminCard>
          </div>
        ))}
      </ShowData>
    </>
  )
}
</file>

<file path="libs/ui/src/components/templates/ManageValets.tsx">
'use client'
import { AddValet } from '../organisms/AddValet'
import { ListValets } from '../organisms/ListValets'

export const ManageValets = () => {
  return (
    <div>
      <div className="flex justify-end">
        <AddValet />
      </div>
      <ListValets />
    </div>
  )
}
</file>

<file path="libs/ui/src/components/templates/RegisterForm.tsx">
'use client'
import { Role } from '@autospace/util/types'
import { useFormRegister } from '@autospace/forms/src/register'
import { useMutation } from '@apollo/client'
import { RegisterWithCredentialsDocument } from '@autospace/network/src/gql/generated'
import { Form } from '../atoms/Form'
import { signIn } from 'next-auth/react'
import { HtmlLabel } from '../atoms/HtmlLabel'
import { HtmlInput } from '../atoms/HtmlInput'
import { Button } from '../atoms/Button'
import Link from 'next/link'

export interface ISignupFormProps {
  className?: string
  role?: Role
}
export const RegisterForm = ({ className, role }: ISignupFormProps) => {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useFormRegister()

  const [registerWithCredentials, { loading, data }] = useMutation(
    RegisterWithCredentialsDocument,
  )

  return (
    <Form
      onSubmit={handleSubmit(async (formData) => {
        const { data, errors } = await registerWithCredentials({
          variables: {
            registerWithCredentialsInput: formData,
          },
        })

        if (errors) {
          alert(errors)
        }

        if (data) {
          alert(`User ${data.registerWithCredentials.uid} created. 🎉`)
          signIn('credentials', {
            email: formData.email,
            password: formData.password,
            callbackUrl: '/',
          })
        }
      })}
    >
      <HtmlLabel title="Email" error={errors.email?.message}>
        <HtmlInput
          className="text-black"
          placeholder="Enter the email."
          {...register('email')}
        />
      </HtmlLabel>
      <HtmlLabel title="Password" error={errors.password?.message}>
        <HtmlInput
          className="text-black"
          type="password"
          placeholder="······"
          {...register('password')}
        />
      </HtmlLabel>
      <HtmlLabel title="Display name" error={errors.name?.message}>
        <HtmlInput
          className="text-black"
          placeholder="Enter your name."
          {...register('name')}
        />
      </HtmlLabel>
      {Object.keys(errors).length ? (
        <div className="text-xs text-gray-600">
          Please fix the above {Object.keys(errors).length} errors
        </div>
      ) : null}
      <Button type="submit" fullWidth loading={loading}>
        Register
      </Button>
      <div className="mt-4 text-sm ">
        Already have an autospace account?
        <br />
        <Link href="/login" className="font-bold underline underline-offset-4">
          Login
        </Link>{' '}
        now.
      </div>
    </Form>
  )
}
</file>

<file path="libs/ui/src/components/templates/SearchPage.tsx">
'use client'
import { useCallback } from 'react'
import { Map } from '../organisms/map/Map'
import { Panel } from '../organisms/map/Panel'
import { DefaultZoomControls } from '../organisms/map/ZoomControls'
import { ViewStateChangeEvent } from 'react-map-gl'
import { initialViewState } from '@autospace/util/constants'
import { SearchPlaceBox } from '../organisms/map/SearchPlacesBox'
import { useFormContext } from 'react-hook-form'
import { FormTypeSearchGarage } from '@autospace/forms/src/searchGarages'
import { IconType } from '../molecules/IconTypes'
import { IconArrowDown } from '@tabler/icons-react'
import { HtmlInput } from '../atoms/HtmlInput'
import { toLocalISOString } from '@autospace/util/date'
import { ShowGarages } from '../organisms/search/ShowGarages'
import { FilterSidebar } from '../organisms/search/FilterSidebar'

export const SearchPage = () => {
  const {
    register,
    setValue,
    watch,
    formState: { errors },
    trigger,
  } = useFormContext<FormTypeSearchGarage>()
  console.log('errors ', errors)
  const formData = watch()

  const handleMapChange = useCallback(
    (target: ViewStateChangeEvent['target']) => {
      const bounds = target.getBounds()
      const locationFilter = {
        ne_lat: bounds?.getNorthEast().lat || 0,
        ne_lng: bounds?.getNorthEast().lng || 0,
        sw_lat: bounds?.getSouthWest().lat || 0,
        sw_lng: bounds?.getSouthWest().lng || 0,
      }
      setValue('locationFilter', locationFilter)
    },
    [setValue],
  )

  return (
    <Map
      onLoad={(e) => handleMapChange(e.target)}
      onDragEnd={(e) => handleMapChange(e.target)}
      onZoomEnd={(e) => handleMapChange(e.target)}
      initialViewState={initialViewState}
    >
      <ShowGarages />
      <Panel position="left-top">
        <div className="flex flex-col items-stretch">
          <SearchPlaceBox />
          <div className="flex relative pl-1 flex-col mt-1 bg-white/40 items-center gap-1 backdrop-blur-sm">
            <div className=" absolute left-[1px] top-1/2 -translate-y-1/2 ">
              <IconArrowDown className="p-1" />
            </div>
            <div className="flex gap-1 items-center">
              <IconType time={formData.startTime} />
              <HtmlInput
                type="datetime-local"
                className="w-full p-2 text-lg font-light border-0"
                min={toLocalISOString(new Date()).slice(0, 16)}
                {...register('startTime', {
                  onChange(event) {
                    trigger('startTime')
                    trigger('endTime')
                  },
                })}
              />
            </div>
            <div className="flex gap-1 items-center">
              <IconType time={formData.endTime} />
              <HtmlInput
                min={toLocalISOString(new Date()).slice(0, 16)}
                type="datetime-local"
                className="w-full p-2 text-lg font-light border-0"
                {...register('endTime', {
                  onChange(event) {
                    trigger('endTime')
                  },
                })}
              />
            </div>
          </div>
        </div>
      </Panel>
      <Panel position="right-center">
        <DefaultZoomControls />
      </Panel>
      {errors ? (
        <Panel position="center-bottom">
          {Object.entries(errors).map(([key, value]) => {
            return (
              <div className="text-red-800 p-2 shadow bg-white" key={key}>
                {key}: {value.message}
              </div>
            )
          })}
        </Panel>
      ) : null}
      <Panel position="right-top">
        <FilterSidebar />
      </Panel>
    </Map>
  )
}
</file>

<file path="libs/ui/src/components/templates/ValetHome.tsx">
import { useState } from 'react'
import { Tab, TabPanel, Tabs } from '../molecules/Tabs'
import { ShowValetAllPickupTrips } from '../organisms/ShowValetAllPickupTrips'
import { ShowValetAllDropTrips } from '../organisms/ShowValetAllDropTrips'

export const ValetHome = () => {
  const [value, setValue] = useState<0 | 1>(0)

  return (
    <>
      <Tabs
        value={value}
        onChange={(e, v) => setValue(v)}
        aria-label="bookings"
      >
        <Tab label={'Pickup'} />
        <Tab label={'Drop'} />
      </Tabs>
      <TabPanel value={value} index={0}>
        <ShowValetAllPickupTrips />
      </TabPanel>
      <TabPanel value={value} index={1}>
        <ShowValetAllDropTrips />
      </TabPanel>
    </>
  )
}
</file>

<file path="libs/ui/src/components/templates/ValetTrips.tsx">
import { useState } from 'react'
import { Tab, TabPanel, Tabs } from '../molecules/Tabs'
import { ShowValetMyPickupTrips } from '../organisms/ShowValetMyPickupTrips'
import { ShowValetMyDropTrips } from '../organisms/ShowValetMyDropTrips'

export const ValetTrips = ({ uid }: { uid: string }) => {
  const [value, setValue] = useState<0 | 1>(0)

  return (
    <>
      <Tabs
        value={value}
        onChange={(e, v) => setValue(v)}
        aria-label="bookings"
      >
        <Tab label={'Pickup'} />
        <Tab label={'Drop'} />
      </Tabs>
      <TabPanel value={value} index={0}>
        <ShowValetMyPickupTrips uid={uid} />
      </TabPanel>
      <TabPanel value={value} index={1}>
        <ShowValetMyDropTrips uid={uid} />
      </TabPanel>
    </>
  )
}
</file>

<file path="libs/ui/src/styles/config.js">
import colors from 'tailwindcss/colors'

const brandHue = 52

// #ffdd00 for brandHue 52
const primaryPallete = {
  DEFAULT: `hsl(${brandHue}, 100%, 50%)`,
  25: `hsl(${brandHue}, 100%, 98%)`,
  50: `hsl(${brandHue}, 100%, 92%)`,
  100: `hsl(${brandHue}, 100%, 84%)`,
  200: `hsl(${brandHue}, 100%, 75%)`,
  300: `hsl(${brandHue}, 100%, 66%)`,
  400: `hsl(${brandHue}, 100%, 58%)`,
  500: `hsl(${brandHue}, 100%, 50%)`,
  600: `hsl(${brandHue}, 100%, 45%)`,
  700: `hsl(${brandHue}, 100%, 30%)`,
  800: `hsl(${brandHue}, 100%, 20%)`,
  900: `hsl(${brandHue}, 100%, 06%)`,
}
const grayPallete = {
  DEFAULT: `hsl(${brandHue}, 2%, 32%)`,
  25: `hsl(${brandHue}, 2%, 94%)`,
  50: `hsl(${brandHue}, 2%, 90%)`,
  100: `hsl(${brandHue}, 2%, 80%)`,
  200: `hsl(${brandHue}, 2%, 70%)`,
  300: `hsl(${brandHue}, 2%, 60%)`,
  400: `hsl(${brandHue}, 2%, 50%)`,
  500: `hsl(${brandHue}, 2%, 32%)`,
  600: `hsl(${brandHue}, 2%, 24%)`,
  700: `hsl(${brandHue}, 2%, 16%)`,
  800: `hsl(${brandHue}, 2%, 08%)`,
  900: `hsl(${brandHue}, 2%, 04%)`,
}

const greenPallete = {
  DEFAULT: 'hsl(116, 100%, 27%)',
  25: 'hsl(116, 100%, 98%)',
  50: 'hsl(116, 100%, 90%)',
  100: 'hsl(116, 100%, 78%)',
  200: 'hsl(116, 100%, 66%)',
  300: 'hsl(116, 100%, 54%)',
  400: 'hsl(116, 100%, 40%)',
  500: 'hsl(116, 100%, 27%)',
  600: 'hsl(116, 100%, 21%)',
  700: 'hsl(116, 100%, 14%)',
  800: 'hsl(116, 100%, 08%)',
  900: 'hsl(116, 100%, 04%)',
}
const redPallete = {
  DEFAULT: 'hsl(10, 94%, 45%)',
  25: 'hsl(10, 94%, 98%)',
  50: 'hsl(10, 94%, 92%)',
  100: 'hsl(10, 94%, 84%)',
  200: 'hsl(10, 94%, 74%)',
  300: 'hsl(10, 94%, 64%)',
  400: 'hsl(10, 94%, 54%)',
  500: 'hsl(10, 94%, 45%)',
  600: 'hsl(10, 94%, 35%)',
  700: 'hsl(10, 94%, 22%)',
  800: 'hsl(10, 94%, 10%)',
  900: 'hsl(10, 94%, 04%)',
}

export const animationConfig = {
  'spin-reverse': 'reverse-spin 1s linear infinite',
  'spin-slow': 'spin 3s linear infinite',
  'spin-12': 'spin 12s linear infinite',
  'spin-24': 'spin 24s linear infinite',
  'spin-30': 'spin 30s linear infinite',
  wiggle: 'wiggle 1s ease-in-out infinite',
  'wiggle-fade': 'wiggle-fade 1s ease-in-out infinite',
  slide: 'slide 1s ease-in-out infinite',
  'slide-left': 'slide-left 1s ease-in-out infinite',
  'park-car': 'park-car 5s ease-in-out infinite',
  'slide-right': 'slide-right 1s linear infinite',
  blink: 'blink 2s linear infinite',
  breathe: 'breathe 6s ease-in-out infinite',
  'move-right-12': 'move-right 12s ease-in-out infinite',
  'move-right-24': 'move-right 24s ease-in-out infinite',
  'move-right-36': 'move-right 36s ease-in-out infinite',
  'move-right-48': 'move-right 48s ease-in-out infinite',
  'move-right-60': 'move-right 60s ease-in-out infinite',
}
export const keyframesConfig = {
  'reverse-spin': {
    from: {
      transform: 'rotate(360deg)',
    },
  },
  wiggle: {
    '0%, 100%': { transform: 'rotate(-3deg)' },
    '50%': { transform: 'rotate(3deg)' },
  },
  'wiggle-fade': {
    '0%, 100%': { transform: 'rotate(-3deg)', opacity: '0.4' },
    '50%': { transform: 'rotate(3deg)', opacity: '0.9' },
  },
  blink: {
    '0%, 49%': { opacity: '1' },
    '50%, 100%': { opacity: '0' },
  },

  slide: {
    '0%': { opacity: '1' },
    '100%': { transform: 'translateX(25%)' },
  },
  'move-right': {
    '0%': {
      left: '20%',
      opacity: '0',
    },
    '10%, 90%': {
      opacity: '1',
    },
    '100%': {
      left: '80%',
      opacity: '0',
    },
  },
  'park-car': {
    '0%': {
      transform: ' translateX(-150%) translateY(150%) rotate(90deg)',
    },
    '30%': {
      transform: ' translateY(-10%) rotate(0deg)',
    },
    '40%, 60%': {
      transform: ' translateX(0%) rotate(0deg)',
    },
    '100%': {
      transform: ' translateX(100%) translateY(150%)  rotate(-90deg)',
    },
  },
  'slide-right': {
    '40%,60%': {
      opacity: '1',
    },
    '46%': { transform: 'translateX(25%)', opacity: '0' },
    '54%': {
      transform: 'translateX(-25%)',
      opacity: '0',
    },
  },
  'slide-left': {
    '40%,60%': {
      opacity: '1',
    },
    '46%': { transform: 'translateX(-25%)', opacity: '0' },
    '54%': {
      transform: 'translateX(25%)',
      opacity: '0',
    },
  },
  breathe: {
    '0%, 100%': { transform: 'scale(1)', opacity: '0.1' },
    '60%': {
      transform: 'scale(1.5)',
      opacity: '1',
    },
  },
}

const template = {
  DEFAULT: '40%',
  25: '98%',
  50: '95%',
  100: '92%',
  200: '86%',
  300: '78%',
  400: '66%',
  500: '50%',
  600: '36%',
  700: '24%',
  800: '12%',
  900: '04%',
}

export const colorGen = ({ saturation = '100%', hue, lightness = template }) =>
  Object.entries(lightness)
    .map(([key, item]) => ({
      [key]: `hsl(${hue}, ${saturation}, ${item})`,
    }))
    .reduce((obj, item) => Object.assign(obj, item), {})

export const spacingConfig = {
  112: '28rem',
  128: '32rem',
  144: '36rem',
  160: '40rem',
  192: '48rem',
}

export const colorsConfig = {
  transparent: colors.transparent,
  black: colors.black,
  white: colors.white,
  primary: primaryPallete,
  red: redPallete,
  green: greenPallete,
  gray: grayPallete,
  accent: colors.black,
}
</file>

<file path="libs/ui/.eslintrc.json">
{
  "extends": "next/core-web-vitals"
}
</file>

<file path="libs/ui/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="libs/ui/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;
</file>

<file path="libs/ui/package.json">
{
  "name": "@autospace/ui",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@autospace/forms": "*",
    "@autospace/util": "*",
    "@emotion/react": "^11.11.4",
    "@emotion/styled": "^11.11.5",
    "@headlessui/react": "^2.0.3",
    "@mapbox/polyline": "^1.2.1",
    "@mui/material": "^5.15.17",
    "@stripe/stripe-js": "^3.4.0",
    "mapbox-gl": "^3.3.0",
    "next": "14.2.3",
    "react": "^18",
    "react-dom": "^18",
    "react-map-gl": "^7.1.7",
    "react-toastify": "^10.0.5"
  },
  "devDependencies": {
    "@types/mapbox__polyline": "^1.0.5",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "14.2.3",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}
</file>

<file path="libs/ui/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="libs/ui/README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="libs/ui/tailwind.config.ts">
import type { Config } from 'tailwindcss'
import {
  colorsConfig,
  spacingConfig,
  animationConfig,
  keyframesConfig,
} from './src/styles/config'

const config: Config = {
  important: true,
  content: ['./src/components/**/*.{js,ts,jsx,tsx}'],

  theme: {
    colors: colorsConfig,
    extend: {
      ringColor: {
        DEFAULT: colorsConfig.primary.DEFAULT,
      },
      outlineColor: {
        DEFAULT: colorsConfig.primary.DEFAULT,
      },
      borderRadius: {
        DEFAULT: '0',
      },
      spacing: spacingConfig,
      animation: animationConfig,
      keyframes: keyframesConfig,
    },
  },
  plugins: [],
}
export default config
</file>

<file path="libs/ui/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="libs/ui/types.d.ts">
import '@autospace/network/next-auth'
</file>

<file path="libs/util/hooks/async.ts">
import { useEffect, useState } from 'react'

export const useDebounce = <T>(
  value: T,
  delay = 1000,
): [T, { debouncing: boolean }] => {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)
  const [debouncing, setDebouncing] = useState<boolean>(false)

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
      setDebouncing(false)
    }, delay)

    setDebouncing(true)

    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])

  return [debouncedValue, { debouncing }]
}
</file>

<file path="libs/util/hooks/cloudinary.ts">
import { useState } from 'react'

export const useCloudinaryUpload = () => {
  const [uploading, setUploading] = useState(false)

  const upload = async (fileList: FileList) => {
    setUploading(true)

    try {
      const uploadPromises = Array.from(fileList).map(async (file) => {
        const formData = new FormData()
        formData.append('file', file)
        formData.append(
          'upload_preset',
          process.env.NEXT_PUBLIC_CLOUDINARY_UPLOAD_PRESET || '',
        )

        const response = await fetch(
          `https://api.cloudinary.com/v1_1/${process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME}/image/upload`,
          {
            method: 'POST',
            body: formData,
          },
        )

        if (!response.ok) {
          throw new Error('Upload failed')
        }

        const data = await response.json()
        const imageUrl = data.secure_url as string

        return imageUrl
      })

      const uploadedImages = await Promise.all(uploadPromises)
      return uploadedImages
    } catch (error) {
      throw new Error('Upload failed')
    } finally {
      setUploading(false)
    }
  }

  return { upload, uploading }
}
</file>

<file path="libs/util/hooks/dialog.ts">
import { usePathname } from 'next/navigation'
import { useEffect, useRef, useState } from 'react'

export const useDialogState = (defaultState = false) => {
  const [open, setOpen] = useState(defaultState)

  const pathname = usePathname()
  const initialPathname = useRef(pathname)

  useEffect(() => {
    if (pathname !== initialPathname.current) {
      setOpen(false)
      initialPathname.current = pathname
    }
  }, [pathname, open])

  return [open, setOpen] as const
}
</file>

<file path="libs/util/hooks/directions.ts">
import { LatLng } from '../types'
import { useEffect, useState } from 'react'

export const useMapboxDirections = (
  start?: Partial<LatLng> | null,
  end?: Partial<LatLng> | null,
) => {
  const [data, setData] = useState<[number, number][]>([])
  const [distance, setDistance] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  useEffect(() => {
    if (!start || !end) {
      setData([])
      setDistance(null)
      return
    }
    setLoading(true)
    const fetchData = async () => {
      try {
        const response = await fetch(
          `https://api.mapbox.com/directions/v5/mapbox/driving/${start.lng},${start.lat};${end.lng},${end.lat}?access_token=${process.env.NEXT_PUBLIC_MAPBOX_TOKEN}&steps=true&overview=simplified`,
        )
        const data = await response.json()
        const coordinates =
          data?.routes[0]?.legs[0]?.steps?.map(
            (step: { maneuver: { location: any } }) => step.maneuver.location,
          ) || []
        setData(coordinates)
        setDistance(data.routes[0].distance)
      } catch (error: any) {
        setError(error)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
  }, [start, end])

  return { data, distance, loading, error }
}
</file>

<file path="libs/util/hooks/keys.ts">
import { useEffect } from 'react'

export const useKeypress = (keys: string[], action: () => void) => {
  useEffect(() => {
    const onKeyup = (e: { key: any }) => {
      if (keys.includes(e.key)) action()
    }
    window.addEventListener('keyup', onKeyup)
    return () => window.removeEventListener('keyup', onKeyup)
  }, [action, keys])
}
</file>

<file path="libs/util/hooks/location.ts">
import { useEffect, useState } from 'react'
import { LocationInfo } from '../types'
import { useDebounce } from './async'

export const useSearchLocation = () => {
  const [searchText, setSearchText] = useState('')
  const [loading, setLoading] = useState(false)
  const [locationInfo, setLocationInfo] = useState<LocationInfo[]>(() => [])

  const [debouncedSearchText] = useDebounce(searchText, 400)

  useEffect(() => {
    setLoading(true)

    fetch(
      `https://api.mapbox.com/geocoding/v5/mapbox.places/${debouncedSearchText}.json?fuzzyMatch=true&access_token=${process.env.NEXT_PUBLIC_MAPBOX_TOKEN}`,
    )
      .then((response) => response.json())
      .then((data) => {
        const filtered = data.features?.map((x: any) => ({
          placeName: x.place_name,
          latLng: [x.center[1], x.center[0]],
        }))

        setLocationInfo(filtered)
      })
      .finally(() => setLoading(false))
  }, [debouncedSearchText])
  return { loading, setLoading, searchText, setSearchText, locationInfo }
}
</file>

<file path="libs/util/hooks/pagination.ts">
import { TAKE_COUNT } from '../constants'
import { useState } from 'react'

export const useTakeSkip = (initialSkip = 0, initialTake = TAKE_COUNT) => {
  const [skip, setSkip] = useState(() => initialSkip)
  const [take, setTake] = useState(() => initialTake)

  return { take, skip, setTake, setSkip }
}
</file>

<file path="libs/util/hooks/price.ts">
import { FormTypeBookSlot } from '@autospace/forms/src/bookSlot'
import { useWatch } from 'react-hook-form'
import { useState, useEffect } from 'react'
import { differenceInTime } from '../date'
import { VALET_CHARGE_PER_METER } from '../constants'

export type TotalPriceType = {
  pricePerHour?: number
}

export const useTotalPrice = ({ pricePerHour }: TotalPriceType) => {
  const { startTime, endTime, valet } = useWatch<FormTypeBookSlot>()

  const [parkingCharge, setParkingCharge] = useState(0)
  const [valetChargePickup, setValetChargePickup] = useState(0)
  const [valetChargeDropoff, setValetChargeDropoff] = useState(0)

  useEffect(() => {
    if (!startTime || !endTime) return
    if (!pricePerHour) return

    const differenceInMilliseconds = differenceInTime({
      startTime: startTime,
      endTime: endTime,
    })
    const differenceInHours = differenceInMilliseconds / (60 * 60 * 1000)

    const parkingCharge = Math.floor((pricePerHour || 0) * differenceInHours)

    setParkingCharge(parkingCharge)
  }, [pricePerHour, startTime, endTime])

  useEffect(() => {
    const pickupCharge = valet?.pickupInfo?.distance
      ? valet?.pickupInfo?.distance * VALET_CHARGE_PER_METER
      : 0
    const dropoffCharge = valet?.dropoffInfo?.distance
      ? valet.dropoffInfo.distance * VALET_CHARGE_PER_METER
      : 0

    setValetChargePickup(Math.floor(pickupCharge))
    setValetChargeDropoff(
      Math.floor(valet?.differentLocations ? dropoffCharge : pickupCharge),
    )
  }, [valet])

  return {
    parkingCharge,
    valetChargePickup,
    valetChargeDropoff,
  }
}
</file>

<file path="libs/util/constants.ts">
import { LocationInfo } from './types'

export const initialViewState = {
  latitude: 40.7128,
  longitude: -74.006,
  zoom: 11.5,
}

export const majorCitiesLocationInfo: LocationInfo[] = [
  {
    placeName: 'Chennai, Tamil Nadu, India',
    latLng: [13.0827, 80.2707],
  },
  {
    placeName: 'New York, New York, United States',
    latLng: [40.7128, -74.006],
  },
  {
    placeName: 'London, Greater London, England, United Kingdom',
    latLng: [51.5074, -0.1278],
  },
  {
    placeName: 'Paris, France',
    latLng: [48.8566, 2.3522],
  },
  {
    placeName: 'Berlin, Germany',
    latLng: [52.52, 13.405],
  },
  {
    placeName: 'Sydney, New South Wales, Australia',
    latLng: [-33.8688, 151.2093],
  },
  {
    placeName: 'Rio de Janeiro, Brazil',
    latLng: [-22.9068, -43.1729],
  },
  {
    placeName: 'Cape Town, Western Cape, South Africa',
    latLng: [-33.9249, 18.4241],
  },
  {
    placeName: 'Moscow, Russia',
    latLng: [55.7558, 37.6176],
  },
  {
    placeName: 'Beijing, China',
    latLng: [39.9042, 116.4074],
  },
]

export const VALET_CHARGE_PER_METER = 0.005

export const TAKE_COUNT = 12
</file>

<file path="libs/util/date.ts">
import { format } from 'date-fns'
import pluralize from 'pluralize'

export const toLocalISOString = (date: Date): string => {
  const tzoffset = date.getTimezoneOffset() * 60000 // offset in milliseconds
  const localISOTime = new Date(date.getTime() - tzoffset).toISOString()

  return localISOTime
}

export const formatDate = (date: string) => {
  const dateObj = new Date(date)
  return format(dateObj, 'dd MMM yy')
}

export const formatTime = (date: string) => {
  const dateObj = new Date(date)
  return format(dateObj, 'HH:mm')
}

export const differenceInTime = ({
  startTime,
  endTime,
  unit = 'milliseconds',
}: {
  startTime: string
  endTime: string
  unit?: 'milliseconds' | 'seconds' | 'minutes' | 'hours'
}) => {
  const diffInMs = new Date(endTime).getTime() - new Date(startTime).getTime()
  switch (unit) {
    case 'milliseconds':
      return diffInMs
    case 'seconds':
      return diffInMs / 1000
    case 'minutes':
      return diffInMs / 1000 / 60
    case 'hours':
      return diffInMs / 1000 / 60 / 60
    default:
      throw new Error(`Invalid time unit: ${unit}`)
  }
}

export const getTimeUnits = (timeInSeconds: number) => {
  let timeString = ''

  timeInSeconds = timeInSeconds / 1000

  const days = Math.floor(timeInSeconds / 86400)
  timeInSeconds -= days * 86400
  if (days > 0) {
    timeString += `${days} ${pluralize('day', days)}`
  }

  const hours = Math.floor(timeInSeconds / 3600)
  timeInSeconds -= hours * 3600
  if (hours > 0) {
    if (timeString.length > 0) {
      timeString += ' '
    }
    timeString += `${hours} ${pluralize('hour', hours)}`
  }

  const minutes = Math.floor(timeInSeconds / 60)
  timeInSeconds -= minutes * 60
  if (minutes > 0) {
    if (timeString.length > 0) {
      timeString += ' '
    }
    timeString += `${minutes} ${pluralize('minute', minutes)}`
  }

  return {
    days,
    hours,
    minutes,
    timeString,
  }
}
</file>

<file path="libs/util/index.ts">
import { LatLng } from './types'

export const isLatLng = (obj?: Partial<LatLng> | null): obj is LatLng => {
  return obj?.lat !== undefined && obj?.lng !== undefined
}
</file>

<file path="libs/util/package.json">
{
  "name": "@autospace/util",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "dependencies": {
    "date-fns": "^3.6.0",
    "pluralize": "^8.0.0"
  },
  "devDependencies": {
    "@types/pluralize": "^0.0.33"
  }
}
</file>

<file path="libs/util/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": ".",
    "esModuleInterop": true,
    "jsx": "react-jsx"
  }
}
</file>

<file path="libs/util/types.ts">
import { ReactNode } from 'react'

export type Role = 'admin' | 'manager' | 'valet'

export type BaseComponent = {
  children?: ReactNode
  className?: string
}

export type MenuItem = { label: string; href: string }

export type ViewState = {
  latitude: number
  longitude: number
  zoom?: number
}

export type LocationInfo = { placeName: string; latLng: [number, number] }

export type TotalPrice = {
  parkingCharge: number
  valetChargeDropoff: number
  valetChargePickup: number
}

export type LatLng = {
  lat: number
  lng: number
}

export type LngLatTuple = [number, number]
</file>

<file path=".gitignore">
node_modules
build
dist
.next
.env


.nx/cache
</file>

<file path=".prettierrc">
{
  "singleQuote": true,
  "trailingComma": "all",
  "semi": false
}
</file>

<file path="nx.json">
{
  "$schema": "./node_modules/nx/schemas/nx-schema.json",
  "targetDefaults": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["{projectRoot}/.next, build, dist"],
      "cache": true
    },
    "dev": {
      "dependsOn": ["^dev"]
    },
    "lint": {
      "dependsOn": ["^lint"],
      "cache": true
    },
    "tsc": {
      "dependsOn": ["^tsc"],
      "cache": true
    }
  },
  "defaultBase": "main",
  "nxCloudAccessToken": "YjRmOGQ1ZDUtYWRkMi00MDQ3LWFiMGQtOGU4NzE0ZDRhZWEzfHJlYWQtd3JpdGU="
}
</file>

<file path="package.json">
{
  "name": "autospace",
  "version": "1.0.0",
  "description": "",
  "private": true,
  "workspaces": {
    "packages": [
      "apps/*",
      "libs/*"
    ],
    "nohoist": [
      "**/@nestjs",
      "**/@nestjs/**"
    ]
  },
  "scripts": {
    "format": "prettier  \"{apps,libs}/**/*.{ts,tsx,js,json}\" --ignore-path .gitignore",
    "format:check": "yarn format --check",
    "format:write": "yarn format --write",
    "tsc": "yarn nx run-many -t tsc",
    "lint": "yarn nx run-many -t lint",
    "build": "yarn nx run-many -t build",
    "validate": "yarn format:write && yarn tsc && yarn lint && yarn build",
    "prepare": "husky install",
    "cloc": "npx cloc --exclude-dir=node_modules,dist,build,yarn.lock,package.json,generated.tsx,.next,.nx ."
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "prettier": "^2.3.2",
    "typescript": "^5.4.3",
    "husky": "^8.0.0",
    "nx": "18.3.4"
  }
}
</file>

<file path="README.md">
# Autospace Workshop

This repository contains the Autospace Workshop project, which includes multiple applications and libraries. This guide will help you set up the project locally and run the applications.

## Prerequisites

Before you begin, ensure you have the following installed on your system:

- Node.js (>= 14.x)
- Yarn (>= 1.22.x)
- Docker
- Git

## Getting Started

### 1. Clone the Repository

Clone the repository to your local machine using Git.

```bash
git clone https://github.com/karthickthankyou/autospace-workshop.git
cd autospace-workshop
```

### 2. Install Dependencies

Install the project dependencies using Yarn.

```
yarn install
```

### 3. Set Up Environment Variables

Create a .env file in the root directory and add the necessary environment variables. Refer to .env.example for the required variables.

### 4. Run the Database with Docker Compose

Start the PostgreSQL database using Docker Compose.

```
docker-compose up -d
```

### 5. Run Prisma Migrations

After the database is running, apply Prisma migrations to set up the database schema.

```
yarn prisma migrate dev
```

### 6. Run the Applications

You can run the individual applications using the following commands:

#### API Application

Navigate to the apps/api directory and start the API server.

```
cd apps/api
yarn dev
```

#### WEB Applications

Navigate to the apps/web directory and start the WEB server.

```
cd apps/web
yarn dev
```

License
This project is licensed under the MIT License.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "CommonJS",
    "strict": true
  },
  "exclude": ["node_modules"]
}
</file>

</files>
